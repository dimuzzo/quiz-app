{
  "global": {
    "back_to_home": "‚Üê Back to homepage",
    "show_answer": "Show Answer",
    "next": "Next ‚Üí",
    "stop_quiz": "Stop Quiz",
    "restart_quiz": "üîÑ Restart Quiz",
    "previous": "‚Üê Previous",
    "correct": "Correct",
    "incorrect": "Incorrect",
    "question_progress": "Question {current} of {total}",
    "go_to": "Go to:",
    "quiz_finished": "Quiz Finished!",
    "score_summary": "Here is the summary of your session.",
    "total_score": "Total Score",
    "correct_total": "Correct (out of Total)",
    "incorrect_total": "Incorrect (out of Total)",
    "correct_answered": "Correct / Answered",
    "incorrect_answered": "Incorrect / Answered",
    "finish_quiz_button": "üèÅ Finish Quiz",
    "select_answer_alert": "Please select an answer first.",
    "true_option": "‚úì True",
    "false_option": "‚úó False",
    "explanation": "Explanation:"
  },
  "home": {
    "main_title": "üéì Exam Quizzes",
    "subtitle": "Choose the type of quiz you want to take",
    "theory_title": "Software Application Development - Theory",
    "theory_desc": "Test your knowledge on the fundamental concepts of software application development.",
    "theory_prompt": "Choose the number of questions:",
    "theory_20": "20 Questions",
    "theory_50": "50 Questions",
    "theory_100": "100 Questions",
    "theory_all": "All Questions",
    "pattern_title": "Software Application Development - Design Patterns",
    "pattern_desc": "Deepen your understanding of design patterns, from GRASP to GoF, and how to apply them.",
    "network_title": "Computer Network Technologies and Services",
    "network_desc": "Test your skills on protocols, architecture, and network technologies."
  },
  "pattern_page": {
    "title": "üèóÔ∏è Software Application Development - Design Patterns Quiz"
  },
  "theory_page": {
    "title": "üìö Software Application Development - Theory Quiz",
    "question_title": "Question {number}"
  },
  "network_page": {
    "title": "üåê Computer Network Technologies and Services - Quiz",
    "question_title": "Question {number}"
  },
  "questions": {
    "pattern": [
      { "pattern": "Creator", "category": "GRASP", "type": "Problem-Solution", "question": "What problem does the Creator pattern solve?", "options": ["Who should be responsible for creating instances of a class?", "How to maintain low coupling between classes?", "How to assign responsibilities to objects?", "How to manage communication between objects?"], "correct": 0, "explanation": "The Creator pattern addresses the problem of determining which class should be responsible for creating instances of other classes." },
      { "pattern": "Information Expert", "category": "GRASP", "type": "Problem-Solution", "question": "What solution does the Information Expert pattern propose?", "options": ["Centralize all information in one class", "Assign responsibility to the class that has the necessary information", "Create a dedicated class for each type of information", "Use global variables to share information"], "correct": 1, "explanation": "Information Expert suggests assigning responsibility to the class that has the information necessary to fulfill it." },
      { "pattern": "Low Coupling", "category": "GRASP", "type": "Problem-Solution", "question": "What problem does the Low Coupling pattern address?", "options": ["How to increase dependency between classes?", "How to reduce the impact of changes and increase reuse?", "How to centralize responsibilities?", "How to increase system performance?"], "correct": 1, "explanation": "Low Coupling aims to reduce dependencies between classes to minimize the impact of changes and promote reuse." },
      { "pattern": "High Cohesion", "category": "GRASP", "type": "Problem-Solution", "question": "What does the High Cohesion pattern promote?", "options": ["Classes with very different responsibilities", "Classes with closely related and focused responsibilities", "Classes with many external dependencies", "Classes with very long and complex methods"], "correct": 1, "explanation": "High Cohesion promotes classes with closely related and well-focused responsibilities, making the code more understandable and maintainable." },
      { "pattern": "Controller", "category": "GRASP", "type": "Problem-Solution", "question": "What problem does the Controller pattern solve?", "options": ["How to manage the user interface?", "Who should handle system input events?", "How to implement data persistence?", "How to optimize database performance?"], "correct": 1, "explanation": "The Controller pattern determines which object should receive and coordinate (control) system input events." },
      { "pattern": "Singleton", "category": "GoF Creational", "type": "Problem-Solution", "question": "What problem does the Singleton pattern solve?", "options": ["How to create families of related objects?", "How to ensure a class has only one instance?", "How to separate the construction of complex objects?", "How to clone prototype objects?"], "correct": 1, "explanation": "Singleton ensures that a class has only one instance and provides a global point of access to it." },
      { "pattern": "Abstract Factory", "category": "GoF Creational", "type": "Problem-Solution", "question": "What solution does the Abstract Factory pattern provide?", "options": ["Creates a single global instance", "Provides an interface for creating families of related objects", "Separates the algorithm from the data structure", "Allows adding new operations without modifying classes"], "correct": 1, "explanation": "Abstract Factory provides an interface for creating families of related or dependent objects without specifying their concrete classes." },
      { "pattern": "Adapter", "category": "GoF Structural", "type": "Problem-Solution", "question": "What problem does the Adapter pattern solve?", "options": ["How to compose objects into tree structures?", "How to allow classes with incompatible interfaces to work together?", "How to add responsibilities to objects dynamically?", "How to efficiently share similar objects?"], "correct": 1, "explanation": "Adapter allows classes with incompatible interfaces to work together by acting as a bridge between them." },
      { "pattern": "Composite", "category": "GoF Structural", "type": "Problem-Solution", "question": "What structure does the Composite pattern create?", "options": ["A chain of linked objects", "A tree structure of objects", "A stack of objects", "A map of key-value objects"], "correct": 1, "explanation": "Composite allows composing objects into tree structures to represent part-whole hierarchies." },
      { "pattern": "Decorator", "category": "GoF Structural", "type": "Problem-Solution", "question": "How does the Decorator pattern work?", "options": ["It directly modifies the original class", "It wraps the original object in one or more wrappers", "It completely replaces the original object", "It creates a modified copy of the object"], "correct": 1, "explanation": "Decorator allows adding new functionalities to objects by wrapping them in wrappers that contain the new behaviors." },
      { "pattern": "Observer", "category": "GoF Behavioral", "type": "Problem-Solution", "question": "What problem does the Observer pattern solve?", "options": ["How to iterate through a collection?", "How to automatically notify multiple objects when state changes?", "How to encapsulate interchangeable algorithms?", "How to handle requests in a chain of handlers?"], "correct": 1, "explanation": "Observer defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically." },
      { "pattern": "State", "category": "GoF Behavioral", "type": "Problem-Solution", "question": "What solution does the State pattern propose?", "options": ["Use a large switch/if to manage states", "Encapsulate each state in a separate class", "Store all states in an array", "Completely ignore the concept of state"], "correct": 1, "explanation": "State allows an object to alter its behavior when its internal state changes, encapsulating each state in a separate class." },
      { "pattern": "Strategy", "category": "GoF Behavioral", "type": "Problem-Solution", "question": "What problem does the Strategy pattern address?", "options": ["How to manage notifications between objects?", "How to make algorithms interchangeable at runtime?", "How to visit elements of a complex structure?", "How to manage complex states of an object?"], "correct": 1, "explanation": "Strategy defines a family of algorithms, encapsulates each one, and makes them interchangeable during execution." },
      { "pattern": "Visitor", "category": "GoF Behavioral", "type": "Problem-Solution", "question": "What advantage does the Visitor pattern offer?", "options": ["Simplifies the structure of the visited objects", "Allows adding new operations without modifying the existing classes", "Reduces the number of classes in the system", "Improves data access performance"], "correct": 1, "explanation": "Visitor allows defining new operations without changing the classes of the elements on which it operates, separating algorithms from the structure." },
      { "pattern": "Creator", "category": "GRASP", "type": "UML", "question": "In the Creator pattern's UML diagram, what relationship is typically shown?", "options": ["Inheritance between creator and product", "Composition or aggregation between creator and product", "Bidirectional association", "Circular dependency"], "correct": 1, "explanation": "The Creator typically has a composition or aggregation relationship with the objects it creates, shown with a filled or empty diamond." },
      { "pattern": "Singleton", "category": "GoF Creational", "type": "UML", "question": "How is the constructor represented in the Singleton's UML diagram?", "options": ["Public (+)", "Private (-)", "Protected (#)", "Static (underlined)"], "correct": 1, "explanation": "In Singleton, the constructor is private (-) to prevent direct instantiation from outside the class." },
      { "pattern": "Observer", "category": "GoF Behavioral", "type": "UML", "question": "In the Observer pattern, what interface do observers typically implement?", "options": ["Subject", "Observer or Listener", "ConcreteSubject", "Publisher"], "correct": 1, "explanation": "Observers implement an Observer (or Listener) interface that defines the update() method for receiving notifications." },
      { "pattern": "Strategy", "category": "GoF Behavioral", "type": "UML", "question": "In the Strategy pattern's UML diagram, what kind of relationship does the Context have with the Strategy?", "options": ["Inheritance", "Composition", "Realization", "Simple dependency"], "correct": 3, "explanation": "The Context uses the Strategy interface to delegate the algorithm's execution, establishing a simple dependency. This allows the Context to flexibly vary the concrete algorithm." },
      { "pattern": "Composite", "category": "GoF Structural", "type": "UML", "question": "In the Composite pattern, how is the relationship between Composite and Component shown?", "options": ["Simple aggregation", "Recursive composition (Composite contains Component)", "Multiple inheritance", "Bidirectional association"], "correct": 1, "explanation": "Composite inherits from Component and also contains a collection of Components, creating a recursive structure." },
      { "pattern": "Decorator", "category": "GoF Structural", "type": "UML", "question": "In the Decorator pattern, what is a characteristic of the Decorator class?", "options": ["It is final and cannot be extended", "It implements the same interface as the decorated component", "It is static and contains only utility methods", "It is abstract and cannot be instantiated"], "correct": 1, "explanation": "Decorator implements the same interface as the component it decorates, allowing it to be substituted transparently." }
    ],
    "theory": [
      { "id": 1, "text": "In UP, the requirements discipline aims to produce a list of requirements, understand the system context, and capture functional and non-functional requirements", "correct": true, "explanation": "The requirements discipline in UP indeed has as its main objectives: to produce a list of requirements, understand the system context, and capture both functional and non-functional requirements." },
      { "id": 2, "text": "The domain model includes the definition of objects, associations, and attributes of software classes", "correct": false, "explanation": "The domain model represents CONCEPTUAL classes of the problem domain, not software classes. It includes conceptual objects, associations, and attributes from the real world." },
      { "id": 3, "text": "The domain model is a visual dictionary of conceptual classes", "correct": true, "explanation": "Correct. The domain model is a visual representation (visual dictionary) of the relevant conceptual classes in the problem domain." },
      { "id": 4, "text": "The domain model is a textual representation of conceptual classes, real objects of the domain", "correct": false, "explanation": "The domain model is a VISUAL (not textual) representation of conceptual classes. It uses UML diagrams to graphically represent the concepts." },
      { "id": 5, "text": "The domain model is not part of the requirements discipline", "correct": true, "explanation": "The domain model is part of the Business Modeling discipline in UP. It helps to understand and document the concepts of the problem domain." },
      { "id": 6, "text": "In domain model associations, the reading direction must always be specified", "correct": false, "explanation": "The reading direction in domain model associations does NOT always need to be specified. It is optional and used only when necessary to clarify the meaning of the association." },
      { "id": 7, "text": "The association in the domain model is by its nature unidirectional", "correct": false, "explanation": "Associations in the domain model are by nature BIDIRECTIONAL. They represent conceptual relationships that can be navigated in both directions." },
      { "id": 8, "text": "The association in the domain model represents a meaningful relationship between classes", "correct": true, "explanation": "Correct. Associations in the domain model represent meaningful and relevant relationships between the conceptual classes of the domain." },
      { "id": 9, "text": "The association in the domain model represents a logical value of the objects of a class", "correct": false, "explanation": "Associations represent RELATIONSHIPS between classes, not logical values of objects. Logical values are represented by attributes." },
      { "id": 10, "text": "The association in the domain model represents a set of n-tuples of objects of the classes", "correct": true, "explanation": "Mathematically, an association can be seen as a set of n-tuples (pairs, triples, etc.) of objects from the classes involved in the relationship." },
      { "id": 11, "text": "THE DOMAIN MODEL: A set of UML class diagrams that include associations between software classes", "correct": false, "explanation": "The domain model includes associations between CONCEPTUAL classes, not software classes. Software classes belong to the design model." },
      { "id": 12, "text": "THE DOMAIN MODEL: A graphical representation of software objects", "correct": false, "explanation": "The domain model represents CONCEPTUAL objects of the problem domain, not software objects which belong to the implementation." },
      { "id": 13, "text": "THE DOMAIN MODEL: A visual representation of conceptual classes", "correct": true, "explanation": "Correct. The domain model is a visual representation of the relevant conceptual classes in the problem domain." },
      { "id": 14, "text": "THE DOMAIN MODEL: A set of UML class diagrams that include associations between conceptual classes", "correct": true, "explanation": "Correct. The domain model uses UML class diagrams to represent conceptual classes and their associations." },
      { "id": 15, "text": "THE DOMAIN MODEL: A visual representation of JAVA classes", "correct": false, "explanation": "The domain model represents CONCEPTUAL classes of the domain, not Java classes which are part of the software implementation." },
      { "id": 16, "text": "THE DOMAIN MODEL: A set of UML class diagrams that include 'doing' responsibilities", "correct": false, "explanation": "The domain model does NOT include 'doing' responsibilities (methods). Responsibilities are assigned during the design phase, not in the domain analysis." },
      { "id": 17, "text": "A use case represents a way a user uses the system to achieve a goal", "correct": true, "explanation": "Correct. A use case describes how an actor (user) interacts with the system to achieve a specific goal." },
      { "id": 18, "text": "The narrative of a use case is expressed at the level of the user's intentions and the system's responsibility", "correct": true, "explanation": "Correct. Use cases are written from the perspective of the user's intentions and the responsibilities the system must undertake to satisfy them." },
      { "id": 19, "text": "The narrative of a use case is expressed at the level of the user's concrete actions and the system's responsibilities", "correct": false, "explanation": "Use cases are written at the level of user INTENTIONS, not concrete actions. Concrete actions belong to a too-low level of detail." },
      { "id": 20, "text": "A use case is always completed (implemented) in a single iteration", "correct": false, "explanation": "A use case can be implemented over multiple iterations. Often, the basic scenarios are implemented first, followed by the alternative ones." },
      { "id": 21, "text": "A use case represents the set of all functionalities of a system", "correct": false, "explanation": "A use case represents A SPECIFIC WAY of using the system to achieve a goal, not the set of all its features." },
      { "id": 22, "text": "Functional requirements not captured by use cases are described in the supplementary specifications", "correct": true, "explanation": "Correct. The supplementary specifications document functional requirements that are not captured by use cases (e.g., reports, file formats, etc.)." },
      { "id": 23, "text": "Linguistic analysis of use cases in detailed format is a source of inspiration for building the domain model", "correct": true, "explanation": "Correct. Analyzing the nouns and concepts in detailed use cases helps to identify conceptual classes for the domain model." },
      { "id": 24, "text": "The domain model reports the significant concepts related to the use cases", "correct": true, "explanation": "Correct. The domain model includes the domain concepts that are relevant to the system's use cases." },
      { "id": 25, "text": "Non-functional requirements are fully described by use cases", "correct": false, "explanation": "Use cases primarily capture FUNCTIONAL requirements. Non-functional requirements (performance, security, usability) are documented in the supplementary specifications." },
      { "id": 26, "text": "Contracts are considered part of the use case model because they provide more analysis details on the effect of system operations implied by the use cases", "correct": true, "explanation": "Correct. System operation contracts provide additional details on the effects of the operations identified in the use cases." },
      { "id": 27, "text": "USE CASES are a collection of success scenarios only that describe an actor using the system to achieve a specific goal", "correct": false, "explanation": "Use cases include both SUCCESS scenarios and ALTERNATIVE scenarios (including failure scenarios). They are not limited to success scenarios only." },
      { "id": 28, "text": "Use cases are textual descriptions of interesting usage scenarios of the software system to be built", "correct": true, "explanation": "Correct. Use cases are textual descriptions that document significant usage scenarios of the system under development." },
      { "id": 29, "text": "Use cases are used to capture functional requirements", "correct": true, "explanation": "Correct. The main purpose of use cases is to capture and document the system's functional requirements." },
      { "id": 30, "text": "In UP, use cases are used to capture functional requirements in the requirements discipline", "correct": true, "explanation": "Correct. In the Unified Process, use cases are the primary tool for capturing functional requirements during the requirements discipline." },
      { "id": 31, "text": "Use cases are features of the system", "correct": false, "explanation": "Use cases are NOT system features, but describe HOW the system is used by actors to achieve specific goals." },
      { "id": 32, "text": "Use cases are used to plan iterations", "correct": true, "explanation": "Correct. Use cases are used to organize and plan development iterations, with the most critical use cases being implemented in the early iterations." },
      { "id": 33, "text": "In UP, use cases are described using the UML language", "correct": false, "explanation": "In UP, use cases are described primarily in NATURAL language (text), not in UML. UML only provides use case diagrams to show relationships." },
      { "id": 34, "text": "DURING THE ELABORATION PHASE: About 10% of the most critical use cases are written in a detailed format using specific templates", "correct": false, "explanation": "During Inception, about 10% of the most critical and risky use cases are detailed to guide the architecture. The Elaboration phase is when most requirements are clarified and stabilized, leading to a much higher percentage (40-80%) of detailed use cases by the end of this phase." },
      { "id": 35, "text": "As a percentage of the total use cases in a project, should 5% be completed by the end of the inception phase?", "correct": true, "explanation": "Correct. During the inception phase, about 5% of all identified use cases are typically implemented." },
      { "id": 36, "text": "Use cases highlight user goals", "correct": true, "explanation": "Correct. Use cases are organized around the goals that users (actors) want to achieve by using the system." },
      { "id": 37, "text": "Use cases are used for the discovery and definition of non-functional requirements", "correct": false, "explanation": "Use cases are primarily used for FUNCTIONAL requirements. Non-functional requirements are documented in the supplementary specifications." },
      { "id": 38, "text": "Use cases are used for the discovery and definition of functional requirements", "correct": true, "explanation": "Correct. Use cases are the main tool for discovering, defining, and documenting the system's functional requirements." },
      { "id": 39, "text": "Use cases highlight system goals", "correct": false, "explanation": "Use cases highlight USER (actor) goals, not system goals. The system responds to user goals." },
      { "id": 40, "text": "Use cases are used only in the first development iterations", "correct": false, "explanation": "Use cases are used throughout the ENTIRE development process, not just in the early iterations. They guide implementation, testing, and validation." },
      { "id": 41, "text": "The main input for writing contracts are system operations and the domain model", "correct": true, "explanation": "Correct. Contracts are written for the system operations identified in SSDs, using the domain model to describe the effects." },
      { "id": 42, "text": "Post-conditions describe the state changes of objects in the domain model after the operation is completed", "correct": true, "explanation": "Correct. Post-conditions in contracts describe how the states of domain model objects change after the operation's execution." },
      { "id": 43, "text": "Contracts serve as input for the domain model", "correct": false, "explanation": "Contracts do NOT serve as input for the domain model. It's the other way around: the domain model serves as input for writing contracts." },
      { "id": 44, "text": "Responsibilities are assigned to the concepts defined in the domain model", "correct": false, "explanation": "Responsibilities are assigned to SOFTWARE CLASSES during design, not to the concepts in the domain model, which represents only the analysis." },
      { "id": 45, "text": "System operation contracts use pre- and post-conditions to detail the changes to (conceptual) objects in a domain model", "correct": true, "explanation": "Correct. Contracts use pre-conditions and post-conditions to describe in detail how system operations modify conceptual objects." },
      { "id": 46, "text": "Pre-conditions describe the state changes of objects in the domain model after the operation is completed", "correct": false, "explanation": "Pre-conditions describe the state that must exist BEFORE the operation. It is the POST-conditions that describe the changes after the operation." },
      { "id": 47, "text": "Object composition is statically defined through the specification of classes and associations", "correct": true, "explanation": "Correct. Composition is statically defined in the code through the definition of classes and their composition relationships." },
      { "id": 48, "text": "The specialization mechanism for code reuse is called white-box reuse", "correct": true, "explanation": "Correct. Inheritance (specialization) is called 'white-box' reuse because the subclass has visibility into the internal details of the superclass." },
      { "id": 49, "text": "Changing a class's interface generally has a low impact on its subclasses", "correct": false, "explanation": "Changing a class's interface generally has a HIGH impact on its subclasses, which depend on the superclass's interface." },
      { "id": 50, "text": "GRASP patterns are expressed in terms of responsibilities, roles, and collaborations", "correct": true, "explanation": "Correct. GRASP (General Responsibility Assignment Software Patterns) focus on the assignment of responsibilities, roles, and collaborations among objects." },
      { "id": 51, "text": "The decision on assigning responsibilities always precedes coding", "correct": false, "explanation": "Assigning responsibilities is part of the design (OOD) which logically precedes implementation/coding, but decisions on assigning responsibilities to objects can also be made while coding or during modeling." },
      { "id": 52, "text": "The use of GRASP patterns is carried out within the requirements discipline of UP", "correct": false, "explanation": "GRASP patterns are used in the DESIGN discipline, not the requirements discipline. They concern the assignment of responsibilities to software classes." },
      { "id": 53, "text": "Responsibilities are assigned to classes during OOD", "correct": true, "explanation": "Correct. Object-Oriented Design (OOD) is the phase where responsibilities are assigned to software classes using principles like the GRASP patterns." },
      { "id": 54, "text": "The delegation mechanism is preferable to the specialization mechanism for code reuse", "correct": true, "explanation": "Correct. Composition/delegation (black-box reuse) is generally preferable to inheritance because it is more flexible and maintains lower coupling." },
      { "id": 55, "text": "Inheritance respects encapsulation", "correct": false, "explanation": "Inheritance does NOT fully respect encapsulation because the subclass has access to the protected members of the superclass, breaking the encapsulation." },
      { "id": 56, "text": "Object composition is a code reuse mechanism called black-box reuse", "correct": true, "explanation": "Correct. Composition is called 'black-box' reuse because the component objects are used only through their public interfaces." },
      { "id": 57, "text": "A method of a software class represents a 'doing' responsibility for instances of that class", "correct": true, "explanation": "Correct. Methods represent the 'doing' responsibilities of a class, i.e., what objects of that class can do." },
      { "id": 58, "text": "DURING THE ELABORATION PHASE: No tests are performed on the development code", "correct": false, "explanation": "During the elaboration phase, tests ARE performed on the code. It's a phase where the architectural core is programmed and tested." },
      { "id": 59, "text": "DURING THE ELABORATION PHASE: No code is developed", "correct": false, "explanation": "During the elaboration phase, code IS developed. The architectural core of the system is programmed to validate the proposed architecture." },
      { "id": 60, "text": "DURING THE ELABORATION PHASE: Most of the requirements are discovered and stabilized", "correct": true, "explanation": "Correct. Elaboration is the phase where most requirements are discovered and stabilized, completing the analysis started in inception." },
      { "id": 61, "text": "DURING THE ELABORATION PHASE: A business case is created to establish the project's scope and costs", "correct": false, "explanation": "The preliminary business case is made during the INCEPTION phase, not elaboration. Elaboration refines the estimates." },
      { "id": 62, "text": "DURING THE ELABORATION PHASE: The risky core of the architecture is programmed", "correct": true, "explanation": "Correct. During elaboration, the architectural core of the system is programmed and tested, focusing on the riskiest parts." },
      { "id": 63, "text": "In UML, a responsibility means the specification of a method associated with a Java class", "correct": false, "explanation": "In UML, responsibility is a more general concept that includes both 'knowing' and 'doing'. It is not limited to just Java methods." },
      { "id": 64, "text": "In UML, a responsibility means the specification of an instance variable of a Java class", "correct": false, "explanation": "Instance variables are part of the 'knowing' responsibilities, but responsibility in UML is a broader concept that also includes actions." },
      { "id": 65, "text": "In UML, a responsibility means a contract or an obligation of a classifier", "correct": true, "explanation": "Correct. In UML, a responsibility is defined as a contract or obligation of a classifier (class), which includes both knowing and doing." },
      { "id": 66, "text": "In UML, a responsibility means the specification of an instance variable or a method associated with a Java class", "correct": false, "explanation": "Responsibility in UML is a more abstract concept of a contract/obligation, not simply the implementation in Java variables or methods." },
      { "id": 67, "text": "SSDs are expressed through UML communication diagrams", "correct": false, "explanation": "SSDs (System Sequence Diagrams) are expressed through UML SEQUENCE diagrams, not communication diagrams." },
      { "id": 68, "text": "SSDs show the order of events generated by actors external to the system", "correct": true, "explanation": "Correct. SSDs show the time sequence of system events generated by external actors for a specific use case scenario." },
      { "id": 69, "text": "Contracts are an input for SSDs of operations and for object design", "correct": false, "explanation": "It's the other way around: SSDs are input for contracts. SSDs identify the system operations, for which contracts are then written." },
      { "id": 70, "text": "A system event is an event internal to the system", "correct": false, "explanation": "A system event is an event that comes to the system from the OUTSIDE, generated by an external actor. Internal events are not system events." },
      { "id": 71, "text": "SSDs show events generated by actors external to the system", "correct": true, "explanation": "Correct. SSDs (System Sequence Diagrams) show the system events generated by external actors during the execution of a use case." },
      { "id": 72, "text": "As a percentage of the total functional requirements of a project, should 50% be identified by the end of the INCEPTION phase?", "correct": false, "explanation": "By the end of inception, about 70% of functional requirements should have been identified, not 50%. 50% is too little to complete inception." },
      { "id": 73, "text": "As a percentage of the total functional requirements of a project, should 100% be identified by the end of the ELABORATION phase?", "correct": true, "explanation": "Correct. By the end of elaboration, virtually all functional requirements should be identified to accurately plan the construction phase." },
      { "id": 74, "text": "White-box reuse is preferable to black-box reuse", "correct": false, "explanation": "Black-box reuse (composition) is generally preferable to white-box reuse (inheritance) because it offers greater flexibility and lower coupling." },
      { "id": 75, "text": "The inheritance mechanism is not preferable to the delegation mechanism for achieving software reuse", "correct": true, "explanation": "Correct. Delegation (composition) is often preferable to inheritance for reuse because it is more flexible and maintains lower coupling." },
      { "id": 76, "text": "Inheritance makes use of the delegation mechanism", "correct": false, "explanation": "Inheritance and delegation are ALTERNATIVE mechanisms for code reuse. Inheritance does not use delegation." },
      { "id": 77, "text": "The composition mechanism does not respect encapsulation", "correct": false, "explanation": "The composition mechanism DOES respect encapsulation because it accesses component objects only through their public interfaces." },
      { "id": 78, "text": "System operations can be identified while sketching SSDs", "correct": true, "explanation": "Correct. System operations are identified during the creation of SSDs, which show the events the system must handle." },
      { "id": 79, "text": "Contracts describe in detail the changes required by the execution of a system operation, they describe how these results should be obtained", "correct": false, "explanation": "Contracts describe WHAT must happen (post-conditions), but they do NOT describe HOW to achieve these results. The 'how' is part of the design." },
      { "id": 80, "text": "GoF patterns encourage the use of inheritance as a code reuse mechanism, particularly through the composite pattern", "correct": false, "explanation": "GoF patterns generally DISCOURAGE the overuse of inheritance for reuse, preferring composition. The Composite pattern uses inheritance for polymorphism, not for reuse." },
      { "id": 81, "text": "GoF patterns favor the use of the inheritance mechanism to achieve specialization", "correct": false, "explanation": "GoF patterns emphasize the principle 'favor composition over inheritance' - preferring composition to inheritance even for specialization." },
      { "id": 82, "text": "GoF patterns encourage software reuse mechanisms through the definition of class hierarchies", "correct": false, "explanation": "GoF patterns promote reuse through COMPOSITION and delegation, not through extensive class hierarchies." },
      { "id": 83, "text": "GoF patterns favor the use of the inheritance mechanism to achieve polymorphism", "correct": true, "explanation": "Correct. GoF patterns use inheritance primarily to achieve POLYMORPHISM (different behaviors with a common interface), not for code reuse." },
      { "id": 84, "text": "The GoF Composite pattern provides additional features to atomic elements (leaves), while maintaining a common interface", "correct": false, "explanation": "The Composite pattern does NOT provide additional features to leaves. It allows simple and composite objects to be treated uniformly." },
      { "id": 85, "text": "The GoF Composite pattern allows for the construction of class taxonomies", "correct": false, "explanation": "The Composite pattern allows for the construction of object TREES, not class taxonomies. Taxonomies are inheritance hierarchies." },
      { "id": 86, "text": "The GoF Composite pattern uses the specialization mechanism to make the interface of atomic entities exactly like the interface of composite entities", "correct": false, "explanation": "Composite uses generalization to make leaves and composite nodes implement the same interface, allowing for uniform treatment." },
      { "id": 87, "text": "The GoF Composite pattern allows avoiding subclass explosion to support a large number of extensions and their combinations", "correct": false, "explanation": "This is the DECORATOR pattern, not Composite. Composite organizes objects into tree structures, it does not prevent subclass explosion." },
      { "id": 88, "text": "The GoF Composite pattern allows for the construction of recursive structures so that to a client, the entire structure is seen as a single entity", "correct": true, "explanation": "Correct. The Composite pattern allows for the construction of tree structures where clients can treat simple and composite objects uniformly." },
      { "id": 89, "text": "Extreme programming promotes development followed by tests", "correct": false, "explanation": "XP promotes TDD (Test-Driven Development): tests are written first, THEN the code is written to make them pass. Tests precede development." },
      { "id": 90, "text": "Unit tests are intended to verify the communication between specific parts of the system", "correct": false, "explanation": "Unit tests verify the behavior of single UNITS (methods, classes) in isolation. Integration tests verify communication between parts." },
      { "id": 91, "text": "Setup, execution, verification, and teardown are the parts of a unit test", "correct": true, "explanation": "Correct. The typical phases of a unit test are: Setup, Exercise (execution), Verify, and Teardown (release)." },
      { "id": 92, "text": "Refactoring involves applying small transformations that preserve behavior", "correct": true, "explanation": "Correct. Refactoring consists of applying small transformations to the code that improve its structure without changing its external behavior." },
      { "id": 93, "text": "Unit tests are used to demonstrate that refactoring has not caused a regression", "correct": true, "explanation": "Correct. Unit tests serve as a safety net during refactoring, ensuring that the behavior remains unchanged." },
      { "id": 94, "text": "Object-oriented design in UP aims to identify responsibilities and assign them to an appropriate object or class", "correct": true, "explanation": "Correct. OOD in UP focuses on identifying software responsibilities and assigning them to the appropriate classes." },
      { "id": 95, "text": "Cohesion is the measure of how strongly an element is connected to, has knowledge of, and depends on other elements", "correct": false, "explanation": "This is the definition of COUPLING. Cohesion measures how strongly the responsibilities of a single element are related to each other." },
      { "id": 96, "text": "The GRASP patterns Information Expert and High Cohesion are evaluative patterns", "correct": false, "explanation": "Low Coupling and High Cohesion are evaluative GRASP patterns that provide criteria for evaluating the quality of design solutions." },
      { "id": 97, "text": "The creation of an object is the responsibility of an object that aggregates, contains an instance of the object to be created", "correct": true, "explanation": "Correct. According to the GRASP Creator pattern, the responsibility of creating an object often falls to the one that aggregates, contains, or intensively uses it." },
      { "id": 98, "text": "A class with high coupling does many unrelated things and performs too much work", "correct": false, "explanation": "This is the definition of low COHESION. High coupling indicates many dependencies on other classes, not necessarily many responsibilities." },
      { "id": 99, "text": "Refactoring is a practice promoted by the iterative and agile method XP", "correct": true, "explanation": "Correct. Refactoring is one of the fundamental practices of XP (Extreme Programming) and agile methods in general." },
      { "id": 100, "text": "Refactoring involves test-driven development, i.e., development preceded by tests", "correct": false, "explanation": "Refactoring and TDD are SEPARATE practices. Refactoring improves existing code; TDD is a development technique guided by tests." },
      { "id": 101, "text": "Refactoring is a structured and disciplined method for writing or restructuring existing code", "correct": true, "explanation": "Correct. Refactoring is a disciplined process for restructuring existing code, improving its structure without changing its behavior." },
      { "id": 102, "text": "DURING THE ELABORATION PHASE: Requirements and iterations are organized based on the end user's request", "correct": false, "explanation": "During elaboration, requirements are organized based on RISK and ARCHITECTURAL SIGNIFICANCE, not on the end user's requests." },
      { "id": 103, "text": "DURING THE ELABORATION PHASE: Requirements and iterations are organized based on risk, coverage (they must cover the entire system), and criticality", "correct": true, "explanation": "Correct. Elaboration organizes iterations based on risk, architectural criticality, and the need to cover all aspects of the system." },
      { "id": 104, "text": "DURING THE ELABORATION PHASE: Production-quality programming and testing activities are performed", "correct": true, "explanation": "Correct. During elaboration, production-quality code is developed for the architectural core, and appropriate tests are performed." },
      { "id": 105, "text": "DURING THE ELABORATION PHASE: 'Throwaway' prototypes are created to address major risks", "correct": false, "explanation": "During elaboration, the EVOLUTIONARY architectural core is developed, not 'throwaway' prototypes. Throwaway prototypes are typical of the inception phase." },
      { "id": 106, "text": "Responsibility is an abstraction of what a software object or component does or represents", "correct": true, "explanation": "Correct. Responsibility is an abstraction of what an object KNOWS or DOES." },
      { "id": 107, "text": "In Responsibility-Driven Development, software objects are considered to have responsibilities", "correct": true, "explanation": "Correct. RDD (Responsibility-Driven Development) views objects as entities that have specific responsibilities in the system." },
      { "id": 108, "text": "The requirements discipline is the process of discovering what needs to be built", "correct": true, "explanation": "Correct. The requirements discipline in UP aims to discover, document, and validate what the system must do." },
      { "id": 109, "text": "The requirements discipline must guide development towards the correct system", "correct": true, "explanation": "Correct. The requirements discipline ensures that the RIGHT system is developed (the one that truly meets user needs)." },
      { "id": 110, "text": "Contracts use pre-conditions and post-conditions to detail the changes to objects in a design model (software)", "correct": false, "explanation": "Contracts describe changes to objects in the DOMAIN MODEL (conceptual), not the design model (software)." },
      { "id": 111, "text": "System operations can be identified while sketching DCDs", "correct": false, "explanation": "System operations are identified earlier, while sketching SSDs, not DCDs. DCDs show how these operations are realized internally." },
      { "id": 112, "text": "In the Requirements Analysis phase, the first activity is to translate the collected information into a document that defines a set of requirements.", "correct": false, "explanation": "The first main phase of Requirements Analysis is Requirements Elicitation and Analysis; Requirements Specification, which consists of translating information into a document, comes later." },
      { "id": 113, "text": "In agile methodologies, software design and implementation are usually separate and produce detailed formal documents before coding.", "correct": false, "explanation": "In agile methodologies, design and implementation are intertwined and do not produce formal documents; the design is often recorded informally." },
      { "id": 114, "text": "The Unified Process (UP) is a software development methodology that follows a strictly sequential and waterfall approach.", "correct": false, "explanation": "UP encourages iterative and risk-driven development. Programming and testing begin before the analysis of all requirements is complete." },
      { "id": 115, "text": "The main purpose of the Inception phase in UP is to define all the detailed requirements of the project and generate a reliable cost estimate.", "correct": false, "explanation": "The purpose of the inception phase is not to define all requirements, nor to generate a reliable estimate or project plan. It is rather to decide if the project is worth a more serious investigation." },
      { "id": 116, "text": "The Vision document in UP summarizes the high-level requirements and is useful for establishing a common project vision among participants.", "correct": true, "explanation": "The Vision document summarizes some information contained in the use case model and supplementary specifications, briefly describing the project as context for participants and establishing a common vision." },
      { "id": 117, "text": "In UP, the Glossary also functions as a data dictionary, including information related to other data (metadata), such as validation rules.", "correct": true, "explanation": "In UP, the Glossary also plays the role of a data dictionary, a document containing data about other data, i.e., metadata, including examples of validation rules." },
      { "id": 118, "text": "The Requirements Discipline in UP focuses mainly on 'how' the system should be built, defining the technical and architectural solutions.", "correct": false, "explanation": "The Requirements Discipline is the process of discovering 'what' needs to be built and guiding development towards the correct system, defining the capabilities and conditions the system must conform to." },
      { "id": 119, "text": "According to the sources, use cases in UP are primarily represented by UML diagrams to visualize the interactions between actors and the system.", "correct": false, "explanation": "Use cases in UP are textual descriptions of interesting usage scenarios of the software system. The sources clearly state that use cases are textual documents, not diagrams." },
      { "id": 120, "text": "A Primary Actor in a use case is one who offers a service to the system.", "correct": false, "explanation": "The Primary Actor is the one who achieves user goals by using the system's services. The supporting actor is the one who offers a service to the system." },
      { "id": 121, "text": "In the detailed format of a use case, the 'Extensions' section is used to describe alternative scenarios, both success and failure, compared to the main scenario.", "correct": true, "explanation": "Extensions describe alternative scenarios, of success or failure, and how they are handled." },
      { "id": 122, "text": "When writing a use case in an essential style, it is crucial to include precise details about the user interface (GUI) with which the actor interacts.", "correct": false, "explanation": "The essential style implies ignoring the user interface and focusing on the user's goal and the system's responsibilities at an abstract level, independent of technological and UI details." },
      { "id": 123, "text": "The Black-box approach in writing use cases means describing exactly 'how' the system performs a certain action, including implementation details like database usage or SQL statements.", "correct": false, "explanation": "The Black-box approach means describing 'what' the system must do (behavior or functional requirements) without deciding how." },
      { "id": 124, "text": "To verify the usefulness of a use case, the Boss Test asks if the described activity represents a significant action for the user that justifies the implementation effort.", "correct": true, "explanation": "The Boss Test involves asking if a boss would be happy if a day's work was just the activity described in the use case; if the answer is no, the use case is not useful." },
      { "id": 125, "text": "The Domain Model represents the key concepts of the system as software objects with names and information similar to the real-world domain.", "correct": false, "explanation": "The Domain Model is an analysis tool that represents real-world concepts (conceptual classes) independently of the software implementation, while software objects with similar names to the domain are created in a later phase (design and implementation) and represented, for example, in the Design Model (via DCDs), inspired by the Domain Model." },
      { "id": 126, "text": "System Sequence Diagrams (SSDs) show the interactions between the internal objects of the system to realize an operation.", "correct": false, "explanation": "A System Sequence Diagram is used to represent the input and output events involving the system during an interaction with external actors, viewing the system as a black box." },
      { "id": 127, "text": "System operation contracts describe in detail 'how' the changes in the system's state are achieved after an operation is executed.", "correct": false, "explanation": "A contract describes in great detail the changes required by the execution of a system operation without, however, describing how they are to be obtained." },
      { "id": 128, "text": "A Query system operation modifies the state of the system and for this reason must have post-conditions in its contract.", "correct": false, "explanation": "A Query system operation does not modify the state of the system, it only calculates and returns a value, and for this reason, it has no post-conditions. Post-conditions describe changes in the state of objects." },
      { "id": 129, "text": "Object-oriented design (OOD) emphasizes the definition of software objects and how they collaborate to meet requirements.", "correct": true, "explanation": "Object-oriented design emphasizes the definition of software objects and how they collaborate to meet requirements." },
      { "id": 130, "text": "GRASP patterns are a repository of specific design solutions for recurring problems in software implementation, similar to GoF patterns.", "correct": false, "explanation": "GRASP patterns are principles for assigning responsibilities. GoF patterns are named descriptions of recurring design problems and a solution." },
      { "id": 131, "text": "According to the GRASP Information Expert pattern, a responsibility should be assigned to the class that has the necessary information to fulfill it.", "correct": true, "explanation": "The Information Expert pattern suggests assigning a responsibility to the class that has the necessary information to fulfill it, to the information expert." },
      { "id": 132, "text": "Unit tests are a type of test designed to verify the complete software system, considering the interactions between all major components.", "correct": false, "explanation": "Unit tests test single units of code. Integration tests test communication between specific parts, while end-to-end tests test the entire system." },
      { "id": 133, "text": "In the eXtreme Programming methodology, tests are written before writing the corresponding code (test-driven development).", "correct": true, "explanation": "In some agile methodologies like eXtreme Programming, tests are written before writing the code." },
      { "id": 134, "text": "In the waterfall model, it is assumed that requirements are predictable and stable from the beginning with a low rate of change.", "correct": true, "explanation": "The waterfall model assumes that specifications are predictable and stable and can be correctly defined from the beginning, in the face of a low rate of change." },
      { "id": 135, "text": "According to sources, iterative development methods are statistically associated with lower success rates than the waterfall model.", "correct": false, "explanation": "Based on statistical data, iterative methods are associated with higher success and productivity rates, as well as lower defect levels. In contrast, the waterfall approach is characterized by lower productivity and higher defect rates." },
      { "id": 136, "text": "One of the main reasons requirements change is the inability of customers to fully predict how a system will affect operational practices before it is delivered and used.", "correct": true, "explanation": "Requirements change because it is impossible for customers to predict how a system will affect operational practices, how it will interact with other systems, and which user operations will need to be automated; the real requirements become clear only after the system has been delivered and used." },
      { "id": 137, "text": "In Unified Process (UP), the Requirements Discipline is a set of activities that take place exclusively at the beginning of the project, before any other discipline.", "correct": false, "explanation": "In UP, disciplines (types of activities) are not sequential and are performed in the project in every iteration. The Requirements Discipline is the process of discovering 'what' needs to be built and guiding development towards the correct system." },
      { "id": 138, "text": "According to UP, it is necessary to define 100% of the detailed requirements before starting any programming or testing activities.", "correct": false, "explanation": "In UP, programming and testing begin when only 10% or 20% of the most significant requirements have been specified. Furthermore, one does not try to define all requirements before starting design or implementation." },
      { "id": 139, "text": "The Supplementary Specifications document in UP is intended to contain all functional requirements of the system, including those described in use cases.", "correct": false, "explanation": "The Supplementary Specifications contain what does not fit into use cases, such as non-functional requirements or functional requirements not expressible through use cases. The main functional requirements are described in the Use-Case Model." },
      { "id": 140, "text": "During the Inception phase in UP, the goal is to analyze most of the use cases in detail to gain a complete understanding of the functional requirements.", "correct": false, "explanation": "During inception, about 10% of the use cases are analyzed in detail. The purpose of Inception is not to gather all requirements, but to understand if the project deserves a more serious investigation (feasibility)." },
      { "id": 141, "text": "In the context of UP, Agile Modeling suggests that the value of modeling lies primarily in creating reliable and complete specification documents.", "correct": false, "explanation": "Agile Modeling suggests that the value of modeling is to improve understanding, rather than to document reliable specifications." },
      { "id": 142, "text": "A Supporting Actor in a use case is one who uses the system to achieve their user goals.", "correct": false, "explanation": "The Supporting Actor is the one who offers a service to the system. The Primary Actor is the one who achieves user goals by using the system's services." },
      { "id": 143, "text": "When writing a use case in an essential style, the description focuses on the user's concrete actions and the specific details of the user interface.", "correct": false, "explanation": "The essential style implies that the narrative is expressed at the level of intentions and responsibilities, ignoring the user interface and remaining independent of technological details." },
      { "id": 144, "text": "The 'EBP Test' (Elementary Business Process) to verify the usefulness of a use case asks if the activity described by the use case adds measurable business value.", "correct": true, "explanation": "An elementary business process is an activity that adds measurable business value. The EBP Test assesses whether the use case represents a valuable interaction." },
      { "id": 145, "text": "A detailed use case, to pass the Size Test, should ideally be described on a single page.", "correct": false, "explanation": "To pass the Size Test, a detailed use case normally comprises several steps and requires 3 to 10 pages of text. A single action or step rarely constitutes a useful use case." },
      { "id": 146, "text": "The Domain Model aims to describe the key concepts of the problem domain and their relationships, also serving as inspiration for the software classes.", "correct": true, "explanation": "The Domain Model describes the significant concepts of the system as domain objects and relates the concepts. It serves to understand the domain and its vocabulary, define a common language, and is a source of inspiration for OOD, reducing the 'representation gap'." },
      { "id": 147, "text": "In a UML class diagram representing a Domain Model, associations should indicate the direction of navigability between software classes.", "correct": false, "explanation": "Associations in a domain model are by nature bidirectional. The reading direction (optionally indicated) is not a specification of visibility or navigability between software entities." },
      { "id": 148, "text": "System Sequence Diagrams (SSDs) show the order and logic of interactions between the internal objects of the software system.", "correct": false, "explanation": "System Sequence Diagrams are used to represent the input and output events involving the system during an interaction with external actors, viewing the system as a black box. Sequence diagrams (not system diagrams) show interactions between internal objects." },
      { "id": 149, "text": "Post-conditions in a contract describe the actions the system must perform to satisfy the operation, such as database instructions or calls to specific methods.", "correct": false, "explanation": "A contract describes the changes required by the execution of a system operation in terms of Domain Model objects, without describing how they are to be obtained. Post-conditions describe the state of objects after the operation, not the actions to get there." },
      { "id": 150, "text": "A 'Transformation' system operation does not modify the state of the system and therefore does not require post-conditions in its contract.", "correct": false, "explanation": "A Transformation system operation modifies the state of the system and for this reason should have post-conditions that describe these changes. Query operations do not modify the state and do not have post-conditions." },
      { "id": 151, "text": "Object-Oriented Design (OOD) focuses primarily on defining software objects and how they should collaborate to meet requirements.", "correct": true, "explanation": "Object-oriented design emphasizes the definition of software objects and how they collaborate to meet requirements." },
      { "id": 152, "text": "According to the GRASP principle 'Information Expert', the responsibility for saving an object to the database should be assigned to the class that represents that object (e.g., the Sale class should save itself).", "correct": false, "explanation": "In general, Expert does not apply to persistence (saving to DB) because assigning this responsibility to the class itself would cause problems of low cohesion (it also deals with persistence), high coupling (linked to system classes like DB drivers), and logical duplication. This basic architectural principle suggests separating different logics into subsystems." },
      { "id": 153, "text": "The GoF Strategy pattern allows defining a family of algorithms and making them interchangeable, allowing clients to use different algorithms independently.", "correct": true, "explanation": "The Strategy pattern allows the definition of a family of algorithms, encapsulates each one, and makes them interchangeable. It allows algorithms to be modified independently of clients and decouples algorithms from clients." },
      { "id": 154, "text": "The GoF Iterator pattern exposes the internal structure of a collection to allow the caller to access and traverse its elements.", "correct": false, "explanation": "The Iterator pattern suggests implementing an object that allows access and traversal of the collection, providing a standard interface that hides the internal structure." },
      { "id": 155, "text": "In the GoF Visitor pattern, the ConcreteVisitor is the object that is visited by the data structure.", "correct": false, "explanation": "In the Visitor pattern, the ConcreteVisitor is the object that traverses the collection and applies a specific method to each visited object (Element). The objects in the collection (Element) are the ones that are visited." },
      { "id": 156, "text": "The Model-View Separation Principle suggests separating objects that manage application logic (Model/Domain) from those that manage the user interface (View/UI).", "correct": true, "explanation": "The Model-View separation principle states that the Model (domain layer, objects with application logic) and the View (UI layer, user interface objects) must be separated. UI objects delegate application logic requests to non-UI objects (domain objects)." },
      { "id": 157, "text": "Unit tests are intended to verify the overall functioning of the software system from the user's point of view, considering the system as a black box.", "correct": false, "explanation": "Unit tests test single units of code, not the system as a whole. Acceptance tests are those that verify the overall functioning of the black-box system from the user's point of view, with reference to use cases." },
      { "id": 158, "text": "The Verification phase in a unit test consists of preparing the objects and resources necessary for the execution of the test.", "correct": false, "explanation": "The Setup phase creates the object or group of objects to be verified and prepares resources. The Verification phase evaluates whether the results obtained match those expected." },
      { "id": 159, "text": "Object-oriented analysis is driven by responsibilities.", "correct": false, "explanation": "No, it is object-oriented design that is driven by responsibilities." },
      { "id": 160, "text": "Object-oriented analysis considers a software project as a 'community of objects' with collaborating responsibilities.", "correct": false, "explanation": "No, it is object-oriented design that considers a software project as a 'community of objects' with collaborating responsibilities." },
      { "id": 161, "text": "Identifying responsibilities, assigning these responsibilities, and investigating how to fulfill these responsibilities are the steps of 'responsibility-driven development'.", "correct": true, "explanation": "Responsibility-Driven Development is based on exactly these steps: identifying responsibilities, assigning them to objects, and determining how to realize them." },
      { "id": 162, "text": "Controller, High Cohesion, and Abstract Factory are some examples of GRASP patterns.", "correct": false, "explanation": "Controller and High Cohesion are part of the GRASP patterns, while Abstract Factory is a GoF pattern, not GRASP." },
      { "id": 163, "text": "GRASP patterns are the main tool used in the requirements discipline of UP.", "correct": false, "explanation": "GRASP patterns are used in object-oriented design, not as the main tool for requirements gathering in UP." },
      { "id": 164, "text": "UP temporally organizes the development cycle into four iterations and the iterations into different phases.", "correct": false, "explanation": "UP speaks of four phases (inception, elaboration, construction, transition), each of which can contain multiple iterations; not four iterations overall." },
      { "id": 165, "text": "Inception, elaboration, construction, and transition in UP are temporally separate and never overlap.", "correct": true, "explanation": "They are distinct phases and never overlap." },
      { "id": 166, "text": "Specification, development, validation, and evolution in UP are temporally separate activities and never overlap.", "correct": false, "explanation": "In UP, disciplines (specification, development, validation, evolution, etc.) occur concurrently during iterations, not in isolated sequence." },
      { "id": 167, "text": "During development with UP, refactoring mechanisms are not used to cope with changes.", "correct": false, "explanation": "UP encourages continuous refactoring within iterations to manage changes iteratively." },
      { "id": 168, "text": "Business modeling, requirements, design, implementation, testing, and deployment in UP are temporally separate and never overlap.", "correct": false, "explanation": "UP disciplines (business modeling, requirements, design, implementation, testing, deployment, etc.) take place in parallel within each iteration, not in separate phases." },
      { "id": 169, "text": "Test-driven development is a practice promoted by the waterfall method that involves development preceded by tests.", "correct": false, "explanation": "TDD originated in the context of Extreme Programming, not the waterfall model." },
      { "id": 170, "text": "The purpose of unit tests is to verify the overall connection between all elements of the system.", "correct": false, "explanation": "Unit testing checks isolated components; verifying the overall connection is the job of integration or system tests." },
      { "id": 171, "text": "Unit tests consist of setup, execution, verification, and teardown.", "correct": true, "explanation": "A typical unit test cycle includes setup, execution, assertion (verification), and teardown." },
      { "id": 172, "text": "Test-driven development and refactoring are practices particularly promoted by the development known as extreme programming.", "correct": true, "explanation": "TDD and refactoring are two core practices of Extreme Programming." },
      { "id": 173, "text": "The Strategy pattern deals with how an object performs a certain task and encapsulates an algorithm.", "correct": true, "explanation": "Strategy defines a family of interchangeable algorithms, and the choice of behavior is delegated to different classes that encapsulate each algorithm." },
      { "id": 174, "text": "The State pattern deals with how an object performs a certain task and encapsulates an algorithm.", "correct": false, "explanation": "State encapsulates different states of an object and changes behavior based on the state, not on interchangeable algorithms." },
      { "id": 175, "text": "The State pattern allows the definition of a family of interchangeable algorithms.", "correct": false, "explanation": "Defining a family of interchangeable algorithms is characteristic of the Strategy pattern, not the State pattern." },
      { "id": 176, "text": "The State pattern decouples algorithms from the clients that want to use them dynamically.", "correct": false, "explanation": "Decoupling algorithms and clients is the job of the Strategy pattern; State, on the other hand, decouples behavior based on internal state." },
      { "id": 177, "text": "The State pattern and the Strategy pattern are syntactically equivalent but differ in application.", "correct": false, "explanation": "They are syntactically different." },
      { "id": 178, "text": "The essential characteristics of software are Maintainability, Dependability, Efficiency, and Usability.", "correct": true, "explanation": "Yes, these are the ones." },
      { "id": 179, "text": "A software development process describes a disciplined approach to building, releasing, and eventually maintaining software. There are four fundamental process activities: Specification, Development, Validation, and Evolution/Maintenance.", "correct": true, "explanation": "Yes, these are the ones." },
      { "id": 180, "text": "The biggest problem during software development is change (due to the client, technical or contextual adjustments).", "correct": true, "explanation": "They take time, during which it is not guaranteed that things will remain unchanged." },
      { "id": 181, "text": "Unified Process (UP) organizes work and iterations into four NON-sequential phases. The end of each phase corresponds to a milestone: Inception, Elaboration, Construction, and Transition.", "correct": false, "explanation": "Unified Process (UP) organizes work and iterations into four sequential phases. The end of each phase corresponds to a milestone: Inception, Elaboration, Construction, and Transition." },
      { "id": 182, "text": "Elaboration is the final series of iterations in which the requirements are consolidated and the core of the system's architecture is developed.", "correct": false, "explanation": "Elaboration is the INITIAL series of iterations in which the requirements are consolidated and the core of the system's architecture is developed." },
      { "id": 183, "text": "The domain model is part of the requirements phase that consists of a textual representation describing the fundamental concepts of a system, highlighting the main entities of the domain and their relationships.", "correct": false, "explanation": "The domain model is part of business modeling that consists of a visual representation describing the fundamental concepts of a system, highlighting the main entities of the domain and their relationships." },
      { "id": 184, "text": "The System Sequence Diagram (SSD) is a tool of the requirements discipline used to represent the input and output events involving the system during an interaction with external actors.", "correct": true, "explanation": "Correct definition." },
      { "id": 185, "text": "Layered architecture divides a complex system into a set of software elements that, as much as possible, can be developed and modified independently of each other.", "correct": true, "explanation": "Correct definition." },
      { "id": 186, "text": "Static models describe the behavior of the system and the interactions between objects (for example, with sequence diagrams).", "correct": false, "explanation": "Dynamic models describe the behavior of the system and the interactions between objects (for example, with sequence diagrams)." },
      { "id": 187, "text": "Dynamic models represent the structure of the system, defining classes, attributes, and relationships (typically through class diagrams).", "correct": false, "explanation": "Static models represent the structure of the system, defining classes, attributes, and relationships (typically through class diagrams)." },
      { "id": 188, "text": "GRASP (General Responsibility Assignment Software Patterns) are a set of patterns used to effectively assign responsibilities to objects in an Object-Oriented system.", "correct": true, "explanation": "Correct definition." },
      { "id": 189, "text": "GoF patterns promote the use of inheritance over composition, as composition avoids dependency problems.", "correct": false, "explanation": "GoF patterns promote the use of composition over inheritance, as composition avoids dependency problems." },
      { "id": 190, "text": "End-to-end tests verify the functioning of the small parts (units) of the system.", "correct": false, "explanation": "End-to-end tests verify the overall connection between all elements of the system." },
      { "id": 191, "text": "Refactoring is a structured and disciplined method for writing or restructuring existing code by modifying its external behavior.", "correct": false, "explanation": "Refactoring is a structured and disciplined method for writing or restructuring existing code without modifying its external behavior." },
      { "id": 192, "text": "Unit tests verify the functioning of the small parts (units) of the system. A unit test method is logically composed of four parts: Setup, Execution, Verification, and Teardown.", "correct": true, "explanation": "Unit tests verify the functioning of the small parts (units) of the system. A unit test method is logically composed of four parts: Setup, Execution, Verification, and Teardown." },
      { "id": 193, "text": "The logical architecture of a software system is the large-scale macro-organization of software classes into packages, subsystems, and layers.", "correct": true, "explanation": "Correct definition." },
      { "id": 194, "text": "In contracts, pre-conditions define the state of the system necessary for an operation to be executed, while post-conditions describe the effects of the operation on the domain model.", "correct": true, "explanation": "Correct definition." }
    ],
    "network": [
      { "id": 1, "text": "VPNs (virtual private networks) are used to:", "options": ["Partition a private network into multiple virtually separated networks", "Divide a corporate LAN into subnets for different functions", "Transport private traffic through a shared infrastructure creating conditions similar to a private infrastructure", "Connect only physical devices on the same LAN"], "correct": 2, "explanation": "A VPN uses tunneling and encryption to extend a private network across a public network (like the Internet), allowing data to be transported securely as if it were on a private line." },
      { "id": 2, "text": "Layer 3 VPN solutions based on MPLS are characterized by:", "options": ["A good level of automation and integration between the public backbone and private networks", "Particularly high security thanks to cryptographic techniques", "Layer 3 tunneling mechanisms, specifically within IP packets", "A mix of Layer 2 and Layer 3 tunneling mechanisms"], "correct": 0, "explanation": "MPLS L3 VPNs (BGP/MPLS) are designed for scalability and allow the service provider to automate the distribution of routing information between customer sites via the backbone." },
      { "id": 3, "text": "IPsec 'Tunnel Mode' involves encryption of:", "options": ["The IP header, TCP/UDP header, and payload of the internal packet", "Only the TCP/UDP header and payload", "Only the payload of the internal packet", "The entire external packet, including the header"], "correct": 0, "explanation": "In Tunnel Mode, the entire original IP packet (including its header and payload) is encrypted and encapsulated inside a new IP packet with a new header." },
      { "id": 4, "text": "Two hosts A and B belong to the same physical network and have IP addresses 130.192.1.1/25 and 130.192.1.129/24, respectively.", "options": ["A communicates directly with B and vice versa", "A communicates directly with B but not vice versa", "A can communicate with B only via a router", "A cannot communicate with B"], "correct": 2, "explanation": "Host B (/24) sees A's IP as part of its own subnet (1.0-1.255) and tries to talk directly. Host A (/25) sees its subnet as 1.0-1.127; since B is 1.129, A considers it remote and sends traffic to the Gateway (Router)." },
      { "id": 5, "text": "Which of these techniques is NOT a solution for IPv4-IPv6 transition?", "options": ["6to4", "6over4", "Teredo", "6mix4"], "correct": 3, "explanation": "6to4, 6over4, and Teredo are valid tunneling mechanisms defined by IETF. '6mix4' is a fictitious name not corresponding to any standard." },
      { "id": 6, "text": "In the DS-Lite solution for IPv4-IPv6 transition:", "options": ["The entries of the filtering database of an Ethernet switch", "NAT functionality is not available", "NAT functionality is implemented for all users on appropriate ISP devices", "NAT functionality is implemented on both the CPE and ISP devices"], "correct": 2, "explanation": "DS-Lite moves the NAT44 function from the home router (CPE) to the ISP's network (AFTR), using IPv6 to tunnel IPv4 traffic to the carrier." },
      { "id": 7, "text": "The metric (cost) used by a routing algorithm:", "options": ["Expresses the probability of using the shortest path", "Expresses the complexity of the algorithm in computing the path", "Expresses the weight assigned to a link (channel) in path selection", "Expresses the monetary cost of hardware"], "correct": 2, "explanation": "The metric is a value (based on bandwidth, delay, hop count, etc.) assigned to a link to help the algorithm determine the 'best' path to a destination." },
      { "id": 8, "text": "BGP is used on the Internet for:", "options": ["Finding the geographic location of a host based on IP", "Discovering neighboring routers on a local network", "Communicating link states to neighboring routers", "Exchanging routing information between routers belonging to different autonomous systems"], "correct": 3, "explanation": "BGP (Border Gateway Protocol) is the standard Exterior Gateway Protocol (EGP) used to route traffic between different Autonomous Systems (AS) on the Internet." },
      { "id": 9, "text": "The difference between link state and distance vector routing algorithms can be summarized as:", "options": ["Link state sends local info only to neighbors; Distance vector sends global info to all nodes", "Link state sends local info to all nodes; Distance vector sends global info only to neighboring nodes", "Link state sends global info to all nodes; Distance vector sends local info only to neighbors", "There is no significant difference"], "correct": 1, "explanation": "Link State routers flood information about their local links to the entire network (global map). Distance Vector routers send their full routing table (global reachability) only to direct neighbors." },
      { "id": 10, "text": "RIP is characterized by:", "options": ["Suitability for both inter-domain and intra-domain routing", "Ability to operate on large networks due to hierarchical function", "Usage of a link state routing algorithm", "Frequent instability and tendency to create circular forwarding paths (i.e., routing loops)"], "correct": 3, "explanation": "RIP is a Distance Vector protocol that suffers from slow convergence and the 'count-to-infinity' problem, which can lead to routing loops during topology changes." },
      { "id": 11, "text": "Two IP networks 130.192.0.0/24 and 130.192.2.0/24 can be aggregated into:", "options": ["130.192.0.0/23", "They cannot be aggregated", "130.192.0.0/22", "130.192.2.0/23"], "correct": 2, "explanation": "To aggregate 0.0 and 2.0, you need a mask that covers 0, 1, 2, 3. A /23 only covers 0 and 1. A /22 covers 0.0 through 3.255, making it the correct aggregation block." },
      { "id": 12, "text": "The Integrated IS-IS protocol:", "options": ["Is used by Ethernet switches to create a spanning tree", "Is an evolution of BGP for inter-AS routing", "Is a link-state protocol widely used in large networks", "Is an obsolete routing protocol"], "correct": 2, "explanation": "IS-IS is a robust Link State protocol, similar to OSPF, and is widely favored by Service Providers for large backbone networks." },
      { "id": 13, "text": "RSVP (Resource reSerVation Protocol) allows:", "options": ["Monitoring delay and loss for multimedia packets", "Servers to reserve computing resources", "Routers to know application QoS requirements", "Limiting jitter in routers"], "correct": 2, "explanation": "RSVP is a signaling protocol used by applications to request specific Quality of Service (bandwidth, delay) from the network routers along the path." },
      { "id": 14, "text": "In DiffServ, a 'class of service' identifies:", "options": ["A set of packets handled the same way by routers (e.g., all VoIP traffic)", "A working mode of border routers classifying packets", "A set of packets belonging to the same VoIP session", "A priority level assigned by the application layer only"], "correct": 0, "explanation": "DiffServ aggregates traffic into classes. All packets in the same class (marked with the same DSCP) receive the same forwarding treatment (Per-Hop Behavior)." },
      { "id": 15, "text": "The importance of MPLS in modern networks stems from the possibility to:", "options": ["Have a single control plane for different switching technologies", "Balance traffic across a server farm", "Create devices that work without configuration", "Create switches with specific support for QoS"], "correct": 0, "explanation": "MPLS (Multi-Protocol Label Switching) decouples forwarding from routing, allowing a unified control plane (IP routing) to manage various data link technologies (Ethernet, ATM, Frame Relay)." },
      { "id": 16, "text": "One of the protocols used in MPLS for label distribution is:", "options": ["OSPF", "BGP", "L2TP", "IS-IS"], "correct": 1, "explanation": "While LDP is the basic protocol, MP-BGP (Multiprotocol BGP) is extensively used to distribute labels for MPLS VPN services." },
      { "id": 17, "text": "In MPLS architecture, LSPs (Label Switched Paths):", "options": ["Consist of the shortest path to a destination", "Represent alternative paths kept in a router's table", "Are set up by nodes agreeing on labels for a specific FEC", "Are exchanged by routers to map the network"], "correct": 2, "explanation": "An LSP is the sequence of labels established across the network to forward packets belonging to a specific Forwarding Equivalence Class (FEC)." },
      { "id": 18, "text": "Operations an MPLS router can perform on labels are:", "options": ["Labels cannot be modified", "Push (add outer), Pop (remove outer), Swap (change outer)", "Push only if no others exist, Pop only on exit, Swap", "Push/Pop/Swap on any position in the stack"], "correct": 1, "explanation": "MPLS operations always affect the top of the label stack. Push adds a label, Pop removes the top label, and Swap replaces the top label." },
      { "id": 19, "text": "The IGMP protocol:", "options": ["Is a new version of ICMP", "Allows an IPv4 router to discover multicast groups on a connected network", "Allows an IPv4 router to discover active multicast groups on the Internet", "Allows an IPv4 host to create a new multicast group"], "correct": 1, "explanation": "IGMP (Internet Group Management Protocol) is used between hosts and local routers so the router knows which multicast groups the hosts want to join." },
      { "id": 20, "text": "In an IPv4 network, a host is reached by a multicast packet:", "options": ["Only if it joined that group (regardless of L2 technology)", "Even if it did not join that group (depending on L2 config)", "Always, and delivers it to the application layer", "Never, IPv4 does not support multicast"], "correct": 1, "explanation": "Without mechanisms like IGMP Snooping on switches, multicast traffic is often flooded like broadcast at Layer 2, reaching hosts that did not request it." },
      { "id": 21, "text": "IPv6 Neighbor Discovery procedure:", "options": ["Is based on a multicast ICMPv6 packet", "Is based on ARPv6", "Requires network IPv4 support", "Is based on a broadcast ICMPv6 packet"], "correct": 0, "explanation": "IPv6 replaced broadcast ARP with Neighbor Discovery using ICMPv6 messages sent to the specific Solicited-Node Multicast address." },
      { "id": 22, "text": "The ICMPv6 Router Advertisement packet:", "options": ["Enables stateless autoconfiguration", "Is sent periodically to all routers", "Is a broadcast packet", "Is sent as a reply to Neighbor Solicitation"], "correct": 0, "explanation": "Router Advertisements (RA) provide the network prefix to hosts, allowing them to generate their own IP address via SLAAC (Stateless Address Autoconfiguration)." },
      { "id": 23, "text": "IPv6 Private addresses (Unique Local):", "options": ["Used only on routers", "Globally unique with high probability, but not globally routable", "Used to interconnect private networks via public network", "Used only for on-link communications"], "correct": 1, "explanation": "Unique Local Addresses (fc00::/7) are the IPv6 equivalent of private IPs. They use a random ID to ensure high probability of uniqueness if networks merge, but aren't routed on the Internet." },
      { "id": 24, "text": "IPv6 Site Local addresses:", "options": ["Automatically setup for on-link", "Deprecated but can be used", "Assigned by central authority", "Do not exist"], "correct": 1, "explanation": "Site-Local addresses (fec0::/10) were an early IPv6 feature but were formally deprecated (RFC 3879) in favor of Unique Local Addresses." },
      { "id": 25, "text": "The IPv6 address FE80::0201:06FF:FEA5:3A4C is:", "options": ["Currently not available", "Usable by a host to communicate with another on the same link", "Usable by a server to offer public service", "Usable by multiple devices on the same link"], "correct": 1, "explanation": "The prefix FE80::/10 identifies a Link-Local address, which is valid and unique only on the specific physical link (network segment) it is connected to." },
      { "id": 26, "text": "Centralized routing:", "options": ["Mandates traffic traverses a specific node", "Is obsolete", "Mandates nodes do not exchange routing info", "Consists of one node computing routes for others and providing them"], "correct": 3, "explanation": "In centralized routing (like in SDN), a central controller has a global view and calculates paths for all forwarding devices, pushing the table entries to them." },
      { "id": 27, "text": "Using privacy-aware autoconfiguration (RFC-4941), an IPv6 host address has:", "options": ["Both prefix and interface ID untraceable", "Untraceable prefix", "Only valid within a VPN", "Untraceable interface ID"], "correct": 3, "explanation": "Privacy extensions generate a random, temporary Interface ID that changes over time to prevent tracking the device based on its static MAC address." },
      { "id": 28, "text": "One of the main properties of 5G infrastructure is:", "options": ["Return to circuit switching", "Joint use of virtualization and flexible network control (Network Slicing)", "Virtualization on mobile terminals", "Use of software emulators for design"], "correct": 1, "explanation": "5G relies heavily on NFV (Network Function Virtualization) and SDN to create 'Network Slices', allowing different logical networks to run on shared physical hardware." },
      { "id": 29, "text": "The MAC address of an ICMPv6 Neighbor Solicitation packet is:", "options": ["Broadcast address", "Anycast address", "Multicast address", "Unicast address of the target"], "correct": 2, "explanation": "Neighbor Solicitation is sent to the Solicited-Node Multicast address, which maps to a specific Layer 2 Multicast MAC address (33:33:xx:xx:xx:xx)." },
      { "id": 30, "text": "Indicate the FALSE claim about SSL-based VPNs:", "options": ["There is no authentication of the IP header", "They are weak against DoS attacks", "Standard solutions are available", "Tunnels over TCP or UDP are used"], "correct": 2, "explanation": "Unlike IPsec, which is a strict IETF standard, SSL VPNs are often proprietary implementations (Clientless or AnyConnect-style) and lack a single interoperable standard." },
      { "id": 31, "text": "Handover in cellular networks refers to:", "options": ["Moving between cells without interruption of active communication", "Roaming to a different operator", "Moving between cells while idle", "Turning on the terminal"], "correct": 0, "explanation": "Handover (or handoff) is the process of transferring an active call or data session from one base station to another as the user moves." },
      { "id": 32, "text": "In an FDMA cellular network:", "options": ["Only one frequency is used", "Voice calls are not possible", "Frequencies are randomly selected", "Available frequencies are divided among neighboring cells and reused in distant ones"], "correct": 3, "explanation": "FDMA divides the spectrum into frequency channels. To avoid interference, adjacent cells use different frequencies, but frequencies can be reused in non-adjacent cells (Frequency Reuse)." },
      { "id": 33, "text": "In MPLS, label binding consists of:", "options": ["Including a label in BGP", "Associating a label to a routing path", "Associating a label to a Forwarding Equivalence Class (FEC)", "Sending a label to another node"], "correct": 2, "explanation": "Label binding is the local decision by an LSR to assign a specific label value to represent a specific destination (FEC)." },
      { "id": 34, "text": "Traffic encryption in VPNs is:", "options": ["Not utilized", "The basis of every solution", "Important but not strictly necessary/available in all solutions", "Important but not strictly necessary, not supported in some"], "correct": 2, "explanation": "While essential for security, encryption is technically optional in definitions like MPLS VPNs (which separate traffic logically but don't encrypt it by default)." },
      { "id": 35, "text": "Smallest aggregation for 130.192.0.0/25 and 130.192.1.0/25 is:", "options": ["130.192.0.0/24", "130.192.1.0/24", "130.192.1.0/23", "130.192.0.0/23"], "correct": 3, "explanation": "0.0/25 is in the 0.0/24 block. 1.0/25 is in the 1.0/24 block. The smallest block containing both 0.x and 1.x is the supernet /23 (which covers 0.0 to 1.255)." },
      { "id": 36, "text": "Count to Infinity:", "options": ["Link State algorithm to prevent loops", "Transient period in Distance Vector algorithm", "Stable state", "Helps understand if a node is unreachable"], "correct": 1, "explanation": "Count-to-infinity is a routing loop problem in Distance Vector protocols where nodes keep incrementing the metric to an unreachable node until it hits a limit." },
      { "id": 37, "text": "The Solicited Node Multicast Address is:", "options": ["Source address in Neighbor Solicitation", "Inserted in payload (Target Address)", "Destination address in Neighbor Solicitation", "Inserted in ICMPv6 payload"], "correct": 2, "explanation": "When resolving an address, the sender sends the Neighbor Solicitation to the target's Solicited-Node Multicast address (destination)." },
      { "id": 38, "text": "Indicate the TRUE claim about VPNs:", "options": ["None of the others", "End-to-end is always better than site-to-site", "Skewed channel is IPsec encryption only", "Firewalls cannot be placed inside a VPN"], "correct": 3, "explanation": "Standard firewall placement design usually prevents placing a firewall *inside* the network protected by a VPN gateway in a way that it inspects the encrypted traffic before decryption." },
      { "id": 39, "text": "In GSM, a 'Regular Burst' is used:", "options": ["Only for call control", "For sending voice samples or control info", "During connection phase", "Only for voice samples"], "correct": 1, "explanation": "Regular bursts carry the Traffic Channels (TCH) which contain the actual user data (voice) and Fast Associated Control Channel (FACCH) data." },
      { "id": 40, "text": "Multicast groups in IPv4:", "options": ["Identified by list of IP addresses", "Identified by special IP addresses not assigned to single hosts", "Identified by list of MAC addresses", "Do not exist"], "correct": 1, "explanation": "Class D IP addresses (224.0.0.0 to 239.255.255.255) identify multicast groups, not specific interfaces." },
      { "id": 41, "text": "Label distribution in MPLS:", "options": ["Performed implicitly via OSPF", "Not needed with BGP", "Can be performed with RSVP", "Involves hosts"], "correct": 2, "explanation": "RSVP-TE (Resource Reservation Protocol with Traffic Engineering extensions) is one of the standard protocols used to distribute labels and reserve resources for LSPs." },
      { "id": 42, "text": "OSPF-TE and ISIS-TE extensions are for:", "options": ["Distribution of constraint-based data", "Faster convergence", "Independence of control/data plane", "Explicit routing fields"], "correct": 0, "explanation": "These extensions carry additional data (like available bandwidth on a link) to allow the calculation of Constraint-based paths for Traffic Engineering." },
      { "id": 43, "text": "IPv6 address 2001:4600::0201:06FF:FEA5:3A4C is:", "options": ["Usable on a server for public IPv6 Internet service", "Usable only on-link", "Private address", "Invalid address"], "correct": 0, "explanation": "2000::/3 is the range for Global Unicast Addresses, meaning this is a publicly routable address suitable for a server." },
      { "id": 44, "text": "Distance Vector algorithm:", "options": ["Shorter convergence than Link State", "Deployed in specific scenarios", "Better stability than Link State", "Outdated and unused"], "correct": 1, "explanation": "While older, Distance Vector (like RIP or EIGRP) is still deployed in specific scenarios (small networks, or EIGRP in Cisco shops) despite slower convergence than Link State." },
      { "id": 45, "text": "The basic idea of MPLS consists of:", "options": ["Inserting label in IP packets for path determination", "Inserting label in L2 frames", "Associating a label so destination identifies flow", "Associating a label so network nodes determine how to process the packet"], "correct": 3, "explanation": "MPLS attaches a label to packets. Network nodes (LSRs) make forwarding decisions based solely on the content of this label, rather than the complex IP header." },
      { "id": 46, "text": "An optical switch is capable of switching:", "options": ["Different optical channels on a fiber", "Packets arriving on optical channel", "An optical channel on a wavelength from input to different wavelength on output", "An optical channel on a wavelength from input to output fiber"], "correct": 3, "explanation": "An optical switch (OXC/ROADM) physically switches light of a specific wavelength from an input port to an output port without converting it to electricity." },
      { "id": 47, "text": "GRE (Generic Routing Encapsulation) is used for:", "options": ["Identifying protocol encapsulated in IP", "Identifying protocol in Ethernet", "Exchanging routing info", "Encrypted tunneling"], "correct": 0, "explanation": "GRE adds a header that indicates the 'EtherType' of the payload protocol, allowing non-IP protocols (or IP itself) to be encapsulated over an IP network." },
      { "id": 48, "text": "Redistribution in routing consists of:", "options": ["Redistributing traffic", "Learning routes without exchange", "Distributing routing table", "Distributing routes acquired via one protocol via another protocol"], "correct": 3, "explanation": "Redistribution is the process of taking routes learned by one protocol (e.g., OSPF) and injecting them into another protocol (e.g., BGP)." },
      { "id": 49, "text": "In topology-based control-driven label binding:", "options": ["Traffic of different apps uses different LSPs", "LSP is setup as result of discovering a route (one LSP per destination)", "Forwarding tables manual", "Must use BGP"], "correct": 1, "explanation": "In this mode (like LDP), labels are assigned and distributed automatically as soon as the routing protocol learns a route to a destination prefix." },
      { "id": 50, "text": "DWDM allows:", "options": ["Packaging fibers", "Multiplexing/demultiplexing optical signals (wavelengths) on same fiber", "Multiplexing bit flows", "Switching optical signal"], "correct": 1, "explanation": "Dense Wavelength Division Multiplexing puts multiple data streams on a single fiber by assigning each stream a different color (wavelength) of light." }
    ]
  }
}