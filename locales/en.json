{
  "global": {
    "back_to_home": "‚Üê Back to homepage",
    "show_answer": "Show Answer",
    "next": "Next ‚Üí",
    "stop_quiz": "Stop Quiz",
    "restart_quiz": "üîÑ Restart Quiz",
    "previous": "‚Üê Previous",
    "correct": "Correct",
    "incorrect": "Incorrect",
    "question_progress": "Question {current} of {total}",
    "go_to": "Go to:",
    "quiz_finished": "Quiz Finished!",
    "score_summary": "Here is the summary of your session.",
    "total_score": "Total Score",
    "correct_total": "Correct (out of Total)",
    "incorrect_total": "Incorrect (out of Total)",
    "correct_answered": "Correct / Answered",
    "incorrect_answered": "Incorrect / Answered",
    "finish_quiz_button": "üèÅ Finish Quiz",
    "select_answer_alert": "Please select an answer first.",
    "true_option": "‚úì True",
    "false_option": "‚úó False",
    "explanation": "Explanation:"
  },
  "home": {
    "main_title": "üéì SAS QUIZ",
    "subtitle": "Choose the type of quiz you want to take",
    "theory_title": "Theory Quiz",
    "theory_desc": "Test your knowledge on the fundamental concepts of software application development.",
    "theory_prompt": "Choose the number of questions:",
    "theory_20": "20 Questions",
    "theory_50": "50 Questions",
    "theory_100": "100 Questions",
    "theory_all": "All Questions",
    "pattern_title": "Design Patterns Quiz",
    "pattern_desc": "Deepen your understanding of design patterns, from GRASP to GoF, and how to apply them."
  },
  "pattern_page": {
    "title": "üèóÔ∏è Design Patterns Quiz"
  },
  "theory_page": {
    "title": "üìö Theory Quiz",
    "question_title": "Question {number}"
  },
  "questions": {
    "pattern": [
      { "pattern": "Creator", "category": "GRASP", "type": "Problem-Solution", "question": "What problem does the Creator pattern solve?", "options": ["Who should be responsible for creating instances of a class?", "How to maintain low coupling between classes?", "How to assign responsibilities to objects?", "How to manage communication between objects?"], "correct": 0, "explanation": "The Creator pattern addresses the problem of determining which class should be responsible for creating instances of other classes." },
      { "pattern": "Information Expert", "category": "GRASP", "type": "Problem-Solution", "question": "What solution does the Information Expert pattern propose?", "options": ["Centralize all information in one class", "Assign responsibility to the class that has the necessary information", "Create a dedicated class for each type of information", "Use global variables to share information"], "correct": 1, "explanation": "Information Expert suggests assigning responsibility to the class that has the information necessary to fulfill it." },
      { "pattern": "Low Coupling", "category": "GRASP", "type": "Problem-Solution", "question": "What problem does the Low Coupling pattern address?", "options": ["How to increase dependency between classes?", "How to reduce the impact of changes and increase reuse?", "How to centralize responsibilities?", "How to increase system performance?"], "correct": 1, "explanation": "Low Coupling aims to reduce dependencies between classes to minimize the impact of changes and promote reuse." },
      { "pattern": "High Cohesion", "category": "GRASP", "type": "Problem-Solution", "question": "What does the High Cohesion pattern promote?", "options": ["Classes with very different responsibilities", "Classes with closely related and focused responsibilities", "Classes with many external dependencies", "Classes with very long and complex methods"], "correct": 1, "explanation": "High Cohesion promotes classes with closely related and well-focused responsibilities, making the code more understandable and maintainable." },
      { "pattern": "Controller", "category": "GRASP", "type": "Problem-Solution", "question": "What problem does the Controller pattern solve?", "options": ["How to manage the user interface?", "Who should handle system input events?", "How to implement data persistence?", "How to optimize database performance?"], "correct": 1, "explanation": "The Controller pattern determines which object should receive and coordinate (control) system input events." },
      { "pattern": "Singleton", "category": "GoF Creational", "type": "Problem-Solution", "question": "What problem does the Singleton pattern solve?", "options": ["How to create families of related objects?", "How to ensure a class has only one instance?", "How to separate the construction of complex objects?", "How to clone prototype objects?"], "correct": 1, "explanation": "Singleton ensures that a class has only one instance and provides a global point of access to it." },
      { "pattern": "Abstract Factory", "category": "GoF Creational", "type": "Problem-Solution", "question": "What solution does the Abstract Factory pattern provide?", "options": ["Creates a single global instance", "Provides an interface for creating families of related objects", "Separates the algorithm from the data structure", "Allows adding new operations without modifying classes"], "correct": 1, "explanation": "Abstract Factory provides an interface for creating families of related or dependent objects without specifying their concrete classes." },
      { "pattern": "Adapter", "category": "GoF Structural", "type": "Problem-Solution", "question": "What problem does the Adapter pattern solve?", "options": ["How to compose objects into tree structures?", "How to allow classes with incompatible interfaces to work together?", "How to add responsibilities to objects dynamically?", "How to efficiently share similar objects?"], "correct": 1, "explanation": "Adapter allows classes with incompatible interfaces to work together by acting as a bridge between them." },
      { "pattern": "Composite", "category": "GoF Structural", "type": "Problem-Solution", "question": "What structure does the Composite pattern create?", "options": ["A chain of linked objects", "A tree structure of objects", "A stack of objects", "A map of key-value objects"], "correct": 1, "explanation": "Composite allows composing objects into tree structures to represent part-whole hierarchies." },
      { "pattern": "Decorator", "category": "GoF Structural", "type": "Problem-Solution", "question": "How does the Decorator pattern work?", "options": ["It directly modifies the original class", "It wraps the original object in one or more wrappers", "It completely replaces the original object", "It creates a modified copy of the object"], "correct": 1, "explanation": "Decorator allows adding new functionalities to objects by wrapping them in wrappers that contain the new behaviors." },
      { "pattern": "Observer", "category": "GoF Behavioral", "type": "Problem-Solution", "question": "What problem does the Observer pattern solve?", "options": ["How to iterate through a collection?", "How to automatically notify multiple objects when state changes?", "How to encapsulate interchangeable algorithms?", "How to handle requests in a chain of handlers?"], "correct": 1, "explanation": "Observer defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically." },
      { "pattern": "State", "category": "GoF Behavioral", "type": "Problem-Solution", "question": "What solution does the State pattern propose?", "options": ["Use a large switch/if to manage states", "Encapsulate each state in a separate class", "Store all states in an array", "Completely ignore the concept of state"], "correct": 1, "explanation": "State allows an object to alter its behavior when its internal state changes, encapsulating each state in a separate class." },
      { "pattern": "Strategy", "category": "GoF Behavioral", "type": "Problem-Solution", "question": "What problem does the Strategy pattern address?", "options": ["How to manage notifications between objects?", "How to make algorithms interchangeable at runtime?", "How to visit elements of a complex structure?", "How to manage complex states of an object?"], "correct": 1, "explanation": "Strategy defines a family of algorithms, encapsulates each one, and makes them interchangeable during execution." },
      { "pattern": "Visitor", "category": "GoF Behavioral", "type": "Problem-Solution", "question": "What advantage does the Visitor pattern offer?", "options": ["Simplifies the structure of the visited objects", "Allows adding new operations without modifying the existing classes", "Reduces the number of classes in the system", "Improves data access performance"], "correct": 1, "explanation": "Visitor allows defining new operations without changing the classes of the elements on which it operates, separating algorithms from the structure." },
      { "pattern": "Creator", "category": "GRASP", "type": "UML", "question": "In the Creator pattern's UML diagram, what relationship is typically shown?", "options": ["Inheritance between creator and product", "Composition or aggregation between creator and product", "Bidirectional association", "Circular dependency"], "correct": 1, "explanation": "The Creator typically has a composition or aggregation relationship with the objects it creates, shown with a filled or empty diamond." },
      { "pattern": "Singleton", "category": "GoF Creational", "type": "UML", "question": "How is the constructor represented in the Singleton's UML diagram?", "options": ["Public (+)", "Private (-)", "Protected (#)", "Static (underlined)"], "correct": 1, "explanation": "In Singleton, the constructor is private (-) to prevent direct instantiation from outside the class." },
      { "pattern": "Observer", "category": "GoF Behavioral", "type": "UML", "question": "In the Observer pattern, what interface do observers typically implement?", "options": ["Subject", "Observer or Listener", "ConcreteSubject", "Publisher"], "correct": 1, "explanation": "Observers implement an Observer (or Listener) interface that defines the update() method for receiving notifications." },
      { "pattern": "Strategy", "category": "GoF Behavioral", "type": "UML", "question": "In the Strategy pattern's UML diagram, what kind of relationship does the Context have with the Strategy?", "options": ["Inheritance", "Composition", "Realization", "Simple dependency"], "correct": 3, "explanation": "The Context uses the Strategy interface to delegate the algorithm's execution, establishing a simple dependency. This allows the Context to flexibly vary the concrete algorithm." },
      { "pattern": "Composite", "category": "GoF Structural", "type": "UML", "question": "In the Composite pattern, how is the relationship between Composite and Component shown?", "options": ["Simple aggregation", "Recursive composition (Composite contains Component)", "Multiple inheritance", "Bidirectional association"], "correct": 1, "explanation": "Composite inherits from Component and also contains a collection of Components, creating a recursive structure." },
      { "pattern": "Decorator", "category": "GoF Structural", "type": "UML", "question": "In the Decorator pattern, what is a characteristic of the Decorator class?", "options": ["It is final and cannot be extended", "It implements the same interface as the decorated component", "It is static and contains only utility methods", "It is abstract and cannot be instantiated"], "correct": 1, "explanation": "Decorator implements the same interface as the component it decorates, allowing it to be substituted transparently." }
    ],
    "theory": [
      { "id": 1, "text": "In UP, the requirements discipline aims to produce a list of requirements, understand the system context, and capture functional and non-functional requirements", "correct": true, "explanation": "The requirements discipline in UP indeed has as its main objectives: to produce a list of requirements, understand the system context, and capture both functional and non-functional requirements." },
      { "id": 2, "text": "The domain model includes the definition of objects, associations, and attributes of software classes", "correct": false, "explanation": "The domain model represents CONCEPTUAL classes of the problem domain, not software classes. It includes conceptual objects, associations, and attributes from the real world." },
      { "id": 3, "text": "The domain model is a visual dictionary of conceptual classes", "correct": true, "explanation": "Correct. The domain model is a visual representation (visual dictionary) of the relevant conceptual classes in the problem domain." },
      { "id": 4, "text": "The domain model is a textual representation of conceptual classes, real objects of the domain", "correct": false, "explanation": "The domain model is a VISUAL (not textual) representation of conceptual classes. It uses UML diagrams to graphically represent the concepts." },
      { "id": 5, "text": "The domain model is not part of the requirements discipline", "correct": true, "explanation": "The domain model is part of the Business Modeling discipline in UP. It helps to understand and document the concepts of the problem domain." },
      { "id": 6, "text": "In domain model associations, the reading direction must always be specified", "correct": false, "explanation": "The reading direction in domain model associations does NOT always need to be specified. It is optional and used only when necessary to clarify the meaning of the association." },
      { "id": 7, "text": "The association in the domain model is by its nature unidirectional", "correct": false, "explanation": "Associations in the domain model are by nature BIDIRECTIONAL. They represent conceptual relationships that can be navigated in both directions." },
      { "id": 8, "text": "The association in the domain model represents a meaningful relationship between classes", "correct": true, "explanation": "Correct. Associations in the domain model represent meaningful and relevant relationships between the conceptual classes of the domain." },
      { "id": 9, "text": "The association in the domain model represents a logical value of the objects of a class", "correct": false, "explanation": "Associations represent RELATIONSHIPS between classes, not logical values of objects. Logical values are represented by attributes." },
      { "id": 10, "text": "The association in the domain model represents a set of n-tuples of objects of the classes", "correct": true, "explanation": "Mathematically, an association can be seen as a set of n-tuples (pairs, triples, etc.) of objects from the classes involved in the relationship." },
      { "id": 11, "text": "THE DOMAIN MODEL: A set of UML class diagrams that include associations between software classes", "correct": false, "explanation": "The domain model includes associations between CONCEPTUAL classes, not software classes. Software classes belong to the design model." },
      { "id": 12, "text": "THE DOMAIN MODEL: A graphical representation of software objects", "correct": false, "explanation": "The domain model represents CONCEPTUAL objects of the problem domain, not software objects which belong to the implementation." },
      { "id": 13, "text": "THE DOMAIN MODEL: A visual representation of conceptual classes", "correct": true, "explanation": "Correct. The domain model is a visual representation of the relevant conceptual classes in the problem domain." },
      { "id": 14, "text": "THE DOMAIN MODEL: A set of UML class diagrams that include associations between conceptual classes", "correct": true, "explanation": "Correct. The domain model uses UML class diagrams to represent conceptual classes and their associations." },
      { "id": 15, "text": "THE DOMAIN MODEL: A visual representation of JAVA classes", "correct": false, "explanation": "The domain model represents CONCEPTUAL classes of the domain, not Java classes which are part of the software implementation." },
      { "id": 16, "text": "THE DOMAIN MODEL: A set of UML class diagrams that include 'doing' responsibilities", "correct": false, "explanation": "The domain model does NOT include 'doing' responsibilities (methods). Responsibilities are assigned during the design phase, not in the domain analysis." },
      { "id": 17, "text": "A use case represents a way a user uses the system to achieve a goal", "correct": true, "explanation": "Correct. A use case describes how an actor (user) interacts with the system to achieve a specific goal." },
      { "id": 18, "text": "The narrative of a use case is expressed at the level of the user's intentions and the system's responsibility", "correct": true, "explanation": "Correct. Use cases are written from the perspective of the user's intentions and the responsibilities the system must undertake to satisfy them." },
      { "id": 19, "text": "The narrative of a use case is expressed at the level of the user's concrete actions and the system's responsibilities", "correct": false, "explanation": "Use cases are written at the level of user INTENTIONS, not concrete actions. Concrete actions belong to a too-low level of detail." },
      { "id": 20, "text": "A use case is always completed (implemented) in a single iteration", "correct": false, "explanation": "A use case can be implemented over multiple iterations. Often, the basic scenarios are implemented first, followed by the alternative ones." },
      { "id": 21, "text": "A use case represents the set of all functionalities of a system", "correct": false, "explanation": "A use case represents A SPECIFIC WAY of using the system to achieve a goal, not the set of all its features." },
      { "id": 22, "text": "Functional requirements not captured by use cases are described in the supplementary specifications", "correct": true, "explanation": "Correct. The supplementary specifications document functional requirements that are not captured by use cases (e.g., reports, file formats, etc.)." },
      { "id": 23, "text": "Linguistic analysis of use cases in detailed format is a source of inspiration for building the domain model", "correct": true, "explanation": "Correct. Analyzing the nouns and concepts in detailed use cases helps to identify conceptual classes for the domain model." },
      { "id": 24, "text": "The domain model reports the significant concepts related to the use cases", "correct": true, "explanation": "Correct. The domain model includes the domain concepts that are relevant to the system's use cases." },
      { "id": 25, "text": "Non-functional requirements are fully described by use cases", "correct": false, "explanation": "Use cases primarily capture FUNCTIONAL requirements. Non-functional requirements (performance, security, usability) are documented in the supplementary specifications." },
      { "id": 26, "text": "Contracts are considered part of the use case model because they provide more analysis details on the effect of system operations implied by the use cases", "correct": true, "explanation": "Correct. System operation contracts provide additional details on the effects of the operations identified in the use cases." },
      { "id": 27, "text": "USE CASES are a collection of success scenarios only that describe an actor using the system to achieve a specific goal", "correct": false, "explanation": "Use cases include both SUCCESS scenarios and ALTERNATIVE scenarios (including failure scenarios). They are not limited to success scenarios only." },
      { "id": 28, "text": "Use cases are textual descriptions of interesting usage scenarios of the software system to be built", "correct": true, "explanation": "Correct. Use cases are textual descriptions that document significant usage scenarios of the system under development." },
      { "id": 29, "text": "Use cases are used to capture functional requirements", "correct": true, "explanation": "Correct. The main purpose of use cases is to capture and document the system's functional requirements." },
      { "id": 30, "text": "In UP, use cases are used to capture functional requirements in the requirements discipline", "correct": true, "explanation": "Correct. In the Unified Process, use cases are the primary tool for capturing functional requirements during the requirements discipline." },
      { "id": 31, "text": "Use cases are features of the system", "correct": false, "explanation": "Use cases are NOT system features, but describe HOW the system is used by actors to achieve specific goals." },
      { "id": 32, "text": "Use cases are used to plan iterations", "correct": true, "explanation": "Correct. Use cases are used to organize and plan development iterations, with the most critical use cases being implemented in the early iterations." },
      { "id": 33, "text": "In UP, use cases are described using the UML language", "correct": false, "explanation": "In UP, use cases are described primarily in NATURAL language (text), not in UML. UML only provides use case diagrams to show relationships." },
      { "id": 34, "text": "DURING THE ELABORATION PHASE: About 10% of the most critical use cases are written in a detailed format using specific templates", "correct": false, "explanation": "During Inception, about 10% of the most critical and risky use cases are detailed to guide the architecture. The Elaboration phase is when most requirements are clarified and stabilized, leading to a much higher percentage (40-80%) of detailed use cases by the end of this phase." },
      { "id": 35, "text": "As a percentage of the total use cases in a project, should 5% be completed by the end of the inception phase?", "correct": true, "explanation": "Correct. During the inception phase, about 5% of all identified use cases are typically implemented." },
      { "id": 36, "text": "Use cases highlight user goals", "correct": true, "explanation": "Correct. Use cases are organized around the goals that users (actors) want to achieve by using the system." },
      { "id": 37, "text": "Use cases are used for the discovery and definition of non-functional requirements", "correct": false, "explanation": "Use cases are primarily used for FUNCTIONAL requirements. Non-functional requirements are documented in the supplementary specifications." },
      { "id": 38, "text": "Use cases are used for the discovery and definition of functional requirements", "correct": true, "explanation": "Correct. Use cases are the main tool for discovering, defining, and documenting the system's functional requirements." },
      { "id": 39, "text": "Use cases highlight system goals", "correct": false, "explanation": "Use cases highlight USER (actor) goals, not system goals. The system responds to user goals." },
      { "id": 40, "text": "Use cases are used only in the first development iterations", "correct": false, "explanation": "Use cases are used throughout the ENTIRE development process, not just in the early iterations. They guide implementation, testing, and validation." },
      { "id": 41, "text": "The main input for writing contracts are system operations and the domain model", "correct": true, "explanation": "Correct. Contracts are written for the system operations identified in SSDs, using the domain model to describe the effects." },
      { "id": 42, "text": "Post-conditions describe the state changes of objects in the domain model after the operation is completed", "correct": true, "explanation": "Correct. Post-conditions in contracts describe how the states of domain model objects change after the operation's execution." },
      { "id": 43, "text": "Contracts serve as input for the domain model", "correct": false, "explanation": "Contracts do NOT serve as input for the domain model. It's the other way around: the domain model serves as input for writing contracts." },
      { "id": 44, "text": "Responsibilities are assigned to the concepts defined in the domain model", "correct": false, "explanation": "Responsibilities are assigned to SOFTWARE CLASSES during design, not to the concepts in the domain model, which represents only the analysis." },
      { "id": 45, "text": "System operation contracts use pre- and post-conditions to detail the changes to (conceptual) objects in a domain model", "correct": true, "explanation": "Correct. Contracts use pre-conditions and post-conditions to describe in detail how system operations modify conceptual objects." },
      { "id": 46, "text": "Pre-conditions describe the state changes of objects in the domain model after the operation is completed", "correct": false, "explanation": "Pre-conditions describe the state that must exist BEFORE the operation. It is the POST-conditions that describe the changes after the operation." },
      { "id": 47, "text": "Object composition is statically defined through the specification of classes and associations", "correct": true, "explanation": "Correct. Composition is statically defined in the code through the definition of classes and their composition relationships." },
      { "id": 48, "text": "The specialization mechanism for code reuse is called white-box reuse", "correct": true, "explanation": "Correct. Inheritance (specialization) is called 'white-box' reuse because the subclass has visibility into the internal details of the superclass." },
      { "id": 49, "text": "Changing a class's interface generally has a low impact on its subclasses", "correct": false, "explanation": "Changing a class's interface generally has a HIGH impact on its subclasses, which depend on the superclass's interface." },
      { "id": 50, "text": "GRASP patterns are expressed in terms of responsibilities, roles, and collaborations", "correct": true, "explanation": "Correct. GRASP (General Responsibility Assignment Software Patterns) focus on the assignment of responsibilities, roles, and collaborations among objects." },
      { "id": 51, "text": "The decision on assigning responsibilities always precedes coding", "correct": false, "explanation": "Assigning responsibilities is part of the design (OOD) which logically precedes implementation/coding, but decisions on assigning responsibilities to objects can also be made while coding or during modeling." },
      { "id": 52, "text": "The use of GRASP patterns is carried out within the requirements discipline of UP", "correct": false, "explanation": "GRASP patterns are used in the DESIGN discipline, not the requirements discipline. They concern the assignment of responsibilities to software classes." },
      { "id": 53, "text": "Responsibilities are assigned to classes during OOD", "correct": true, "explanation": "Correct. Object-Oriented Design (OOD) is the phase where responsibilities are assigned to software classes using principles like the GRASP patterns." },
      { "id": 54, "text": "The delegation mechanism is preferable to the specialization mechanism for code reuse", "correct": true, "explanation": "Correct. Composition/delegation (black-box reuse) is generally preferable to inheritance because it is more flexible and maintains lower coupling." },
      { "id": 55, "text": "Inheritance respects encapsulation", "correct": false, "explanation": "Inheritance does NOT fully respect encapsulation because the subclass has access to the protected members of the superclass, breaking the encapsulation." },
      { "id": 56, "text": "Object composition is a code reuse mechanism called black-box reuse", "correct": true, "explanation": "Correct. Composition is called 'black-box' reuse because the component objects are used only through their public interfaces." },
      { "id": 57, "text": "A method of a software class represents a 'doing' responsibility for instances of that class", "correct": true, "explanation": "Correct. Methods represent the 'doing' responsibilities of a class, i.e., what objects of that class can do." },
      { "id": 58, "text": "DURING THE ELABORATION PHASE: No tests are performed on the development code", "correct": false, "explanation": "During the elaboration phase, tests ARE performed on the code. It's a phase where the architectural core is programmed and tested." },
      { "id": 59, "text": "DURING THE ELABORATION PHASE: No code is developed", "correct": false, "explanation": "During the elaboration phase, code IS developed. The architectural core of the system is programmed to validate the proposed architecture." },
      { "id": 60, "text": "DURING THE ELABORATION PHASE: Most of the requirements are discovered and stabilized", "correct": true, "explanation": "Correct. Elaboration is the phase where most requirements are discovered and stabilized, completing the analysis started in inception." },
      { "id": 61, "text": "DURING THE ELABORATION PHASE: A business case is created to establish the project's scope and costs", "correct": false, "explanation": "The preliminary business case is made during the INCEPTION phase, not elaboration. Elaboration refines the estimates." },
      { "id": 62, "text": "DURING THE ELABORATION PHASE: The risky core of the architecture is programmed", "correct": true, "explanation": "Correct. During elaboration, the architectural core of the system is programmed and tested, focusing on the riskiest parts." },
      { "id": 63, "text": "In UML, a responsibility means the specification of a method associated with a Java class", "correct": false, "explanation": "In UML, responsibility is a more general concept that includes both 'knowing' and 'doing'. It is not limited to just Java methods." },
      { "id": 64, "text": "In UML, a responsibility means the specification of an instance variable of a Java class", "correct": false, "explanation": "Instance variables are part of the 'knowing' responsibilities, but responsibility in UML is a broader concept that also includes actions." },
      { "id": 65, "text": "In UML, a responsibility means a contract or an obligation of a classifier", "correct": true, "explanation": "Correct. In UML, a responsibility is defined as a contract or obligation of a classifier (class), which includes both knowing and doing." },
      { "id": 66, "text": "In UML, a responsibility means the specification of an instance variable or a method associated with a Java class", "correct": false, "explanation": "Responsibility in UML is a more abstract concept of a contract/obligation, not simply the implementation in Java variables or methods." },
      { "id": 67, "text": "SSDs are expressed through UML communication diagrams", "correct": false, "explanation": "SSDs (System Sequence Diagrams) are expressed through UML SEQUENCE diagrams, not communication diagrams." },
      { "id": 68, "text": "SSDs show the order of events generated by actors external to the system", "correct": true, "explanation": "Correct. SSDs show the time sequence of system events generated by external actors for a specific use case scenario." },
      { "id": 69, "text": "Contracts are an input for SSDs of operations and for object design", "correct": false, "explanation": "It's the other way around: SSDs are input for contracts. SSDs identify the system operations, for which contracts are then written." },
      { "id": 70, "text": "A system event is an event internal to the system", "correct": false, "explanation": "A system event is an event that comes to the system from the OUTSIDE, generated by an external actor. Internal events are not system events." },
      { "id": 71, "text": "SSDs show events generated by actors external to the system", "correct": true, "explanation": "Correct. SSDs (System Sequence Diagrams) show the system events generated by external actors during the execution of a use case." },
      { "id": 72, "text": "As a percentage of the total functional requirements of a project, should 50% be identified by the end of the INCEPTION phase?", "correct": false, "explanation": "By the end of inception, about 70% of functional requirements should have been identified, not 50%. 50% is too little to complete inception." },
      { "id": 73, "text": "As a percentage of the total functional requirements of a project, should 100% be identified by the end of the ELABORATION phase?", "correct": true, "explanation": "Correct. By the end of elaboration, virtually all functional requirements should be identified to accurately plan the construction phase." },
      { "id": 74, "text": "White-box reuse is preferable to black-box reuse", "correct": false, "explanation": "Black-box reuse (composition) is generally preferable to white-box reuse (inheritance) because it offers greater flexibility and lower coupling." },
      { "id": 75, "text": "The inheritance mechanism is not preferable to the delegation mechanism for achieving software reuse", "correct": true, "explanation": "Correct. Delegation (composition) is often preferable to inheritance for reuse because it is more flexible and maintains lower coupling." },
      { "id": 76, "text": "Inheritance makes use of the delegation mechanism", "correct": false, "explanation": "Inheritance and delegation are ALTERNATIVE mechanisms for code reuse. Inheritance does not use delegation." },
      { "id": 77, "text": "The composition mechanism does not respect encapsulation", "correct": false, "explanation": "The composition mechanism DOES respect encapsulation because it accesses component objects only through their public interfaces." },
      { "id": 78, "text": "System operations can be identified while sketching SSDs", "correct": true, "explanation": "Correct. System operations are identified during the creation of SSDs, which show the events the system must handle." },
      { "id": 79, "text": "Contracts describe in detail the changes required by the execution of a system operation, they describe how these results should be obtained", "correct": false, "explanation": "Contracts describe WHAT must happen (post-conditions), but they do NOT describe HOW to achieve these results. The 'how' is part of the design." },
      { "id": 80, "text": "GoF patterns encourage the use of inheritance as a code reuse mechanism, particularly through the composite pattern", "correct": false, "explanation": "GoF patterns generally DISCOURAGE the overuse of inheritance for reuse, preferring composition. The Composite pattern uses inheritance for polymorphism, not for reuse." },
      { "id": 81, "text": "GoF patterns favor the use of the inheritance mechanism to achieve specialization", "correct": false, "explanation": "GoF patterns emphasize the principle 'favor composition over inheritance' - preferring composition to inheritance even for specialization." },
      { "id": 82, "text": "GoF patterns encourage software reuse mechanisms through the definition of class hierarchies", "correct": false, "explanation": "GoF patterns promote reuse through COMPOSITION and delegation, not through extensive class hierarchies." },
      { "id": 83, "text": "GoF patterns favor the use of the inheritance mechanism to achieve polymorphism", "correct": true, "explanation": "Correct. GoF patterns use inheritance primarily to achieve POLYMORPHISM (different behaviors with a common interface), not for code reuse." },
      { "id": 84, "text": "The GoF Composite pattern provides additional features to atomic elements (leaves), while maintaining a common interface", "correct": false, "explanation": "The Composite pattern does NOT provide additional features to leaves. It allows simple and composite objects to be treated uniformly." },
      { "id": 85, "text": "The GoF Composite pattern allows for the construction of class taxonomies", "correct": false, "explanation": "The Composite pattern allows for the construction of object TREES, not class taxonomies. Taxonomies are inheritance hierarchies." },
      { "id": 86, "text": "The GoF Composite pattern uses the specialization mechanism to make the interface of atomic entities exactly like the interface of composite entities", "correct": false, "explanation": "Composite uses generalization to make leaves and composite nodes implement the same interface, allowing for uniform treatment." },
      { "id": 87, "text": "The GoF Composite pattern allows avoiding subclass explosion to support a large number of extensions and their combinations", "correct": false, "explanation": "This is the DECORATOR pattern, not Composite. Composite organizes objects into tree structures, it does not prevent subclass explosion." },
      { "id": 88, "text": "The GoF Composite pattern allows for the construction of recursive structures so that to a client, the entire structure is seen as a single entity", "correct": true, "explanation": "Correct. The Composite pattern allows for the construction of tree structures where clients can treat simple and composite objects uniformly." },
      { "id": 89, "text": "Extreme programming promotes development followed by tests", "correct": false, "explanation": "XP promotes TDD (Test-Driven Development): tests are written first, THEN the code is written to make them pass. Tests precede development." },
      { "id": 90, "text": "Unit tests are intended to verify the communication between specific parts of the system", "correct": false, "explanation": "Unit tests verify the behavior of single UNITS (methods, classes) in isolation. Integration tests verify communication between parts." },
      { "id": 91, "text": "Setup, execution, verification, and teardown are the parts of a unit test", "correct": true, "explanation": "Correct. The typical phases of a unit test are: Setup, Exercise (execution), Verify, and Teardown (release)." },
      { "id": 92, "text": "Refactoring involves applying small transformations that preserve behavior", "correct": true, "explanation": "Correct. Refactoring consists of applying small transformations to the code that improve its structure without changing its external behavior." },
      { "id": 93, "text": "Unit tests are used to demonstrate that refactoring has not caused a regression", "correct": true, "explanation": "Correct. Unit tests serve as a safety net during refactoring, ensuring that the behavior remains unchanged." },
      { "id": 94, "text": "Object-oriented design in UP aims to identify responsibilities and assign them to an appropriate object or class", "correct": true, "explanation": "Correct. OOD in UP focuses on identifying software responsibilities and assigning them to the appropriate classes." },
      { "id": 95, "text": "Cohesion is the measure of how strongly an element is connected to, has knowledge of, and depends on other elements", "correct": false, "explanation": "This is the definition of COUPLING. Cohesion measures how strongly the responsibilities of a single element are related to each other." },
      { "id": 96, "text": "The GRASP patterns Information Expert and High Cohesion are evaluative patterns", "correct": false, "explanation": "Low Coupling and High Cohesion are evaluative GRASP patterns that provide criteria for evaluating the quality of design solutions." },
      { "id": 97, "text": "The creation of an object is the responsibility of an object that aggregates, contains an instance of the object to be created", "correct": true, "explanation": "Correct. According to the GRASP Creator pattern, the responsibility of creating an object often falls to the one that aggregates, contains, or intensively uses it." },
      { "id": 98, "text": "A class with high coupling does many unrelated things and performs too much work", "correct": false, "explanation": "This is the definition of low COHESION. High coupling indicates many dependencies on other classes, not necessarily many responsibilities." },
      { "id": 99, "text": "Refactoring is a practice promoted by the iterative and agile method XP", "correct": true, "explanation": "Correct. Refactoring is one of the fundamental practices of XP (Extreme Programming) and agile methods in general." },
      { "id": 100, "text": "Refactoring involves test-driven development, i.e., development preceded by tests", "correct": false, "explanation": "Refactoring and TDD are SEPARATE practices. Refactoring improves existing code; TDD is a development technique guided by tests." },
      { "id": 101, "text": "Refactoring is a structured and disciplined method for writing or restructuring existing code", "correct": true, "explanation": "Correct. Refactoring is a disciplined process for restructuring existing code, improving its structure without changing its behavior." },
      { "id": 102, "text": "DURING THE ELABORATION PHASE: Requirements and iterations are organized based on the end user's request", "correct": false, "explanation": "During elaboration, requirements are organized based on RISK and ARCHITECTURAL SIGNIFICANCE, not on the end user's requests." },
      { "id": 103, "text": "DURING THE ELABORATION PHASE: Requirements and iterations are organized based on risk, coverage (they must cover the entire system), and criticality", "correct": true, "explanation": "Correct. Elaboration organizes iterations based on risk, architectural criticality, and the need to cover all aspects of the system." },
      { "id": 104, "text": "DURING THE ELABORATION PHASE: Production-quality programming and testing activities are performed", "correct": true, "explanation": "Correct. During elaboration, production-quality code is developed for the architectural core, and appropriate tests are performed." },
      { "id": 105, "text": "DURING THE ELABORATION PHASE: 'Throwaway' prototypes are created to address major risks", "correct": false, "explanation": "During elaboration, the EVOLUTIONARY architectural core is developed, not 'throwaway' prototypes. Throwaway prototypes are typical of the inception phase." },
      { "id": 106, "text": "Responsibility is an abstraction of what a software object or component does or represents", "correct": true, "explanation": "Correct. Responsibility is an abstraction of what an object KNOWS or DOES." },
      { "id": 107, "text": "In Responsibility-Driven Development, software objects are considered to have responsibilities", "correct": true, "explanation": "Correct. RDD (Responsibility-Driven Development) views objects as entities that have specific responsibilities in the system." },
      { "id": 108, "text": "The requirements discipline is the process of discovering what needs to be built", "correct": true, "explanation": "Correct. The requirements discipline in UP aims to discover, document, and validate what the system must do." },
      { "id": 109, "text": "The requirements discipline must guide development towards the correct system", "correct": true, "explanation": "Correct. The requirements discipline ensures that the RIGHT system is developed (the one that truly meets user needs)." },
      { "id": 110, "text": "Contracts use pre-conditions and post-conditions to detail the changes to objects in a design model (software)", "correct": false, "explanation": "Contracts describe changes to objects in the DOMAIN MODEL (conceptual), not the design model (software)." },
      { "id": 111, "text": "System operations can be identified while sketching DCDs", "correct": false, "explanation": "System operations are identified earlier, while sketching SSDs, not DCDs. DCDs show how these operations are realized internally." },
      { "id": 112, "text": "In the Requirements Analysis phase, the first activity is to translate the collected information into a document that defines a set of requirements.", "correct": false, "explanation": "The first main phase of Requirements Analysis is Requirements Elicitation and Analysis; Requirements Specification, which consists of translating information into a document, comes later." },
      { "id": 113, "text": "In agile methodologies, software design and implementation are usually separate and produce detailed formal documents before coding.", "correct": false, "explanation": "In agile methodologies, design and implementation are intertwined and do not produce formal documents; the design is often recorded informally." },
      { "id": 114, "text": "The Unified Process (UP) is a software development methodology that follows a strictly sequential and waterfall approach.", "correct": false, "explanation": "UP encourages iterative and risk-driven development. Programming and testing begin before the analysis of all requirements is complete." },
      { "id": 115, "text": "The main purpose of the Inception phase in UP is to define all the detailed requirements of the project and generate a reliable cost estimate.", "correct": false, "explanation": "The purpose of the inception phase is not to define all requirements, nor to generate a reliable estimate or project plan. It is rather to decide if the project is worth a more serious investigation." },
      { "id": 116, "text": "The Vision document in UP summarizes the high-level requirements and is useful for establishing a common project vision among participants.", "correct": true, "explanation": "The Vision document summarizes some information contained in the use case model and supplementary specifications, briefly describing the project as context for participants and establishing a common vision." },
      { "id": 117, "text": "In UP, the Glossary also functions as a data dictionary, including information related to other data (metadata), such as validation rules.", "correct": true, "explanation": "In UP, the Glossary also plays the role of a data dictionary, a document containing data about other data, i.e., metadata, including examples of validation rules." },
      { "id": 118, "text": "The Requirements Discipline in UP focuses mainly on 'how' the system should be built, defining the technical and architectural solutions.", "correct": false, "explanation": "The Requirements Discipline is the process of discovering 'what' needs to be built and guiding development towards the correct system, defining the capabilities and conditions the system must conform to." },
      { "id": 119, "text": "According to the sources, use cases in UP are primarily represented by UML diagrams to visualize the interactions between actors and the system.", "correct": false, "explanation": "Use cases in UP are textual descriptions of interesting usage scenarios of the software system. The sources clearly state that use cases are textual documents, not diagrams." },
      { "id": 120, "text": "A Primary Actor in a use case is one who offers a service to the system.", "correct": false, "explanation": "The Primary Actor is the one who achieves user goals by using the system's services. The supporting actor is the one who offers a service to the system." },
      { "id": 121, "text": "In the detailed format of a use case, the 'Extensions' section is used to describe alternative scenarios, both success and failure, compared to the main scenario.", "correct": true, "explanation": "Extensions describe alternative scenarios, of success or failure, and how they are handled." },
      { "id": 122, "text": "When writing a use case in an essential style, it is crucial to include precise details about the user interface (GUI) with which the actor interacts.", "correct": false, "explanation": "The essential style implies ignoring the user interface and focusing on the user's goal and the system's responsibilities at an abstract level, independent of technological and UI details." },
      { "id": 123, "text": "The Black-box approach in writing use cases means describing exactly 'how' the system performs a certain action, including implementation details like database usage or SQL statements.", "correct": false, "explanation": "The Black-box approach means describing 'what' the system must do (behavior or functional requirements) without deciding how." },
      { "id": 124, "text": "To verify the usefulness of a use case, the Boss Test asks if the described activity represents a significant action for the user that justifies the implementation effort.", "correct": true, "explanation": "The Boss Test involves asking if a boss would be happy if a day's work was just the activity described in the use case; if the answer is no, the use case is not useful." },
      { "id": 125, "text": "The Domain Model represents the key concepts of the system as software objects with names and information similar to the real-world domain.", "correct": false, "explanation": "The Domain Model is an analysis tool that represents real-world concepts (conceptual classes) independently of the software implementation, while software objects with similar names to the domain are created in a later phase (design and implementation) and represented, for example, in the Design Model (via DCDs), inspired by the Domain Model." },
      { "id": 126, "text": "System Sequence Diagrams (SSDs) show the interactions between the internal objects of the system to realize an operation.", "correct": false, "explanation": "A System Sequence Diagram is used to represent the input and output events involving the system during an interaction with external actors, viewing the system as a black box." },
      { "id": 127, "text": "System operation contracts describe in detail 'how' the changes in the system's state are achieved after an operation is executed.", "correct": false, "explanation": "A contract describes in great detail the changes required by the execution of a system operation without, however, describing how they are to be obtained." },
      { "id": 128, "text": "A Query system operation modifies the state of the system and for this reason must have post-conditions in its contract.", "correct": false, "explanation": "A Query system operation does not modify the state of the system, it only calculates and returns a value, and for this reason, it has no post-conditions. Post-conditions describe changes in the state of objects." },
      { "id": 129, "text": "Object-oriented design (OOD) emphasizes the definition of software objects and how they collaborate to meet requirements.", "correct": true, "explanation": "Object-oriented design emphasizes the definition of software objects and how they collaborate to meet requirements." },
      { "id": 130, "text": "GRASP patterns are a repository of specific design solutions for recurring problems in software implementation, similar to GoF patterns.", "correct": false, "explanation": "GRASP patterns are principles for assigning responsibilities. GoF patterns are named descriptions of recurring design problems and a solution." },
      { "id": 131, "text": "According to the GRASP Information Expert pattern, a responsibility should be assigned to the class that has the necessary information to fulfill it.", "correct": true, "explanation": "The Information Expert pattern suggests assigning a responsibility to the class that has the necessary information to fulfill it, to the information expert." },
      { "id": 132, "text": "Unit tests are a type of test designed to verify the complete software system, considering the interactions between all major components.", "correct": false, "explanation": "Unit tests test single units of code. Integration tests test communication between specific parts, while end-to-end tests test the entire system." },
      { "id": 133, "text": "In the eXtreme Programming methodology, tests are written before writing the corresponding code (test-driven development).", "correct": true, "explanation": "In some agile methodologies like eXtreme Programming, tests are written before writing the code." },
      { "id": 134, "text": "In the waterfall model, it is assumed that requirements are predictable and stable from the beginning with a low rate of change.", "correct": true, "explanation": "The waterfall model assumes that specifications are predictable and stable and can be correctly defined from the beginning, in the face of a low rate of change." },
      { "id": 135, "text": "According to sources, iterative development methods are statistically associated with lower success rates than the waterfall model.", "correct": false, "explanation": "Based on statistical data, iterative methods are associated with higher success and productivity rates, as well as lower defect levels. In contrast, the waterfall approach is characterized by lower productivity and higher defect rates." },
      { "id": 136, "text": "One of the main reasons requirements change is the inability of customers to fully predict how a system will affect operational practices before it is delivered and used.", "correct": true, "explanation": "Requirements change because it is impossible for customers to predict how a system will affect operational practices, how it will interact with other systems, and which user operations will need to be automated; the real requirements become clear only after the system has been delivered and used." },
      { "id": 137, "text": "In Unified Process (UP), the Requirements Discipline is a set of activities that take place exclusively at the beginning of the project, before any other discipline.", "correct": false, "explanation": "In UP, disciplines (types of activities) are not sequential and are performed in the project in every iteration. The Requirements Discipline is the process of discovering 'what' needs to be built and guiding development towards the correct system." },
      { "id": 138, "text": "According to UP, it is necessary to define 100% of the detailed requirements before starting any programming or testing activities.", "correct": false, "explanation": "In UP, programming and testing begin when only 10% or 20% of the most significant requirements have been specified. Furthermore, one does not try to define all requirements before starting design or implementation." },
      { "id": 139, "text": "The Supplementary Specifications document in UP is intended to contain all functional requirements of the system, including those described in use cases.", "correct": false, "explanation": "The Supplementary Specifications contain what does not fit into use cases, such as non-functional requirements or functional requirements not expressible through use cases. The main functional requirements are described in the Use-Case Model." },
      { "id": 140, "text": "During the Inception phase in UP, the goal is to analyze most of the use cases in detail to gain a complete understanding of the functional requirements.", "correct": false, "explanation": "During inception, about 10% of the use cases are analyzed in detail. The purpose of Inception is not to gather all requirements, but to understand if the project deserves a more serious investigation (feasibility)." },
      { "id": 141, "text": "In the context of UP, Agile Modeling suggests that the value of modeling lies primarily in creating reliable and complete specification documents.", "correct": false, "explanation": "Agile Modeling suggests that the value of modeling is to improve understanding, rather than to document reliable specifications." },
      { "id": 142, "text": "A Supporting Actor in a use case is one who uses the system to achieve their user goals.", "correct": false, "explanation": "The Supporting Actor is the one who offers a service to the system. The Primary Actor is the one who achieves user goals by using the system's services." },
      { "id": 143, "text": "When writing a use case in an essential style, the description focuses on the user's concrete actions and the specific details of the user interface.", "correct": false, "explanation": "The essential style implies that the narrative is expressed at the level of intentions and responsibilities, ignoring the user interface and remaining independent of technological details." },
      { "id": 144, "text": "The 'EBP Test' (Elementary Business Process) to verify the usefulness of a use case asks if the activity described by the use case adds measurable business value.", "correct": true, "explanation": "An elementary business process is an activity that adds measurable business value. The EBP Test assesses whether the use case represents a valuable interaction." },
      { "id": 145, "text": "A detailed use case, to pass the Size Test, should ideally be described on a single page.", "correct": false, "explanation": "To pass the Size Test, a detailed use case normally comprises several steps and requires 3 to 10 pages of text. A single action or step rarely constitutes a useful use case." },
      { "id": 146, "text": "The Domain Model aims to describe the key concepts of the problem domain and their relationships, also serving as inspiration for the software classes.", "correct": true, "explanation": "The Domain Model describes the significant concepts of the system as domain objects and relates the concepts. It serves to understand the domain and its vocabulary, define a common language, and is a source of inspiration for OOD, reducing the 'representation gap'." },
      { "id": 147, "text": "In a UML class diagram representing a Domain Model, associations should indicate the direction of navigability between software classes.", "correct": false, "explanation": "Associations in a domain model are by nature bidirectional. The reading direction (optionally indicated) is not a specification of visibility or navigability between software entities." },
      { "id": 148, "text": "System Sequence Diagrams (SSDs) show the order and logic of interactions between the internal objects of the software system.", "correct": false, "explanation": "System Sequence Diagrams are used to represent the input and output events involving the system during an interaction with external actors, viewing the system as a black box. Sequence diagrams (not system diagrams) show interactions between internal objects." },
      { "id": 149, "text": "Post-conditions in a contract describe the actions the system must perform to satisfy the operation, such as database instructions or calls to specific methods.", "correct": false, "explanation": "A contract describes the changes required by the execution of a system operation in terms of Domain Model objects, without describing how they are to be obtained. Post-conditions describe the state of objects after the operation, not the actions to get there." },
      { "id": 150, "text": "A 'Transformation' system operation does not modify the state of the system and therefore does not require post-conditions in its contract.", "correct": false, "explanation": "A Transformation system operation modifies the state of the system and for this reason should have post-conditions that describe these changes. Query operations do not modify the state and do not have post-conditions." },
      { "id": 151, "text": "Object-Oriented Design (OOD) focuses primarily on defining software objects and how they should collaborate to meet requirements.", "correct": true, "explanation": "Object-oriented design emphasizes the definition of software objects and how they collaborate to meet requirements." },
      { "id": 152, "text": "According to the GRASP principle 'Information Expert', the responsibility for saving an object to the database should be assigned to the class that represents that object (e.g., the Sale class should save itself).", "correct": false, "explanation": "In general, Expert does not apply to persistence (saving to DB) because assigning this responsibility to the class itself would cause problems of low cohesion (it also deals with persistence), high coupling (linked to system classes like DB drivers), and logical duplication. This basic architectural principle suggests separating different logics into subsystems." },
      { "id": 153, "text": "The GoF Strategy pattern allows defining a family of algorithms and making them interchangeable, allowing clients to use different algorithms independently.", "correct": true, "explanation": "The Strategy pattern allows the definition of a family of algorithms, encapsulates each one, and makes them interchangeable. It allows algorithms to be modified independently of clients and decouples algorithms from clients." },
      { "id": 154, "text": "The GoF Iterator pattern exposes the internal structure of a collection to allow the caller to access and traverse its elements.", "correct": false, "explanation": "The Iterator pattern suggests implementing an object that allows access and traversal of the collection, providing a standard interface that hides the internal structure." },
      { "id": 155, "text": "In the GoF Visitor pattern, the ConcreteVisitor is the object that is visited by the data structure.", "correct": false, "explanation": "In the Visitor pattern, the ConcreteVisitor is the object that traverses the collection and applies a specific method to each visited object (Element). The objects in the collection (Element) are the ones that are visited." },
      { "id": 156, "text": "The Model-View Separation Principle suggests separating objects that manage application logic (Model/Domain) from those that manage the user interface (View/UI).", "correct": true, "explanation": "The Model-View separation principle states that the Model (domain layer, objects with application logic) and the View (UI layer, user interface objects) must be separated. UI objects delegate application logic requests to non-UI objects (domain objects)." },
      { "id": 157, "text": "Unit tests are intended to verify the overall functioning of the software system from the user's point of view, considering the system as a black box.", "correct": false, "explanation": "Unit tests test single units of code, not the system as a whole. Acceptance tests are those that verify the overall functioning of the black-box system from the user's point of view, with reference to use cases." },
      { "id": 158, "text": "The Verification phase in a unit test consists of preparing the objects and resources necessary for the execution of the test.", "correct": false, "explanation": "The Setup phase creates the object or group of objects to be verified and prepares resources. The Verification phase evaluates whether the results obtained match those expected." },
      { "id": 159, "text": "Object-oriented analysis is driven by responsibilities.", "correct": false, "explanation": "No, it is object-oriented design that is driven by responsibilities." },
      { "id": 160, "text": "Object-oriented analysis considers a software project as a 'community of objects' with collaborating responsibilities.", "correct": false, "explanation": "No, it is object-oriented design that considers a software project as a 'community of objects' with collaborating responsibilities." },
      { "id": 161, "text": "Identifying responsibilities, assigning these responsibilities, and investigating how to fulfill these responsibilities are the steps of 'responsibility-driven development'.", "correct": true, "explanation": "Responsibility-Driven Development is based on exactly these steps: identifying responsibilities, assigning them to objects, and determining how to realize them." },
      { "id": 162, "text": "Controller, High Cohesion, and Abstract Factory are some examples of GRASP patterns.", "correct": false, "explanation": "Controller and High Cohesion are part of the GRASP patterns, while Abstract Factory is a GoF pattern, not GRASP." },
      { "id": 163, "text": "GRASP patterns are the main tool used in the requirements discipline of UP.", "correct": false, "explanation": "GRASP patterns are used in object-oriented design, not as the main tool for requirements gathering in UP." },
      { "id": 164, "text": "UP temporally organizes the development cycle into four iterations and the iterations into different phases.", "correct": false, "explanation": "UP speaks of four phases (inception, elaboration, construction, transition), each of which can contain multiple iterations; not four iterations overall." },
      { "id": 165, "text": "Inception, elaboration, construction, and transition in UP are temporally separate and never overlap.", "correct": true, "explanation": "They are distinct phases and never overlap." },
      { "id": 166, "text": "Specification, development, validation, and evolution in UP are temporally separate activities and never overlap.", "correct": false, "explanation": "In UP, disciplines (specification, development, validation, evolution, etc.) occur concurrently during iterations, not in isolated sequence." },
      { "id": 167, "text": "During development with UP, refactoring mechanisms are not used to cope with changes.", "correct": false, "explanation": "UP encourages continuous refactoring within iterations to manage changes iteratively." },
      { "id": 168, "text": "Business modeling, requirements, design, implementation, testing, and deployment in UP are temporally separate and never overlap.", "correct": false, "explanation": "UP disciplines (business modeling, requirements, design, implementation, testing, deployment, etc.) take place in parallel within each iteration, not in separate phases." },
      { "id": 169, "text": "Test-driven development is a practice promoted by the waterfall method that involves development preceded by tests.", "correct": false, "explanation": "TDD originated in the context of Extreme Programming, not the waterfall model." },
      { "id": 170, "text": "The purpose of unit tests is to verify the overall connection between all elements of the system.", "correct": false, "explanation": "Unit testing checks isolated components; verifying the overall connection is the job of integration or system tests." },
      { "id": 171, "text": "Unit tests consist of setup, execution, verification, and teardown.", "correct": true, "explanation": "A typical unit test cycle includes setup, execution, assertion (verification), and teardown." },
      { "id": 172, "text": "Test-driven development and refactoring are practices particularly promoted by the development known as extreme programming.", "correct": true, "explanation": "TDD and refactoring are two core practices of Extreme Programming." },
      { "id": 173, "text": "The Strategy pattern deals with how an object performs a certain task and encapsulates an algorithm.", "correct": true, "explanation": "Strategy defines a family of interchangeable algorithms, and the choice of behavior is delegated to different classes that encapsulate each algorithm." },
      { "id": 174, "text": "The State pattern deals with how an object performs a certain task and encapsulates an algorithm.", "correct": false, "explanation": "State encapsulates different states of an object and changes behavior based on the state, not on interchangeable algorithms." },
      { "id": 175, "text": "The State pattern allows the definition of a family of interchangeable algorithms.", "correct": false, "explanation": "Defining a family of interchangeable algorithms is characteristic of the Strategy pattern, not the State pattern." },
      { "id": 176, "text": "The State pattern decouples algorithms from the clients that want to use them dynamically.", "correct": false, "explanation": "Decoupling algorithms and clients is the job of the Strategy pattern; State, on the other hand, decouples behavior based on internal state." },
      { "id": 177, "text": "The State pattern and the Strategy pattern are syntactically equivalent but differ in application.", "correct": false, "explanation": "They are syntactically different." },
      { "id": 178, "text": "The essential characteristics of software are Maintainability, Dependability, Efficiency, and Usability.", "correct": true, "explanation": "Yes, these are the ones." },
      { "id": 179, "text": "A software development process describes a disciplined approach to building, releasing, and eventually maintaining software. There are four fundamental process activities: Specification, Development, Validation, and Evolution/Maintenance.", "correct": true, "explanation": "Yes, these are the ones." },
      { "id": 180, "text": "The biggest problem during software development is change (due to the client, technical or contextual adjustments).", "correct": true, "explanation": "They take time, during which it is not guaranteed that things will remain unchanged." },
      { "id": 181, "text": "Unified Process (UP) organizes work and iterations into four NON-sequential phases. The end of each phase corresponds to a milestone: Inception, Elaboration, Construction, and Transition.", "correct": false, "explanation": "Unified Process (UP) organizes work and iterations into four sequential phases. The end of each phase corresponds to a milestone: Inception, Elaboration, Construction, and Transition." },
      { "id": 182, "text": "Elaboration is the final series of iterations in which the requirements are consolidated and the core of the system's architecture is developed.", "correct": false, "explanation": "Elaboration is the INITIAL series of iterations in which the requirements are consolidated and the core of the system's architecture is developed." },
      { "id": 183, "text": "The domain model is part of the requirements phase that consists of a textual representation describing the fundamental concepts of a system, highlighting the main entities of the domain and their relationships.", "correct": false, "explanation": "The domain model is part of business modeling that consists of a visual representation describing the fundamental concepts of a system, highlighting the main entities of the domain and their relationships." },
      { "id": 184, "text": "The System Sequence Diagram (SSD) is a tool of the requirements discipline used to represent the input and output events involving the system during an interaction with external actors.", "correct": true, "explanation": "Correct definition." },
      { "id": 185, "text": "Layered architecture divides a complex system into a set of software elements that, as much as possible, can be developed and modified independently of each other.", "correct": true, "explanation": "Correct definition." },
      { "id": 186, "text": "Static models describe the behavior of the system and the interactions between objects (for example, with sequence diagrams).", "correct": false, "explanation": "Dynamic models describe the behavior of the system and the interactions between objects (for example, with sequence diagrams)." },
      { "id": 187, "text": "Dynamic models represent the structure of the system, defining classes, attributes, and relationships (typically through class diagrams).", "correct": false, "explanation": "Static models represent the structure of the system, defining classes, attributes, and relationships (typically through class diagrams)." },
      { "id": 188, "text": "GRASP (General Responsibility Assignment Software Patterns) are a set of patterns used to effectively assign responsibilities to objects in an Object-Oriented system.", "correct": true, "explanation": "Correct definition." },
      { "id": 189, "text": "GoF patterns promote the use of inheritance over composition, as composition avoids dependency problems.", "correct": false, "explanation": "GoF patterns promote the use of composition over inheritance, as composition avoids dependency problems." },
      { "id": 190, "text": "End-to-end tests verify the functioning of the small parts (units) of the system.", "correct": false, "explanation": "End-to-end tests verify the overall connection between all elements of the system." },
      { "id": 191, "text": "Refactoring is a structured and disciplined method for writing or restructuring existing code by modifying its external behavior.", "correct": false, "explanation": "Refactoring is a structured and disciplined method for writing or restructuring existing code without modifying its external behavior." },
      { "id": 192, "text": "Unit tests verify the functioning of the small parts (units) of the system. A unit test method is logically composed of four parts: Setup, Execution, Verification, and Teardown.", "correct": true, "explanation": "Unit tests verify the functioning of the small parts (units) of the system. A unit test method is logically composed of four parts: Setup, Execution, Verification, and Teardown." },
      { "id": 193, "text": "The logical architecture of a software system is the large-scale macro-organization of software classes into packages, subsystems, and layers.", "correct": true, "explanation": "Correct definition." },
      { "id": 194, "text": "In contracts, pre-conditions define the state of the system necessary for an operation to be executed, while post-conditions describe the effects of the operation on the domain model.", "correct": true, "explanation": "Correct definition." }
    ]
  }
}