{
  "global": {
    "back_to_home": "‚Üê Torna alla homepage",
    "show_answer": "Mostra Risposta",
    "next": "Successiva ‚Üí",
    "stop_quiz": "Ferma Quiz",
    "restart_quiz": "üîÑ Ricomincia Quiz",
    "previous": "‚Üê Precedente",
    "correct": "Corrette",
    "incorrect": "Sbagliate",
    "question_progress": "Domanda {current} di {total}",
    "go_to": "Vai a:",
    "quiz_finished": "Quiz Terminato!",
    "score_summary": "Ecco il riepilogo della tua sessione.",
    "total_score": "Punteggio Totale",
    "correct_total": "Corrette (su Totali)",
    "incorrect_total": "Sbagliate (su Totali)",
    "correct_answered": "Corrette / Date",
    "incorrect_answered": "Sbagliate / Date",
    "finish_quiz_button": "üèÅ Termina Quiz",
    "select_answer_alert": "Per favore, seleziona una risposta prima.",
    "true_option": "‚úì Vero",
    "false_option": "‚úó Falso",
    "explanation": "Spiegazione:"
  },
  "home": {
    "main_title": "üéì Quiz degli Esami",
    "subtitle": "Scegli il tipo di quiz che vuoi affrontare",
    "theory_title": "Sviluppo Applicazioni Software - Teoria",
    "theory_desc": "Metti alla prova le tue conoscenze sui concetti fondamentali dello sviluppo di applicazioni software.",
    "theory_prompt": "Scegli il numero di domande:",
    "theory_20": "20 Domande",
    "theory_50": "50 Domande",
    "theory_100": "100 Domande",
    "theory_all": "Tutte le Domande",
    "pattern_title": "Sviluppo Applicazioni Software - Design Patterns",
    "pattern_desc": "Approfondisci i pattern di progettazione, dai GRASP ai GoF, e come applicarli.",
    "network_title": "Tecnologie e servizi di rete",
    "network_desc": "Mettiti alla prova su protocolli, architetture e tecnologie di rete."
  },
  "pattern_page": {
    "title": "üèóÔ∏è Sviluppo Applicazioni Software - Quiz sui Design Pattern"
  },
  "theory_page": {
    "title": "üìö Sviluppo Applicazioni Software - Quiz di Teoria",
    "question_title": "Domanda {number}"
  },
  "network_page": {
    "title": "üåê Tecnologie e servizi di rete - Quiz",
    "question_title": "Domanda {number}"
  },
  "questions": {
    "pattern": [
      { "pattern": "Creator", "category": "GRASP", "type": "Problema-Soluzione", "question": "Quale problema risolve il pattern Creator?", "options": ["Chi deve essere responsabile per la creazione di istanze di una classe?", "Come mantenere basso l'accoppiamento tra classi?", "Come assegnare responsabilit√† agli oggetti?", "Come gestire la comunicazione tra oggetti?"], "correct": 0, "explanation": "Il pattern Creator affronta il problema di determinare quale classe dovrebbe essere responsabile della creazione di istanze di altre classi." },
      { "pattern": "Information Expert", "category": "GRASP", "type": "Problema-Soluzione", "question": "Quale soluzione propone il pattern Information Expert?", "options": ["Centralizzare tutte le informazioni in una classe", "Assegnare la responsabilit√† alla classe che ha le informazioni necessarie", "Creare una classe dedicata per ogni tipo di informazione", "Utilizzare variabili globali per condividere informazioni"], "correct": 1, "explanation": "Information Expert suggerisce di assegnare la responsabilit√† alla classe che possiede le informazioni necessarie per svolgere quel compito." },
      { "pattern": "Low Coupling", "category": "GRASP", "type": "Problema-Soluzione", "question": "Quale problema affronta il pattern Low Coupling?", "options": ["Come aumentare la dipendenza tra classi?", "Come ridurre l'impatto dei cambiamenti e aumentare il riuso?", "Come centralizzare le responsabilit√†?", "Come aumentare le prestazioni del sistema?"], "correct": 1, "explanation": "Low Coupling mira a ridurre le dipendenze tra classi per minimizzare l'impatto dei cambiamenti e favorire il riuso." },
      { "pattern": "High Cohesion", "category": "GRASP", "type": "Problema-Soluzione", "question": "Cosa promuove il pattern High Cohesion?", "options": ["Classi con responsabilit√† molto diverse tra loro", "Classi con responsabilit√† strettamente correlate e focalizzate", "Classi con molte dipendenze esterne", "Classi con metodi molto lunghi e complessi"], "correct": 1, "explanation": "High Cohesion promuove classi con responsabilit√† strettamente correlate e ben focalizzate, rendendo il codice pi√π comprensibile e mantenibile." },
      { "pattern": "Controller", "category": "GRASP", "type": "Problema-Soluzione", "question": "Quale problema risolve il pattern Controller?", "options": ["Come gestire l'interfaccia utente?", "Chi dovrebbe gestire gli eventi di input del sistema?", "Come implementare la persistenza dei dati?", "Come ottimizzare le prestazioni del database?"], "correct": 1, "explanation": "Il pattern Controller determina quale oggetto dovrebbe ricevere e coordinare (controllare) gli eventi di input del sistema." },
      { "pattern": "Singleton", "category": "GoF Creational", "type": "Problema-Soluzione", "question": "Quale problema risolve il pattern Singleton?", "options": ["Come creare famiglie di oggetti correlati?", "Come garantire che una classe abbia una sola istanza?", "Come separare la costruzione di oggetti complessi?", "Come clonare oggetti prototipo?"], "correct": 1, "explanation": "Singleton garantisce che una classe abbia una sola istanza e fornisce un punto di accesso globale ad essa." },
      { "pattern": "Abstract Factory", "category": "GoF Creational", "type": "Problema-Soluzione", "question": "Quale soluzione fornisce il pattern Abstract Factory?", "options": ["Crea una singola istanza globale", "Fornisce un'interfaccia per creare famiglie di oggetti correlati", "Separa l'algoritmo dalla struttura dati", "Permette di aggiungere nuove operazioni senza modificare le classi"], "correct": 1, "explanation": "Abstract Factory fornisce un'interfaccia per creare famiglie di oggetti correlati o dipendenti senza specificare le loro classi concrete." },
      { "pattern": "Adapter", "category": "GoF Structural", "type": "Problema-Soluzione", "question": "Quale problema risolve il pattern Adapter?", "options": ["Come comporre oggetti in strutture ad albero?", "Come permettere a classi con interfacce incompatibili di lavorare insieme?", "Come aggiungere responsabilit√† a oggetti dinamicamente?", "Come condividere efficientemente oggetti simili?"], "correct": 1, "explanation": "Adapter permette a classi con interfacce incompatibili di lavorare insieme, agendo come un ponte tra di esse." },
      { "pattern": "Composite", "category": "GoF Structural", "type": "Problema-Soluzione", "question": "Quale struttura crea il pattern Composite?", "options": ["Una catena di oggetti collegati", "Una struttura ad albero di oggetti", "Una pila di oggetti", "Una mappa di oggetti chiave-valore"], "correct": 1, "explanation": "Composite permette di comporre oggetti in strutture ad albero per rappresentare gerarchie parte-tutto." },
      { "pattern": "Decorator", "category": "GoF Structural", "type": "Problema-Soluzione", "question": "Come funziona il pattern Decorator?", "options": ["Modifica direttamente la classe originale", "Avvolge l'oggetto originale in uno o pi√π wrapper", "Sostituisce completamente l'oggetto originale", "Crea una copia modificata dell'oggetto"], "correct": 1, "explanation": "Decorator permette di aggiungere nuove funzionalit√† agli oggetti avvolgendoli in wrapper che contengono i nuovi comportamenti." },
      { "pattern": "Observer", "category": "GoF Behavioral", "type": "Problema-Soluzione", "question": "Quale problema risolve il pattern Observer?", "options": ["Come iterare attraverso una collezione?", "Come notificare automaticamente pi√π oggetti quando cambia lo stato?", "Come incapsulare algoritmi intercambiabili?", "Come gestire richieste in una catena di handler?"], "correct": 1, "explanation": "Observer definisce una dipendenza uno-a-molti tra oggetti, cos√¨ quando uno cambia stato, tutti i dipendenti vengono notificati automaticamente." },
      { "pattern": "State", "category": "GoF Behavioral", "type": "Problema-Soluzione", "question": "Quale soluzione propone il pattern State?", "options": ["Usa un grande switch/if per gestire gli stati", "Incapsula ogni stato in una classe separata", "Memorizza tutti gli stati in un array", "Ignora completamente il concetto di stato"], "correct": 1, "explanation": "State permette a un oggetto di cambiare il suo comportamento quando il suo stato interno cambia, incapsulando ogni stato in una classe separata." },
      { "pattern": "Strategy", "category": "GoF Behavioral", "type": "Problema-Soluzione", "question": "Quale problema affronta il pattern Strategy?", "options": ["Come gestire le notifiche tra oggetti?", "Come rendere algoritmi intercambiabili in runtime?", "Come visitare elementi di una struttura complessa?", "Come gestire stati complessi di un oggetto?"], "correct": 1, "explanation": "Strategy definisce una famiglia di algoritmi, li incapsula e li rende intercambiabili durante l'esecuzione." },
      { "pattern": "Visitor", "category": "GoF Behavioral", "type": "Problema-Soluzione", "question": "Quale vantaggio offre il pattern Visitor?", "options": ["Semplifica la struttura degli oggetti visitati", "Permette di aggiungere nuove operazioni senza modificare le classi esistenti", "Riduce il numero di classi nel sistema", "Migliora le prestazioni dell'accesso ai dati"], "correct": 1, "explanation": "Visitor permette di definire nuove operazioni senza cambiare le classi degli elementi su cui opera, separando algoritmi dalla struttura." },
      { "pattern": "Creator", "category": "GRASP", "type": "UML", "question": "Nel diagramma UML del pattern Creator, quale relazione √® tipicamente mostrata?", "options": ["Ereditariet√† tra creator e prodotto", "Composizione o aggregazione tra creator e prodotto", "Associazione bidirezionale", "Dipendenza circolare"], "correct": 1, "explanation": "Il Creator tipicamente ha una relazione di composizione o aggregazione con gli oggetti che crea, mostrata con diamante pieno o vuoto." },
      { "pattern": "Singleton", "category": "GoF Creational", "type": "UML", "question": "Come √® rappresentato il costruttore nel diagramma UML di Singleton?", "options": ["Pubblico (+)", "Privato (-)", "Protetto (#)", "Statico (sottolineato)"], "correct": 1, "explanation": "Nel Singleton, il costruttore √® privato (-) per impedire l'istanziazione diretta dall'esterno della classe." },
      { "pattern": "Observer", "category": "GoF Behavioral", "type": "UML", "question": "Nel pattern Observer, quale interfaccia implementano tipicamente gli observer?", "options": ["Subject", "Observer o Listener", "ConcreteSubject", "Publisher"], "correct": 1, "explanation": "Gli observer implementano un'interfaccia Observer (o Listener) che definisce il metodo update() per ricevere notifiche." },
      { "pattern": "Strategy", "category": "GoF Behavioral", "type": "UML", "question": "Nel diagramma UML di Strategy, il Context ha quale tipo di relazione con Strategy?", "options": ["Ereditariet√†", "Composizione", "Realizzazione", "Dipendenza semplice"], "correct": 3, "explanation": "Il Context utilizza l'interfaccia Strategy per delegare l'esecuzione dell'algoritmo, il che stabilisce una dipendenza semplice. Questo permette al Context di variare l'algoritmo concreto in modo flessibile." },
      { "pattern": "Composite", "category": "GoF Structural", "type": "UML", "question": "Nel pattern Composite, come √® mostrata la relazione tra Composite e Component?", "options": ["Aggregazione semplice", "Composizione ricorsiva (Composite contiene Component)", "Ereditariet√† multipla", "Associazione bidirezionale"], "correct": 1, "explanation": "Composite eredita da Component e contiene anche una collezione di Component, creando una struttura ricorsiva." },
      { "pattern": "Decorator", "category": "GoF Structural", "type": "UML", "question": "Nel pattern Decorator, quale caratteristica ha la classe Decorator?", "options": ["√à finale e non pu√≤ essere estesa", "Implementa la stessa interfaccia del componente decorato", "√à statica e contiene solo metodi di utilit√†", "√à astratta e non pu√≤ essere istanziata"], "correct": 1, "explanation": "Decorator implementa la stessa interfaccia del componente che decora, permettendo di sostituirlo trasparentemente." }
    ],
    "theory": [
      { "id": 1, "text": "In UP, la disciplina dei requisiti ha l'obiettivo di produrre una lista dei requisiti, capire il contesto del sistema, catturare i requisiti funzionali e i requisiti non-funzionali", "correct": true, "explanation": "La disciplina dei requisiti in UP ha effettivamente come obiettivi principali: produrre una lista dei requisiti, comprendere il contesto del sistema, e catturare sia i requisiti funzionali che non-funzionali." },
      { "id": 2, "text": "Il modello di dominio include la definizione di oggetti, associazioni e attributi di classi software", "correct": false, "explanation": "Il modello di dominio rappresenta classi CONCETTUALI del dominio del problema, non classi software. Include oggetti concettuali, associazioni e attributi del mondo reale." },
      { "id": 3, "text": "Il modello di dominio √® un dizionario visuale delle classi concettuali", "correct": true, "explanation": "Corretto. Il modello di dominio √® una rappresentazione visuale (dizionario visuale) delle classi concettuali rilevanti nel dominio del problema." },
      { "id": 4, "text": "Il modello di dominio √® una rappresentazione testuale delle classi concettuali, oggetti reali del dominio", "correct": false, "explanation": "Il modello di dominio √® una rappresentazione VISUALE (non testuale) delle classi concettuali. Utilizza diagrammi UML per rappresentare graficamente i concetti." },
      { "id": 5, "text": "Il modello di dominio non √® parte della disciplina dei requisiti", "correct": true, "explanation": "Il modello di dominio √® parte della disciplina di Modellazione del Business in UP. Aiuta a comprendere e documentare i concetti del dominio del problema." },
      { "id": 6, "text": "Nelle associazioni nel modello di dominio la direzione di lettura va sempre specificata", "correct": false, "explanation": "La direzione di lettura nelle associazioni del modello di dominio NON va sempre specificata. √à opzionale e si usa solo quando serve chiarire il significato dell'associazione." },
      { "id": 7, "text": "L'associazione nel modello di dominio √® per sua natura unidirezionale", "correct": false, "explanation": "Le associazioni nel modello di dominio sono per natura BIDIREZIONALI. Rappresentano relazioni concettuali che possono essere navigate in entrambe le direzioni." },
      { "id": 8, "text": "L'associazione nel modello di dominio rappresenta una relazione significativa tra classi", "correct": true, "explanation": "Corretto. Le associazioni nel modello di dominio rappresentano relazioni significative e rilevanti tra le classi concettuali del dominio." },
      { "id": 9, "text": "L'associazione nel modello di dominio rappresenta un valore logico degli oggetti di una classe", "correct": false, "explanation": "Le associazioni rappresentano RELAZIONI tra classi, non valori logici degli oggetti. I valori logici sono rappresentati dagli attributi." },
      { "id": 10, "text": "L'associazione nel modello di dominio rappresenta un'insieme di n-tuple di oggetti delle classi", "correct": true, "explanation": "Matematicamente, un'associazione pu√≤ essere vista come un insieme di n-tuple (coppie, triple, ecc.) di oggetti delle classi coinvolte nella relazione." },
      { "id": 11, "text": "Il MODELLO DI DOMINIO: Insieme di diagrammi di classi UML che includono associazioni tra classi software", "correct": false, "explanation": "Il modello di dominio include associazioni tra classi CONCETTUALI, non classi software. Le classi software appartengono al modello di progetto." },
      { "id": 12, "text": "Il MODELLO DI DOMINIO: Rappresentazione grafica degli oggetti software", "correct": false, "explanation": "Il modello di dominio rappresenta oggetti CONCETTUALI del dominio del problema, non oggetti software che appartengono all'implementazione." },
      { "id": 13, "text": "Il MODELLO DI DOMINIO: Rappresentazione visuale delle classi concettuali", "correct": true, "explanation": "Corretto. Il modello di dominio √® una rappresentazione visuale delle classi concettuali rilevanti nel dominio del problema." },
      { "id": 14, "text": "Il MODELLO DI DOMINIO: Insieme di diagrammi di classi UML che includono associazioni tra classi concettuali", "correct": true, "explanation": "Corretto. Il modello di dominio utilizza diagrammi di classi UML per rappresentare classi concettuali e le loro associazioni." },
      { "id": 15, "text": "Il MODELLO DI DOMINIO: Rappresentazione visuale delle classi JAVA", "correct": false, "explanation": "Il modello di dominio rappresenta classi CONCETTUALI del dominio, non classi Java che sono parte dell'implementazione software." },
      { "id": 16, "text": "Il MODELLO DI DOMINIO: Insieme di diagrammi di classi UML che includono le responsabilit√† di fare", "correct": false, "explanation": "Il modello di dominio NON include responsabilit√† 'di fare' (metodi). Le responsabilit√† sono assegnate durante la fase di progetto, non nell'analisi del dominio." },
      { "id": 17, "text": "Un caso d'uso rappresenta una maniera di utilizzare il sistema da parte di un utente per raggiungere un suo obiettivo", "correct": true, "explanation": "Corretto. Un caso d'uso descrive come un attore (utente) interagisce con il sistema per raggiungere un obiettivo specifico." },
      { "id": 18, "text": "La narrativa di un caso d'uso viene espressa a livello delle intenzioni dell'utente e della responsabilit√† del sistema", "correct": true, "explanation": "Corretto. I casi d'uso sono scritti dal punto di vista delle intenzioni dell'utente e delle responsabilit√† che il sistema deve assumere per soddisfarle." },
      { "id": 19, "text": "La narrativa di un caso d'uso viene espressa a livello delle azioni concrete dell'utente e delle responsabilit√† del sistema", "correct": false, "explanation": "I casi d'uso sono scritti a livello di INTENZIONI dell'utente, non di azioni concrete. Le azioni concrete appartengono a un livello di dettaglio troppo basso." },
      { "id": 20, "text": "Un caso d'uso √® sempre completato (implementato) in una solo iterazione", "correct": false, "explanation": "Un caso d'uso pu√≤ essere implementato in pi√π iterazioni. Spesso si implementano prima gli scenari base e successivamente quelli alternativi." },
      { "id": 21, "text": "Un caso d'uso rappresenta l'insieme di funzionalit√† di un sistema", "correct": false, "explanation": "Un caso d'uso rappresenta UN MODO SPECIFICO di utilizzare il sistema per raggiungere un obiettivo, non l'insieme di tutte le funzionalit√†." },
      { "id": 22, "text": "I requisiti funzionali non catturati dai casi d'uso vengono descritti nelle specifiche supplementari", "correct": true, "explanation": "Corretto. Le specifiche supplementari documentano i requisiti funzionali che non sono catturati dai casi d'uso (es. report, formati di file, ecc.)." },
      { "id": 23, "text": "L'analisi linguistica dei casi d'uso nel formato dettagliato √® una fonte di ispirazione per la costruzione del modello di dominio", "correct": true, "explanation": "Corretto. L'analisi dei sostantivi e dei concetti nei casi d'uso dettagliati aiuta a identificare le classi concettuali per il modello di dominio." },
      { "id": 24, "text": "Il modello di dominio riporta i concetti significativi relativi ai casi d'uso", "correct": true, "explanation": "Corretto. Il modello di dominio include i concetti del dominio che sono rilevanti per i casi d'uso del sistema." },
      { "id": 25, "text": "I requisiti non funzionali sono descritti completamente dai casi d'uso", "correct": false, "explanation": "I casi d'uso catturano principalmente requisiti FUNZIONALI. I requisiti non-funzionali (performance, sicurezza, usabilit√†) sono documentati nelle specifiche supplementari." },
      { "id": 26, "text": "I contratti sono considerati parte del modello dei casi d'uso poich√© forniscono maggiori dettagli dell'analisi, sull'effetto delle operazioni di sistema implicate dai casi d'uso", "correct": true, "explanation": "Corretto. I contratti delle operazioni di sistema forniscono dettagli aggiuntivi sugli effetti delle operazioni identificate nei casi d'uso." },
      { "id": 27, "text": "I CASI D'USO Sono una collezione di soli scenari di successo che descrivono un attore che usa il sistema per raggiungere un obiettivo specifico", "correct": false, "explanation": "I casi d'uso includono sia scenari di SUCCESSO che scenari ALTERNATIVI (inclusi quelli di fallimento). Non sono limitati ai soli scenari di successo." },
      { "id": 28, "text": "I casi d'uso sono descrizioni testuali di scenari di uso interessanti del sistema software che si deve realizzare", "correct": true, "explanation": "Corretto. I casi d'uso sono descrizioni testuali che documentano scenari di utilizzo significativi del sistema da sviluppare." },
      { "id": 29, "text": "I casi d'uso servono a catturare i requisiti funzionali", "correct": true, "explanation": "Corretto. Il principale scopo dei casi d'uso √® catturare e documentare i requisiti funzionali del sistema." },
      { "id": 30, "text": "In UP i casi d'uso vengono utilizzati per catturare i requisiti funzionali nella disciplina dei requisiti", "correct": true, "explanation": "Corretto. Nel Unified Process, i casi d'uso sono lo strumento principale per catturare i requisiti funzionali durante la disciplina dei requisiti." },
      { "id": 31, "text": "I casi d'uso sono caratteristiche del sistema", "correct": false, "explanation": "I casi d'uso NON sono caratteristiche del sistema, ma descrivono COME il sistema viene utilizzato dagli attori per raggiungere obiettivi specifici." },
      { "id": 32, "text": "I casi d'uso sono utilizzati per pianificare le iterazioni", "correct": true, "explanation": "Corretto. I casi d'uso sono utilizzati per organizzare e pianificare le iterazioni di sviluppo, implementando i casi d'uso pi√π critici nelle prime iterazioni." },
      { "id": 33, "text": "In UP i casi d'uso sono descritti mediante il linguaggio UML", "correct": false, "explanation": "I casi d'uso in UP sono descritti principalmente in linguaggio NATURALE (testo), non in UML. UML fornisce solo i diagrammi dei casi d'uso per mostrare le relazioni." },
      { "id": 34, "text": "DURANTE LA FASE DI ELABORAZIONE Si scrivono circa il 10% dei casi d'uso tra i pi√π critici in formato dettagliato utilizzando template appositi", "correct": false, "explanation": "Durante l'ideazione si scrive in dettaglio circa il 10% dei casi d'uso pi√π critici e rischiosi per guidare l'architettura. La fase di Elaborazione √® invece il momento in cui la maggior parte dei requisiti viene chiarita e stabilizzata, portando ad una percentuale molto pi√π alta (40-80%) di casi d'uso dettagliati entro la fine di questa fase. Vengono implementati il 100% dei requisiti funzionali del progetto (preso dai quiz)." },
      { "id": 35, "text": "In percentuale sul totale di casi d'uso complessivi di un progetto, sono pari al 5% quelli che dovrebbero essere realizzati entro la conclusione della fase di ideazione?", "correct": true, "explanation": "Corretto. Durante la fase di ideazione si implementa circa il 5% dei casi d'uso tra tutti quelli identificati." },
      { "id": 36, "text": "I casi d'uso mettono in risalto gli obiettivi degli utenti", "correct": true, "explanation": "Corretto. I casi d'uso sono organizzati attorno agli obiettivi che gli utenti (attori) vogliono raggiungere utilizzando il sistema." },
      { "id": 37, "text": "I casi d'uso sono utilizzati per la scoperta e la definizione dei requisiti non funzionali", "correct": false, "explanation": "I casi d'uso sono utilizzati principalmente per i requisiti FUNZIONALI. I requisiti non-funzionali sono documentati nelle specifiche supplementari." },
      { "id": 38, "text": "I casi d'uso sono utilizzati per la scoperta e la definizione dei requisiti funzionali", "correct": true, "explanation": "Corretto. I casi d'uso sono lo strumento principale per scoprire, definire e documentare i requisiti funzionali del sistema." },
      { "id": 39, "text": "I casi d'uso mettono in risalto gli obiettivi del sistema", "correct": false, "explanation": "I casi d'uso mettono in risalto gli obiettivi degli UTENTI (attori), non del sistema. Il sistema risponde agli obiettivi degli utenti." },
      { "id": 40, "text": "I casi d'uso sono utilizzati solo nelle prime iterazioni di sviluppo", "correct": false, "explanation": "I casi d'uso sono utilizzati durante TUTTO il processo di sviluppo, non solo nelle prime iterazioni. Guidano implementazione, test e validazione." },
      { "id": 41, "text": "Il principale input per la redazione dei contratti sono le operazioni di sistema e il modello di dominio", "correct": true, "explanation": "Corretto. I contratti sono scritti per le operazioni di sistema identificate negli SSD, utilizzando il modello di dominio per descrivere gli effetti." },
      { "id": 42, "text": "Le post-condizioni descrivono i cambiamenti di stato degli oggetti nel modello di dominio dopo il completamento dell'operazione", "correct": true, "explanation": "Corretto. Le post-condizioni nei contratti descrivono come cambiano gli stati degli oggetti del modello di dominio dopo l'esecuzione dell'operazione." },
      { "id": 43, "text": "I contratti servono come input per il modello di dominio", "correct": false, "explanation": "I contratti NON servono come input per il modello di dominio. √à il contrario: il modello di dominio serve come input per scrivere i contratti." },
      { "id": 44, "text": "La responsabilit√† sono assegnate ai concetti definiti nel modello di dominio", "correct": false, "explanation": "Le responsabilit√† sono assegnate alle CLASSI SOFTWARE durante la progettazione, non ai concetti del modello di dominio che rappresenta solo l'analisi." },
      { "id": 45, "text": "I contratti delle operazioni di sistema usano pre e post- condizioni per descrivere nel dettaglio i cambiamenti agli oggetti (concettuali) in un modello di dominio", "correct": true, "explanation": "Corretto. I contratti utilizzano pre-condizioni e post-condizioni per descrivere dettagliatamente come le operazioni di sistema modificano gli oggetti concettuali." },
      { "id": 46, "text": "Le pre-condizioni descrivono i cambiamenti di stato degli oggetti nel modello di dominio dopo il completamento dell'operazione", "correct": false, "explanation": "Le pre-condizioni descrivono lo stato che deve esistere PRIMA dell'operazione. Sono le POST-condizioni che descrivono i cambiamenti dopo l'operazione." },
      { "id": 47, "text": "La composizione di oggetti √® definita staticamente attraverso la specifica delle classi e delle associazioni", "correct": true, "explanation": "Corretto. La composizione viene definita staticamente nel codice attraverso la definizione delle classi e delle loro relazioni di composizione." },
      { "id": 48, "text": "Il meccanismo di specializzazione per il riuso del codice √® detto white-box", "correct": true, "explanation": "Corretto. L'ereditariet√† (specializzazione) √® chiamata riuso 'white-box' perch√© la sottoclasse ha visibilit√† sui dettagli interni della superclasse." },
      { "id": 49, "text": "La modifica dell'interfaccia di una classe ha in generale un basso impatto nelle sottoclassi", "correct": false, "explanation": "La modifica dell'interfaccia di una classe ha generalmente un ALTO impatto sulle sottoclassi, che dipendono dall'interfaccia della superclasse." },
      { "id": 50, "text": "I pattern GRASP sono espressi in termini di responsabilit√†, ruoli e collaborazioni", "correct": true, "explanation": "Corretto. I pattern GRASP (General Responsibility Assignment Software Patterns) si concentrano sull'assegnazione di responsabilit√†, ruoli e collaborazioni tra oggetti." },
      { "id": 51, "text": "La decisione sull'assegnazione delle responsabilit√† precede sempre la codifica", "correct": false, "explanation": "L'assegnazione delle responsabilit√† √® parte della progettazione (OOD) che precede logicamente la fase di implementazione/codifica, ma le decisioni sull‚Äôassegnazione delle responsabilit√† agli oggetti possono anche essere prese mentre si esegue la codifica oppure durante la modellazione." },
      { "id": 52, "text": "L'utilizzo dei pattern GRASP √® svolto all'interno della disciplina dei requisiti di UP", "correct": false, "explanation": "I pattern GRASP sono utilizzati nella disciplina di PROGETTAZIONE (Design), non nella disciplina dei requisiti. Riguardano l'assegnazione di responsabilit√† alle classi software." },
      { "id": 53, "text": "Le responsabilit√† sono assegnate alle classi durante la OOD", "correct": true, "explanation": "Corretto. L'Object-Oriented Design (OOD) √® la fase in cui si assegnano le responsabilit√† alle classi software utilizzando principi come i pattern GRASP." },
      { "id": 54, "text": "Il meccanismo di delega √® preferibile al meccanismo di specializzazione per il riuso del codice", "correct": true, "explanation": "Corretto. La composizione/delega (riuso black-box) √® generalmente preferibile all'ereditariet√† perch√© √® pi√π flessibile e mantiene un minor accoppiamento." },
      { "id": 55, "text": "L'ereditariet√† rispetta l'incapsulamento", "correct": false, "explanation": "L'ereditariet√† NON rispetta completamente l'incapsulamento perch√© la sottoclasse ha accesso ai membri protetti della superclasse, rompendo l'incapsulamento." },
      { "id": 56, "text": "La composizione di oggetti √® un meccanismo di riuso del codice detto black-box", "correct": true, "explanation": "Corretto. La composizione √® chiamata riuso 'black-box' perch√© gli oggetti componenti sono utilizzati solo attraverso le loro interfacce pubbliche." },
      { "id": 57, "text": "Un metodo di una classe software rappresenta una responsabilit√† 'a fare' per le istanze di tale classe", "correct": true, "explanation": "Corretto. I metodi rappresentano le responsabilit√† 'doing' (a fare) di una classe, cio√® quello che gli oggetti di quella classe sanno fare." },
      { "id": 58, "text": "DURANTE LA FASE DI ELABORAZIONE Non vengono effettuati test al codice di sviluppo", "correct": false, "explanation": "Durante la fase di elaborazione SI effettuano test al codice. √à una fase in cui si programma il nucleo architetturale e lo si testa." },
      { "id": 59, "text": "DURANTE LA FASE DI ELABORAZIONE Non si sviluppa codice", "correct": false, "explanation": "Durante la fase di elaborazione SI sviluppa codice. Si programma il nucleo architetturale del sistema per validare l'architettura proposta." },
      { "id": 60, "text": "DURANTE LA FASE DI ELABORAZIONE Viene scoperta e stabilizzata la maggior parte dei requisiti", "correct": true, "explanation": "Corretto. L'elaborazione √® la fase in cui si scoprono e stabilizzano la maggior parte dei requisiti, completando l'analisi iniziata nell'ideazione." },
      { "id": 61, "text": "DURANTE LA FASE DI ELABORAZIONE Si realizza uno studio economico per stabilire l'ordine di grandezza del progetto e dei costi", "correct": false, "explanation": "Lo studio economico preliminare viene fatto durante la fase di IDEAZIONE, non di elaborazione. L'elaborazione raffina le stime." },
      { "id": 62, "text": "DURANTE LA FASE DI ELABORAZIONE Viene programmato il nucleo, rischioso, dell'architettura", "correct": true, "explanation": "Corretto. Durante l'elaborazione si programma e testa il nucleo architetturale del sistema, concentrandosi sulle parti pi√π rischiose." },
      { "id": 63, "text": "In UML per responsabilit√† si intende la specifica di un metodo associato ad una classe Java", "correct": false, "explanation": "In UML, responsabilit√† √® un concetto pi√π generale che include sia 'knowing' che 'doing'. Non √® limitato ai soli metodi Java." },
      { "id": 64, "text": "In UML per responsabilit√† si intende la specifica di una variabile di istanza di una classe Java", "correct": false, "explanation": "Le variabili di istanza sono parte delle responsabilit√† 'knowing', ma la responsabilit√† in UML √® un concetto pi√π ampio che include anche le azioni." },
      { "id": 65, "text": "In UML per responsabilit√† si intende un contratto o un obbligo di un classificatore", "correct": true, "explanation": "Corretto. In UML, una responsabilit√† √® definita come un contratto o obbligo di un classificatore (classe), che include sia knowing che doing." },
      { "id": 66, "text": "In UML per responsabilit√† si intende la specifica di una variabile di istanza o di un metodo associato ad una classe Java", "correct": false, "explanation": "La responsabilit√† in UML √® un concetto pi√π astratto di contratto/obbligo, non semplicemente l'implementazione in variabili o metodi Java." },
      { "id": 67, "text": "Gli SSD Sono espressi attraverso i diagrammi di comunicazione di UML", "correct": false, "explanation": "Gli SSD (System Sequence Diagrams) sono espressi attraverso i diagrammi di SEQUENZA di UML, non i diagrammi di comunicazione." },
      { "id": 68, "text": "Gli SSD Mostrano l'ordine degli eventi generati dagli attori esterni al sistema", "correct": true, "explanation": "Corretto. Gli SSD mostrano la sequenza temporale degli eventi di sistema generati dagli attori esterni per uno specifico scenario di caso d'uso." },
      { "id": 69, "text": "I contratti costituiscono un input per gli SSD delle operazioni e per la progettazione degli oggetti", "correct": false, "explanation": "√à il contrario: gli SSD sono input per i contratti. Gli SSD identificano le operazioni di sistema, per le quali poi si scrivono i contratti." },
      { "id": 70, "text": "Un evento di sistema √® un evento interno al sistema", "correct": false, "explanation": "Un evento di sistema √® un evento che arriva al sistema dall'ESTERNO, generato da un attore esterno. Gli eventi interni non sono eventi di sistema." },
      { "id": 71, "text": "Gli SSD mostrano gli eventi generati dagli attori esterni al sistema", "correct": true, "explanation": "Corretto. Gli SSD (System Sequence Diagrams) mostrano gli eventi di sistema generati dagli attori esterni durante l'esecuzione di un caso d'uso." },
      { "id": 72, "text": "In percentuale sul totale dei requisiti funzionali di un progetto, quelli che dovrebbero essere identificati entro la conclusione della fase di IDEAZIONE sono pari al 50%? ", "correct": false, "explanation": "Alla fine dell'ideazione si dovrebbe aver identificato circa il 70% dei requisiti funzionali, non il 50%. Il 50% √® troppo poco per completare l'ideazione." },
      { "id": 73, "text": "In percentuale sul totale dei requisiti funzionali di un progetto, quelli che dovrebbero essere identificati entro la conclusione della fase di ELABORAZIONE sono pari al 100%?", "correct": true, "explanation": "Corretto. Alla fine dell'elaborazione dovrebbero essere identificati praticamente tutti i requisiti funzionali, per poter pianificare accuratamente la costruzione." },
      { "id": 74, "text": "Il riuso white-box √® preferibile al riuso black-box", "correct": false, "explanation": "Il riuso black-box (composizione) √® generalmente preferibile al riuso white-box (ereditariet√†) perch√© offre maggiore flessibilit√† e minor accoppiamento." },
      { "id": 75, "text": "Il meccanismo di ereditariet√† non √® preferibile al meccanismo di delega per ottenere il riuso del software", "correct": true, "explanation": "Corretto. La delega (composizione) √® spesso preferibile all'ereditariet√† per il riuso perch√© √® pi√π flessibile e mantiene un accoppiamento pi√π basso." },
      { "id": 76, "text": "L'ereditariet√† si avvale del meccanismo di delega", "correct": false, "explanation": "L'ereditariet√† e la delega sono meccanismi ALTERNATIVI per il riuso del codice. L'ereditariet√† non si avvale della delega." },
      { "id": 77, "text": "Il meccanismo di composizione non rispetta l'incapsulamento", "correct": false, "explanation": "Il meccanismo di composizione RISPETTA l'incapsulamento perch√© accede agli oggetti componenti solo attraverso le loro interfacce pubbliche." },
      { "id": 78, "text": "Le operazioni di sistema possono essere identificate mentre si abbozzano gli SSD", "correct": true, "explanation": "Corretto. Le operazioni di sistema vengono identificate durante la creazione degli SSD, che mostrano gli eventi che il sistema deve gestire." },
      { "id": 79, "text": "I contratti descrivono in modo dettagliato i cambiamenti richiesti dall'esecuzione di una operazione di sistema, descrivono come devono essere ottenuti questi risultati", "correct": false, "explanation": "I contratti descrivono COSA deve succedere (post-condizioni), ma NON descrivono COME ottenere questi risultati. Il 'come' √® parte della progettazione." },
      { "id": 80, "text": "I pattern GoF incentivano l'uso dell'ereditariet√† come meccanismo di riuso del codice, in particolare attraverso il pattern composite", "correct": false, "explanation": "I pattern GoF generalmente SCORAGGIANO l'uso eccessivo dell'ereditariet√† per il riuso preferendo la composizione. Il pattern Composite usa l'ereditariet√† per il polimorfismo, non per il riuso." },
      { "id": 81, "text": "I pattern GoF prediligono l'utilizzo del meccanismo di ereditariet√† per ottenere la specializzazione", "correct": false, "explanation": "I pattern GoF enfatizzano il principio 'favor composition over inheritance' - preferire la composizione all'ereditariet√† anche per la specializzazione." },
      { "id": 82, "text": "I pattern GoF incentivano i meccanismi di riuso del software attraverso la definizione di gerarchie di classi", "correct": false, "explanation": "I pattern GoF promuovono il riuso attraverso la COMPOSIZIONE e la delega, non attraverso gerarchie di classi estese." },
      { "id": 83, "text": "I pattern GoF prediligono l'utilizzo del meccanismo di ereditariet√† per ottenere il polimorfismo", "correct": true, "explanation": "Corretto. I pattern GoF utilizzano l'ereditariet√† principalmente per ottenere il POLIMORFISMO (comportamenti diversi con interfaccia comune), non per il riuso del codice." },
      { "id": 84, "text": "I pattern GoF Composite fornisce caratteristiche addizionali ad elementi atomici (foglie), mantenendo una interfaccia comune", "correct": false, "explanation": "Il pattern Composite NON fornisce caratteristiche addizionali alle foglie. Permette di trattare oggetti semplici e composti uniformemente." },
      { "id": 85, "text": "Il pattern GoF Composite permette di costruire tassonomie di classi", "correct": false, "explanation": "Il pattern Composite permette di costruire strutture ad ALBERO di oggetti, non tassonomie di classi. Le tassonomie sono gerarchie di ereditariet√†." },
      { "id": 86, "text": "Il pattern GoF Composite utilizza il meccanismo di specializzazione per rendere l'interfaccia delle entit√† atomiche esattamente come l'interfaccia delle entit√† composte", "correct": false, "explanation": "Il Composite usa la generalizzazione per far s√¨ che foglie e nodi composti implementino la stessa interfaccia, permettendo un trattamento uniforme." },
      { "id": 87, "text": "Il pattern GoF Composite permette di evitare l'esplosione delle sottoclassi per supportare un ampio numero di estensioni e combinazioni di esse", "correct": false, "explanation": "Questo √® il pattern DECORATOR, non Composite. Il Composite organizza oggetti in strutture ad albero, non evita l'esplosione di sottoclassi." },
      { "id": 88, "text": "Il pattern GoF Composite permette di costruire strutture ricorsive in modo che ad un cliente l'intera struttura sia vista come una singola entit√†", "correct": true, "explanation": "Corretto. Il pattern Composite permette di costruire strutture ad albero dove i client possono trattare oggetti semplici e composti uniformemente." },
      { "id": 89, "text": "L'extreme programming promuove lo sviluppo seguito dai test", "correct": false, "explanation": "XP promuove il TDD (Test-Driven Development): prima si scrivono i test, POI si scrive il codice per farli passare. I test precedono lo sviluppo." },
      { "id": 90, "text": "I test unitari hanno lo scopo di verificare la comunicazione tra specifiche parti del sistema", "correct": false, "explanation": "I test unitari verificano il comportamento di singole UNIT√Ä (metodi, classi) in isolamento. I test di integrazione verificano la comunicazione tra parti." },
      { "id": 91, "text": "Preparazione, esecuzione, verifica e rilascio sono le parti del test unitario", "correct": true, "explanation": "Corretto. Le fasi tipiche di un test unitario sono: Setup (preparazione), Exercise (esecuzione), Verify (verifica) e Release (rilascio)." },
      { "id": 92, "text": "Il refactoring prevede di applicare piccole trasformazioni che preservano il comportamento", "correct": true, "explanation": "Corretto. Il refactoring consiste nell'applicare piccole trasformazioni al codice che migliorano la struttura senza modificare il comportamento esterno." },
      { "id": 93, "text": "I test unitari sono utilizzati per dimostrare che il refactoring non abbia causato una regressione", "correct": true, "explanation": "Corretto. I test unitari servono come rete di sicurezza durante il refactoring, assicurando che il comportamento rimanga invariato." },
      { "id": 94, "text": "La progettazione object-oriented in UP ha il fine di identificare le responsabilit√† e assegnarle ad un opportuno oggetto o classe", "correct": true, "explanation": "Corretto. L'OOD in UP si concentra sull'identificazione delle responsabilit√† software e sulla loro assegnazione alle classi appropriate." },
      { "id": 95, "text": "La coesione √® la misura di quanto fortemente un elemento √® connesso ad altri elementi, ha conoscenza di altri elementi e dipende da altri elementi", "correct": false, "explanation": "Questa √® la definizione di ACCOPPIAMENTO. La coesione misura quanto le responsabilit√† di un singolo elemento sono correlate tra loro." },
      { "id": 96, "text": "Il pattern GRASP Information Expert e High Cohesion sono pattern valutativi", "correct": false, "explanation": "Low Coupling e High Cohesion sono pattern GRASP valutativi che forniscono criteri per valutare la qualit√† delle soluzioni di design." },
      { "id": 97, "text": "La creazione di un oggetto √® di responsabilit√† di un oggetto che aggrega, contiene un'istanza dell'oggetto da creare", "correct": true, "explanation": "Corretto. Secondo il pattern GRASP Creator, la responsabilit√† di creare un oggetto spetta spesso a chi lo aggrega, contiene o usa intensivamente." },
      { "id": 98, "text": "Una classe con accoppiamento alto fa molte cose non correlate tra loro e svolge troppo lavoro", "correct": false, "explanation": "Questa √® la definizione di bassa COESIONE. L'alto accoppiamento indica molte dipendenze verso altre classi, non necessariamente molte responsabilit√†." },
      { "id": 99, "text": "Il refactoring √® una pratica promossa dal metodo iterativo e agile xp", "correct": true, "explanation": "Corretto. Il refactoring √® una delle pratiche fondamentali di XP (Extreme Programming) e dei metodi agili in generale." },
      { "id": 100, "text": "Il refactoring prevede lo sviluppo guidato dai test, ovvero uno sviluppo preceduto dai test", "correct": false, "explanation": "Il refactoring e il TDD sono pratiche SEPARATE. Il refactoring migliora il codice esistente, il TDD √® una tecnica di sviluppo guidata dai test." },
      { "id": 101, "text": "Il refactoring √® un metodo strutturato e disciplinato per scrivere o ristrutturare del codice esistente", "correct": true, "explanation": "Corretto. Il refactoring √® un processo disciplinato per ristrutturare codice esistente migliorandone la struttura senza cambiarne il comportamento." },
      { "id": 102, "text": "DURANTE LA FASE DI ELABORAZIONE: I requisiti e le iterazioni sono organizzati in base alla richiesta dell'utente finale", "correct": false, "explanation": "Durante l'elaborazione i requisiti sono organizzati in base a RISCHIO e CRITICIT√Ä ARCHITETTURALE, non alle richieste dell'utente finale." },
      { "id": 103, "text": "DURANTE LA FASE DI ELABORAZIONE: I requisiti e le iterazioni sono organizzati in base al rischio, copertura (devono coprire tutto il sistema) e criticit√†", "correct": true, "explanation": "Corretto. L'elaborazione organizza le iterazioni in base a rischio, criticit√† architetturale e necessit√† di coprire tutti gli aspetti del sistema." },
      { "id": 104, "text": "DURANTE LA FASE DI ELABORAZIONE: Si effettua attivit√† di programmazione di qualit√†-produzione e test", "correct": true, "explanation": "Corretto. Durante l'elaborazione si sviluppa codice di qualit√† produzione per il nucleo architetturale e si effettuano test appropriati." },
      { "id": 105, "text": "DURANTE LA FASE DI ELABORAZIONE: Vengono realizzati prototipi 'usa e getta' per ottenere i rischi maggiori", "correct": false, "explanation": "Durante l'elaborazione si sviluppa il nucleo architetturale EVOLUTIVO, non prototipi 'usa e getta'. I prototipi usa e getta sono tipici dell'ideazione." },
      { "id": 106, "text": "La responsabilit√† √® un'astrazione di ci√≤ che fa o rappresenta un oggetto o un componente software", "correct": true, "explanation": "Corretto. La responsabilit√† √® un'astrazione di ci√≤ che un oggetto SA (knowing) o FA (doing)." },
      { "id": 107, "text": "Nel Responsibility-Driven Development gli oggetti software sono considerati come dotati di responsabilit√†", "correct": true, "explanation": "Corretto. Il RDD (Responsibility-Driven Development) vede gli oggetti come entit√† che hanno responsabilit√† specifiche nel sistema." },
      { "id": 108, "text": "La disciplina dei requisiti √® il processo per scoprire cosa deve essere costruito", "correct": true, "explanation": "Corretto. La disciplina dei requisiti in UP ha l'obiettivo di scoprire, documentare e validare cosa il sistema deve fare." },
      { "id": 109, "text": "La disciplina dei requisiti deve orientare lo sviluppo verso il sistema corretto", "correct": true, "explanation": "Corretto. La disciplina dei requisiti assicura che si sviluppi il sistema GIUSTO (quello che soddisfa realmente i bisogni degli utenti)." },
      { "id": 110, "text": "I contratti usano pre-condizioni e post-condizioni per descrivere nel dettaglio i cambiamenti agli oggetti in un modello di progetto (software)", "correct": false, "explanation": "I contratti descrivono cambiamenti agli oggetti del MODELLO DI DOMINIO (concettuali), non del modello di progetto (software)." },
      { "id": 111, "text": "Le operazioni di sistema possono essere identificate mentre si abbozzano gli DSD", "correct": false, "explanation": "Le operazioni di sistema vengono identificate prima, durante l'abbozzo degli SSD, e non dei DSD. I DSD mostrano come tali operazioni vengono realizzate internamente." },
      { "id": 112, "text": "Nella fase di Analisi dei Requisiti, la prima attivit√† consiste nel tradurre le informazioni raccolte in un documento che definisce un insieme di requisiti.", "correct": false, "explanation": "La prima fase principale dell'Analisi dei Requisiti √® la Deduzione e analisi dei requisiti; la Specifica dei requisiti, che consiste nel tradurre le informazioni in un documento, viene successivamente." },
      { "id": 113, "text": "Nelle metodologie agili, la progettazione e l'implementazione del software sono solitamente separate e producono documenti formali dettagliati prima della codifica.", "correct": false, "explanation": "Nelle metodologie agili, la progettazione e l'implementazione sono intrecciate e non producono documenti formali; il progetto √® spesso registrato informalmente." },
      { "id": 114, "text": "L'Unified Process (UP) √® una metodologia di sviluppo software che segue un approccio strettamente sequenziale e a cascata.", "correct": false, "explanation": "UP incoraggia uno sviluppo iterativo e guidato dal rischio. La programmazione e il test iniziano prima che l'analisi di tutti i requisiti sia completata." },
      { "id": 115, "text": "Lo scopo principale della fase di Ideazione in UP √® quello di definire tutti i requisiti dettagliati del progetto e generare una stima affidabile dei costi.", "correct": false, "explanation": "Lo scopo della fase di ideazione non √® quello di definire tutti i requisiti, n√© di generare una stima o un piano di progetto affidabili. Si tratta piuttosto di decidere se il progetto merita un'indagine pi√π seria." },
      { "id": 116, "text": "Il documento Visione in UP riassume i requisiti di alto livello ed √® utile per stabilire una visione comune del progetto tra i partecipanti.", "correct": true, "explanation": "Il documento Visione riassume alcune informazioni contenute nel modello dei casi d'uso e nelle specifiche supplementari, descrivendo brevemente il progetto come contesto per i partecipanti e stabilendo una visione comune." },
      { "id": 117, "text": "In UP, il Glossario ha anche la funzione di dizionario dei dati, includendo informazioni relative ad altri dati (metadati), come le regole di validazione.", "correct": true, "explanation": "In UP, il Glossario svolge anche il ruolo di un dizionario di dati, un documento dati relativi ad altri dati, ovvero metadati, inclusi esempi di regole di validazione." },
      { "id": 118, "text": "La Disciplina dei Requisiti in UP si concentra principalmente sul 'come' il sistema deve essere costruito, definendo le soluzioni tecniche e architetturali.", "correct": false, "explanation": "La Disciplina dei Requisiti √® il processo per scoprire 'cosa' deve essere costruito e orientare lo sviluppo verso il sistema corretto, definendo le capacit√† e condizioni a cui il sistema deve essere conforme." },
      { "id": 119, "text": "Secondo le fonti, i casi d'uso in UP sono principalmente rappresentati da diagrammi UML per visualizzare le interazioni tra attori e sistema.", "correct": false, "explanation": "I casi d'uso in UP sono descrizioni testuali di scenari di uso interessanti del sistema software. Le fonti specificano chiaramente che i casi d'uso sono documenti testuali, non diagrammi." },
      { "id": 120, "text": "Un Attore Primario in un caso d'uso √® colui che offre un servizio al sistema.", "correct": false, "explanation": "L'Attore Primario √® colui che raggiunge gli obiettivi utente utilizzando i servizi del sistema. L'attore di supporto √® colui che offre un servizio al sistema." },
      { "id": 121, "text": "Nel formato dettagliato di un caso d'uso, la sezione 'Estensioni' √® utilizzata per descrivere scenari alternativi, sia di successo che di fallimento, rispetto allo scenario principale.", "correct": true, "explanation": "Le Estensioni descrivono scenari alternativi, di successo o di fallimento, e la loro gestione." },
      { "id": 122, "text": "Quando si scrive un caso d'uso in stile essenziale, √® fondamentale includere dettagli precisi sull'interfaccia utente (GUI) con cui l'attore interagisce.", "correct": false, "explanation": "Lo stile essenziale implica ignorare l'interfaccia utente e concentrarsi sull'obiettivo utente e le responsabilit√† del sistema a un livello astratto, indipendente dai dettagli tecnologici e di UI." },
      { "id": 123, "text": "L'approccio Black-box nella scrittura dei casi d'uso significa descrivere esattamente 'come' il sistema esegue una determinata azione, inclusi dettagli implementativi come l'uso di database o istruzioni SQL.", "correct": false, "explanation": "L'approccio Black-box significa descrivere 'che cosa' il sistema deve fare (comportamento o requisiti funzionali) senza decidere come." },
      { "id": 124, "text": "Per verificare l'utilit√† di un caso d'uso, il Test del capo chiede se l'attivit√† descritta rappresenta un'azione significativa per l'utente che giustifichi lo sforzo di implementazione.", "correct": true, "explanation": "Il Test del capo implica chiedersi se un capo sarebbe contento se il lavoro di un giorno fosse solo l'attivit√† descritta nel caso d'uso; se la risposta √® no, il caso d'uso non √® utile." },
      { "id": 125, "text": "Il Modello di Dominio rappresenta i concetti chiave del sistema come oggetti software con nomi e informazioni simili al dominio del mondo reale.", "correct": false, "explanation": "Il Modello di Dominio √® uno strumento di analisi che rappresenta i concetti del mondo reale (classi concettuali) in modo indipendente dall'implementazione software, mentre gli oggetti software con nomi simili al dominio vengono creati in una fase successiva (progettazione e implementazione) e rappresentati, ad esempio, nel Modello di Progetto (tramite DCD), ispirandosi al Modello di Dominio." },
      { "id": 126, "text": "I Diagrammi di Sequenza di Sistema (SSD) mostrano le interazioni tra gli oggetti interni del sistema per realizzare un'operazione.", "correct": false, "explanation": "Il Diagramma di Sequenza di Sistema serve a rappresentare gli eventi di input e output che coinvolgono il sistema durante un'interazione con gli attori esterni, vedendo il sistema come una scatola nera." },
      { "id": 127, "text": "I Contratti delle operazioni di sistema descrivono in dettaglio 'come' vengono realizzati i cambiamenti nello stato del sistema dopo l'esecuzione di un'operazione.", "correct": false, "explanation": "Un contratto descrive in modo molto dettagliato i cambiamenti richiesti dall'esecuzione di una operazione di sistema senza per√≤ descrivere come devono essere ottenuti." },
      { "id": 128, "text": "Un'operazione di sistema di Interrogazione modifica lo stato del sistema e per questo motivo deve avere delle post-condizioni nel suo contratto.", "correct": false, "explanation": "Un'operazione di sistema di Interrogazione non modifica lo stato del sistema, si limita a calcolare e restituire un valore, e per questo non ha post-condizioni. Le post-condizioni descrivono i cambiamenti nello stato degli oggetti." },
      { "id": 129, "text": "La progettazione orientata agli oggetti (OOD) pone l'enfasi sulla definizione degli oggetti software e sul modo in cui questi collaborano per soddisfare i requisiti.", "correct": true, "explanation": "La progettazione orientata agli oggetti pone l'enfasi sulla definizione di oggetti software e del modo in cui questi collaborano per soddisfare i requisiti." },
      { "id": 130, "text": "I pattern GRASP sono un repertorio di soluzioni progettuali specifiche per problemi ricorrenti nell'implementazione di software, simili ai pattern GoF.", "correct": false, "explanation": "I pattern GRASP sono principi per l'assegnazione di responsabilit√†. I pattern GoF sono descrizioni con nome di problemi di progettazione ricorrenti e di una soluzione." },
      { "id": 131, "text": "Secondo il pattern GRASP Information Expert, una responsabilit√† dovrebbe essere assegnata alla classe che possiede le informazioni necessarie per soddisfarla.", "correct": true, "explanation": "Il pattern Information Expert suggerisce di assegnare una responsabilit√† alla classe che possiede le informazioni necessarie per soddisfarla, all'esperto delle informazioni." },
      { "id": 132, "text": "I test unitari sono un tipo di test progettato per verificare il sistema software completo, considerando le interazioni tra tutti i componenti principali.", "correct": false, "explanation": "I test unitari testano singole unit√† di codice. I test di integrazione testano la comunicazione tra specifiche parti, mentre i test end-to-end testano l'intero sistema." },
      { "id": 133, "text": "Nella metodologia eXtreme Programming, i test vengono scritti prima di scrivere il codice corrispondente (sviluppo guidato dai test).", "correct": true, "explanation": "In alcune metodologie agili come l'eXtreme Programming, si scrivono i test prima di scrivere il codice." },
      { "id": 134, "text": "Nel modello a cascata, si presume che i requisiti siano prevedibili e stabili fin dall'inizio con un basso tasso di cambiamenti.", "correct": true, "explanation": "Il modello a cascata parte dal presupposto che le specifiche sono prevedibili e stabili e possono essere definite correttamente sin dall'inizio, a fronte di un basso tasso di cambiamenti." },
      { "id": 135, "text": "Secondo le fonti, i metodi di sviluppo iterativi sono statisticamente associati a percentuali di successo pi√π basse rispetto al modello a cascata.", "correct": false, "explanation": "In base a dati statistici, i metodi iterativi sono associati a percentuali di successo e di produttivit√† pi√π elevate, nonch√© a livelli minori di difetti. Al contrario, l'approccio a cascata √® caratterizzato da una minore produttivit√† e da maggiori percentuali di difetti." },
      { "id": 136, "text": "Uno dei motivi principali per cui i requisiti cambiano √® l'impossibilit√† per i clienti di prevedere appieno come un sistema influenzer√† le pratiche operative prima che sia consegnato e utilizzato.", "correct": true, "explanation": "I requisiti cambiano perch√© per i clienti √® impossibile prevedere come un sistema influenzer√† le pratiche operative, come interagir√† con gli altri sistemi e quali operazioni degli utenti dovranno essere automatizzate; i requisiti reali diventano chiari solo dopo che il sistema √® stato consegnato e utilizzato." },
      { "id": 137, "text": "In Unified Process (UP), la Disciplina dei Requisiti √® un insieme di attivit√† che si svolgono esclusivamente all'inizio del progetto, prima di qualsiasi altra disciplina.", "correct": false, "explanation": "In UP, le discipline (tipologie di attivit√†) non sono sequenziali e si eseguono nel progetto in ogni iterazione. La Disciplina dei Requisiti √® il processo per scoprire \"cosa\" deve essere costruito e orientare lo sviluppo verso il sistema corretto." },
      { "id": 138, "text": "Secondo UP, √® necessario definire il 100% dei requisiti dettagliati prima di iniziare qualsiasi attivit√† di programmazione o test.", "correct": false, "explanation": "In UP si iniziano programmazione e test quando √® stato specificato solo il 10% o il 20% dei requisiti pi√π significativi. Inoltre, non si cerca di definire tutti i requisiti prima di iniziare la progettazione o l'implementazione." },
      { "id": 139, "text": "Il documento Specifiche Supplementari in UP √® destinato a contenere tutti i requisiti funzionali del sistema, inclusi quelli descritti nei casi d'uso.", "correct": false, "explanation": "Le Specifiche Supplementari contengono ci√≤ che non rientra nei casi d'uso, come requisiti non funzionali o funzionali non esprimibili attraverso casi d'uso. I requisiti funzionali principali sono descritti nel Modello dei Casi d'Uso." },
      { "id": 140, "text": "Durante la fase di Ideazione in UP, l'obiettivo √® analizzare in dettaglio la maggior parte dei casi d'uso per ottenere una comprensione completa dei requisiti funzionali.", "correct": false, "explanation": "Durante l'ideazione si analizzano circa il 10% dei casi d'uso in dettaglio. Lo scopo dell'Ideazione non √® raccogliere tutti i requisiti, ma capire se il progetto merita un'indagine pi√π seria (fattibilit√†)." },
      { "id": 141, "text": "Nel contesto di UP, l'Agile Modeling suggerisce che il valore della modellazione risiede principalmente nella creazione di documenti di specifiche affidabili e completi.", "correct": false, "explanation": "L'Agile Modeling suggerisce che il valore della modellazione √® quello di migliorare la comprensione, anzich√© quello di documentare delle specifiche affidabili." },
      { "id": 142, "text": "Un Attore di Supporto in un caso d'uso √® colui che utilizza il sistema per raggiungere i propri obiettivi utente.", "correct": false, "explanation": "L'Attore di Supporto √® colui che offre un servizio al sistema. L'Attore Primario √® colui che raggiunge gli obiettivi utente utilizzando i servizi del sistema." },
      { "id": 143, "text": "Quando si scrive un caso d'uso in stile essenziale, la descrizione si concentra sulle azioni concrete dell'utente e i dettagli specifici dell'interfaccia utente.", "correct": false, "explanation": "Lo stile essenziale implica che la narrativa √® espressa a livello di intenzioni e responsabilit√†, ignorando l'interfaccia utente e rimanendo indipendente dai dettagli tecnologici." },
      { "id": 144, "text": "Il \"Test EBP\" (Elementary Business Process) per verificare l'utilit√† di un caso d'uso chiede se l'attivit√† descritta dal caso d'uso aggiunge un valore di business misurabile.", "correct": true, "explanation": "Un processo di business elementare √® un'attivit√† che aggiunge un valore di business misurabile. Il Test EBP valuta se il caso d'uso rappresenta una interazione di valore." },
      { "id": 145, "text": "Un caso d'uso dettagliato, per superare il Test della Dimensione, dovrebbe idealmente essere descritto in una singola pagina.", "correct": false, "explanation": "Per superare il Test della Dimensione, un caso d'uso dettagliato normalmente comprende diversi passi e richiede da 3 a 10 pagine di testo. Una singola azione o passo raramente costituisce un caso d'uso utile." },
      { "id": 146, "text": "Il Modello di Dominio ha lo scopo di descrivere i concetti chiave del dominio del problema e le loro relazioni, servendo anche come ispirazione per le classi del software.", "correct": true, "explanation": "Il Modello di Dominio descrive i concetti significativi del sistema come oggetti del dominio e relaziona i concetti. Serve a comprendere il dominio e il suo vocabolario, definire un linguaggio comune, ed √® una fonte di ispirazione per l'OOD, riducendo il \"gap di rappresentazione\"." },
      { "id": 147, "text": "In un diagramma delle classi UML che rappresenta un Modello di Dominio, le associazioni dovrebbero indicare la direzione di navigabilit√† tra le classi software.", "correct": false, "explanation": "Le associazioni in un modello di dominio sono per natura bidirezionali. La direzione di lettura (indicata opzionalmente) non √® una specifica di visibilit√† o navigabilit√† tra entit√† software." },
      { "id": 148, "text": "I Diagrammi di Sequenza di Sistema (SSD) mostrano l'ordine e la logica delle interazioni tra gli oggetti interni del sistema software.", "correct": false, "explanation": "I Diagrammi di Sequenza di Sistema servono a rappresentare gli eventi di input e output che coinvolgono il sistema durante un'interazione con gli attori esterni, vedendo il sistema come una scatola nera. I diagrammi di sequenza (non di sistema) mostrano le interazioni tra gli oggetti interni." },
      { "id": 149, "text": "Le post-condizioni in un contratto descrivono le azioni che il sistema deve eseguire per soddisfare l'operazione, come istruzioni di database o chiamate a metodi specifici.", "correct": false, "explanation": "Un contratto descrive i cambiamenti richiesti dall'esecuzione di una operazione di sistema in termini di oggetti del Modello di Dominio, senza per√≤ descrivere come devono essere ottenuti. Le post-condizioni descrivono lo stato degli oggetti dopo l'operazione, non le azioni per arrivarci." },
      { "id": 150, "text": "Un'operazione di sistema di \"Trasformazione\" non modifica lo stato del sistema e per questo non richiede post-condizioni nel suo contratto.", "correct": false, "explanation": "Un'operazione di sistema di Trasformazione modifica lo stato del sistema e per questo motivo dovrebbe avere delle post-condizioni che descrivono tali modifiche. Le operazioni di Interrogazione non modificano lo stato e non hanno post-condizioni." },
      { "id": 151, "text": "La Progettazione Orientata agli Oggetti (OOD) si concentra principalmente sulla definizione di oggetti software e su come questi dovrebbero collaborare per soddisfare i requisiti.", "correct": true, "explanation": "La progettazione orientata agli oggetti pone l'enfasi sulla definizione di oggetti software e del modo in cui questi collaborano per soddisfare i requisiti." },
      { "id": 152, "text": "Secondo il principio GRASP \"Information Expert\", la responsabilit√† di salvare un oggetto nel database dovrebbe essere assegnata alla classe che rappresenta quell'oggetto (ad es. la classe Sale dovrebbe salvare se stessa).", "correct": false, "explanation": "In generale, l'Expert non si applica alla persistenza (salvataggio in DB) perch√© assegnare questa responsabilit√† alla classe stessa causerebbe problemi di bassa coesione (si occupa anche di persistenza), alto accoppiamento (legata a classi di sistema come i driver DB) e duplicazione logica. Questo principio architetturale di base suggerisce di separare diverse logiche in sottosistemi." },
      { "id": 153, "text": "Il pattern GoF Strategy consente di definire una famiglia di algoritmi e di renderli intercambiabili, permettendo ai clienti di utilizzare diversi algoritmi in modo indipendente.", "correct": true, "explanation": "Il pattern Strategy consente la definizione di una famiglia d'algoritmi, incapsula ognuno e gli fa intercambiabili fra di loro. Permette di modificare gli algoritmi in modo indipendente dai clienti e disaccoppia gli algoritmi dai clienti." },
      { "id": 154, "text": "Il pattern GoF Iterator espone la struttura interna di una collezione per permettere al chiamante di accedere e percorrere i suoi elementi.", "correct": false, "explanation": "Il pattern Iterator suggerisce l'implementazione di un oggetto che consenta l'accesso e percorso della collezione, fornendo una interfaccia standard che nasconde la struttura interna." },
      { "id": 155, "text": "Nel pattern GoF Visitor, il ConcreteVisitor √® l'oggetto che viene visitato dalla struttura dati.", "correct": false, "explanation": "Nel pattern Visitor, il ConcreteVisitor √® l'oggetto che percorre la collezione e applica un metodo specifico su ogni oggetto (Element) visitato. Gli oggetti della collezione (Element) sono quelli che vengono visitati." },
      { "id": 156, "text": "Il Modello-Vista (Model-View) Separation Principle suggerisce di separare gli oggetti che gestiscono la logica applicativa (Modello/Dominio) da quelli che gestiscono l'interfaccia utente (Vista/UI).", "correct": true, "explanation": "Il principio di separazione Modello-Vista stabilisce che il Modello (strato di dominio, oggetti con logica applicativa) e la Vista (strato UI, oggetti interfaccia utente) devono essere separati. Gli oggetti UI delegano le richieste di logica applicativa agli oggetti non UI (oggetti di dominio)." },
      { "id": 157, "text": "I test unitari hanno lo scopo di verificare il funzionamento complessivo del sistema software dal punto di vista dell'utente, considerando il sistema come una scatola nera.", "correct": false, "explanation": "I test unitari testano singole unit√† di codice, non il sistema nel suo complesso. I test di accettazione sono quelli che verificano il funzionamento complessivo del sistema a scatola nera dal punto di vista dell'utente, con riferimento ai casi d'uso." },
      { "id": 158, "text": "La fase di Verifica in un test unitario consiste nel preparare gli oggetti e le risorse necessarie per l'esecuzione del test.", "correct": false, "explanation": "La fase di Preparazione (Setup) crea l'oggetto o il gruppo di oggetti da verificare e prepara risorse. La fase di Verifica valuta se i risultati ottenuti corrispondono a quelli attesi." },
      { "id": 159, "text": "L‚Äôanalisi orientata agli oggetti √® guidata dalle responsabilit√†.", "correct": false, "explanation": "No, √® la progettazione orientata agli oggetti ad essere guidata dalle responsabilit√†." },
      { "id": 160, "text": "L‚Äôanalisi orientata agli oggetti considera un progetto software come una ‚Äúcomunit√† di oggetti‚Äù con responsabilit√† che collaborano.", "correct": false, "explanation": "No, √® la progettazione orientata agli oggetti che considera un progetto software come una ‚Äúcomunit√† di oggetti‚Äù con responsabilit√† che collaborano." },
      { "id": 161, "text": "Identificazione delle responsabilit√†, assegnazione di queste responsabilit√†, indagine di come soddisfare queste responsabilit√† sono i passi della ‚Äúresponsibility-driven development‚Äù.", "correct": true, "explanation": "Il Responsibility-Driven Development si basa esattamente su quei passaggi: identificare responsabilit√†, assegnarle agli oggetti e determinare come realizzarle." },
      { "id": 162, "text": "Controller, High Cohesion, Abstract Factory sono alcuni esempi di pattern GRASP.", "correct": false, "explanation": "Controller e High Cohesion fanno parte dei pattern GRASP, mentre Abstract Factory √® un pattern GoF, non GRASP." },
      { "id": 163, "text": "I pattern GRASP sono lo strumento principale utilizzato nella disciplina dei requisiti di UP.", "correct": false, "explanation": "I pattern GRASP vengono impiegati nella progettazione orientata agli oggetti, non come strumento principale per la raccolta dei requisiti in UP." },
      { "id": 164, "text": "UP organizza temporalmente il ciclo di sviluppo in quattro iterazioni e le iterazioni in diverse fasi.", "correct": false, "explanation": "In UP si parla di quattro fasi (ideazione, elaborazione, costruzione, transizione), ciascuna delle quali pu√≤ contenere pi√π iterazioni; non di quattro iterazioni complessive." },
      { "id": 165, "text": "Ideazione, elaborazione, costruzione e transizione di UP sono separate temporalmente e non si intrecciano mai.", "correct": true, "explanation": "Sono fasi distinte e non si intrecciano mai. " },
      { "id": 166, "text": "Specifica, sviluppo, convalida ed evoluzione in UP sono attivit√† separate temporalmente e non si intrecciano mai.", "correct": false, "explanation": "In UP le discipline (specifica, sviluppo, convalida, evoluzione, ecc.) avvengono in modo concorrente durante le iterazioni, non in sequenza isolata." },
      { "id": 167, "text": "Durante lo sviluppo tramite UP non si fa uso di meccanismi di refactoring per far fronte ai cambiamenti.", "correct": false, "explanation": "UP incoraggia il refactoring continuo all‚Äôinterno delle iterazioni per gestire i cambiamenti in modo iterativo." },
      { "id": 168, "text": "Modellazione del business, requisiti, progettazione, implementazione, test, rilascio in UP sono separate temporalmente e non si intrecciano mai.", "correct": false, "explanation": "Le discipline di UP (modellazione del business, requisiti, progettazione, implementazione, test, rilascio, ecc.) si svolgono in parallelo all‚Äôinterno di ciascuna iterazione, non in fasi separate." },
      { "id": 169, "text": "Il test-driven development √® una pratica promossa dal metodo a cascata che prevede lo sviluppo preceduto dai test.", "correct": false, "explanation": "Il TDD √® nato nell‚Äôambito dell‚ÄôExtreme Programming, non nel modello a cascata." },
      { "id": 170, "text": "I test unitari hanno lo scopo di verificare il collegamento complessivo tra tutti gli elementi del sistema.", "correct": false, "explanation": "Il test unitario controlla componenti isolate; verificare il collegamento complessivo √® compito dei test di integrazione o di sistema." },
      { "id": 171, "text": "I test unitari si compongono di preparazione, esecuzione, verifica e rilascio.", "correct": true, "explanation": "Un tipico ciclo di un test unitario include setup (preparazione), esecuzione, assertion (verifica) e teardown (rilascio)." },
      { "id": 172, "text": "Il test-driven development e il refactoring sono pratiche promosse in particolar modo dallo sviluppo noto come extreme programming.", "correct": true, "explanation": "TDD e refactoring sono due pratiche cardine dell‚ÄôExtreme Programming." },
      { "id": 173, "text": "Il pattern Strategy si occupa del modo in cui un oggetto esegue un determinato compito ed incapsula un algoritmo.", "correct": true, "explanation": "Strategy definisce una famiglia di algoritmi intercambiabili e la scelta del comportamento √® delegata a classi diverse che incapsulano ciascun algoritmo." },
      { "id": 174, "text": "Il pattern State si occupa del modo in cui un oggetto esegue un determinato compito ed incapsula un algoritmo.", "correct": false, "explanation": "State incapsula stati diversi di un oggetto e cambia comportamento in base allo stato, non in base a algoritmi intercambiabili." },
      { "id": 175, "text": "Il pattern State consente la definizione di una famiglia di algoritmi, intercambiabili tra loro.", "correct": false, "explanation": "La definizione di una famiglia di algoritmi intercambiabili √® caratteristica del pattern Strategy, non dello State." },
      { "id": 176, "text": "Il pattern State disaccoppia gli algoritmi dei clienti che vogliono usarli dinamicamente.", "correct": false, "explanation": "Disaccoppiare algoritmi e clienti √® compito del pattern Strategy; State disaccoppia invece il comportamento in base allo stato interno." },
      { "id": 177, "text": "Il pattern State e il pattern Strategy sono sintatticamente equivalenti ma differiscono nell‚Äôapplicazione.", "correct": false, "explanation": "Sono sintatticamente diversi." },
      { "id": 178, "text": "Le caratteristiche essenziali di un software sono Mantenibilit√†, Fidatezza, Efficienza e Accettabilit√†.", "correct": true, "explanation": "Si, sono proprio loro." },
      { "id": 179, "text": "Un processo per lo sviluppo del software descrive un approccio disciplinato alla costruzione, rilascio ed eventualmente manutenzione del software. Ci sono quattro attivit√† fondamentali di processo: Specifiche, Sviluppo, Convalida e Evoluzione/manutenzione.", "correct": true, "explanation": "Si, sono proprio loro." },
      { "id": 180, "text": "La problematica maggiore durante lo sviluppo del software sono i cambiamenti (dovuti dal cliente, adeguamenti tecnici o di contesto).", "correct": true, "explanation": "Occupano del tempo, durante il quale non √® garantito che le cose rimangano invariate." },
      { "id": 181, "text": "Unified Process (UP) organizza il lavoro e le iterazioni in quattro fasi NON sequenziali. La fine di ogni fase corrisponde a una milestone: Ideazione, Elaborazione, Costruzione e Transizione.", "correct": false, "explanation": "Unified Process (UP) organizza il lavoro e le iterazioni in quattro fasi sequenziali. La fine di ogni fase corrisponde a una milestone: Ideazione, Elaborazione, Costruzione e Transizione." },
      { "id": 182, "text": "L‚Äôelaborazione √® la serie finale di iterazioni in cui si consolidano i requisiti e si sviluppa il nucleo dell'architettura del sistema.", "correct": false, "explanation": "L‚Äôelaborazione √® la serie INIZIALE di iterazioni in cui si consolidano i requisiti e si sviluppa il nucleo dell'architettura del sistema." },
      { "id": 183, "text": "Il modello di dominio √® una parte della fase dei requisiti che consiste in una rappresentazione testuale che descrive i concetti fondamentali di un sistema, mettendo in evidenza le entit√† principali del dominio e le loro relazioni.", "correct": false, "explanation": "Il modello di dominio √® una parte di modellazione del business che consiste in una rappresentazione visuale che descrive i concetti fondamentali di un sistema, mettendo in evidenza le entit√† principali del dominio e le loro relazioni. " },
      { "id": 184, "text": "Il Diagramma di Sequenza di Sistema (SSD) √® uno strumento della disciplina dei requisiti che serve a rappresentare gli eventi di input e output che coinvolgono il sistema durante un'interazione con gli attori esterni.", "correct": true, "explanation": "Definizione corretta." },
      { "id": 185, "text": "L‚Äôarchitettura a strati (layered architecture) suddivide un sistema complesso in un insieme di elementi software che, per quanto possibile, possano essere sviluppati e modificati ciascuno indipendentemente dagli altri.", "correct": true, "explanation": "Definizione corretta." },
      { "id": 186, "text": "I modelli statici descrivono il comportamento del sistema e le interazioni tra gli oggetti (ad esempio, con i diagrammi di sequenza).", "correct": false, "explanation": "I modelli dinamici descrivono il comportamento del sistema e le interazioni tra gli oggetti (ad esempio, con i diagrammi di sequenza)." },
      { "id": 187, "text": "I modelli dinamici rappresentano la struttura del sistema, definendo classi, attributi e relazioni (tipicamente attraverso i diagrammi delle classi).", "correct": false, "explanation": "I modelli statici rappresentano la struttura del sistema, definendo classi, attributi e relazioni (tipicamente attraverso i diagrammi delle classi)." },
      { "id": 188, "text": "I GRASP (General Responsibility Assignment Software Patterns) sono un insieme di pattern utilizzati per assegnare in modo efficace le responsabilit√† agli oggetti in un sistema Object Oriented.", "correct": true, "explanation": "Definizione corretta." },
      { "id": 189, "text": "I pattern GoF promuovono l‚Äôuso dell'ereditariet√† rispetto alla composizione, in quanto la composizione evita i problemi di dipendenza.", "correct": false, "explanation": "I pattern GoF promuovono l‚Äôuso della composizione rispetto all‚Äôereditariet√†, in quanto la composizione evita i problemi di dipendenza." },
      { "id": 190, "text": "I test end-to-end verificano il funzionamento delle piccole parti (unit√†) del sistema.", "correct": false, "explanation": "I test end-to-end verificano il collegamento complessivo tra tutti gli elementi del sistema." },
      { "id": 191, "text": "Il refactoring √® un metodo strutturato e disciplinato per scrivere o ristrutturare del codice esistente modificando il comportamento esterno.", "correct": false, "explanation": "Il refactoring √® un metodo strutturato e disciplinato per scrivere o ristrutturare del codice esistente senza per√≤ modificare il comportamento esterno." },
      { "id": 192, "text": "I test unitari verificano il funzionamento delle piccole parti (unit√†) del sistema. Un metodo di test unitario √® logicamente composto da quattro parti: Preparazione, Esecuzione, Verifica e Rilascio.", "correct": true, "explanation": "I test unitari verificano il funzionamento delle piccole parti (unit√†) del sistema. Un metodo di test unitario √® logicamente composto da quattro parti: Preparazione, Esecuzione, Verifica e Rilascio." },
      { "id": 193, "text": "L‚Äôarchitettura logica di un sistema software √® la macro-organizzazione su larga scala delle classi software in package, sottoinsiemi e strati.", "correct": true, "explanation": "Definizione corretta." },
      { "id": 194, "text": "Nei contratti le pre-condizioni definiscono lo stato del sistema necessario affinch√© un‚Äôoperazione possa essere eseguita mentre le post-condizioni descrivono gli effetti dell‚Äôoperazione sul modello di dominio.", "correct": true, "explanation": "Definizione corretta." }
    ],
    "network": [
      { "id": 1, "text": "Le VPN (virtual private networks) sono utilizzate per:", "options": ["Partizionare una rete privata (es. azienda madre e filiali) in multiple reti virtualmente separate", "Dividere una rete locale aziendale in sottoreti per funzioni diverse (vendite, ingegneria, ecc.)", "Trasportare traffico privato su un'infrastruttura condivisa ricreando condizioni simili a un'infrastruttura privata", "Connettere solo dispositivi fisici sulla stessa LAN"], "correct": 2, "explanation": "Una VPN utilizza il tunneling e la crittografia per estendere una rete privata attraverso una rete pubblica (come Internet), permettendo ai dati di viaggiare in sicurezza come se fossero su una linea privata." },
      { "id": 2, "text": "Le soluzioni VPN di Livello 3 basate su MPLS sono caratterizzate da:", "options": ["Un buon livello di automazione e integrazione tra il backbone pubblico e le reti private", "Sicurezza particolarmente elevata grazie a tecniche crittografiche", "Meccanismi di tunneling di Livello 3, specificamente dentro pacchetti IP", "Un mix di meccanismi di tunneling Livello 2 e Livello 3"], "correct": 0, "explanation": "Le VPN MPLS L3 (BGP/MPLS) sono progettate per la scalabilit√† e permettono al provider di automatizzare la distribuzione delle informazioni di routing tra i siti dei clienti tramite il backbone." },
      { "id": 3, "text": "La 'Tunnel Mode' di IPsec prevede la cifratura di:", "options": ["L'header IP, l'header TCP/UDP e il payload del pacchetto interno", "Solo l'header TCP/UDP e il payload", "Solo il payload del pacchetto interno", "L'intero pacchetto esterno, header incluso"], "correct": 0, "explanation": "Nella modalit√† Tunnel, l'intero pacchetto IP originale (inclusi header e payload) viene cifrato e incapsulato all'interno di un nuovo pacchetto IP con una nuova intestazione." },
      { "id": 4, "text": "Due host A e B appartengono alla stessa rete fisica e hanno indirizzi IP 130.192.1.1/25 e 130.192.1.129/24 rispettivamente.", "options": ["A comunica direttamente con B e viceversa", "A comunica direttamente con B ma non viceversa", "A pu√≤ comunicare con B solo tramite un router", "A non pu√≤ comunicare con B"], "correct": 2, "explanation": "L'host B (/24) vede l'IP di A come parte della propria sottorete (1.0-1.255) e tenta di comunicare direttamente. L'host A (/25) vede la propria sottorete come 1.0-1.127; dato che B √® 1.129, A lo considera remoto e invia il traffico al Gateway." },
      { "id": 5, "text": "Quale di queste tecniche NON √® una soluzione per la transizione IPv4-IPv6?", "options": ["6to4", "6over4", "Teredo", "6mix4"], "correct": 3, "explanation": "6to4, 6over4 e Teredo sono meccanismi di tunneling validi definiti da IETF. '6mix4' √® un nome fittizio che non corrisponde ad alcuno standard." },
      { "id": 6, "text": "Nella soluzione DS-Lite per la transizione IPv4-IPv6:", "options": ["Le voci del database di filtraggio di uno switch Ethernet", "La funzionalit√† NAT non √® disponibile", "La funzionalit√† NAT √® implementata per tutti gli utenti su appositi dispositivi ISP", "La funzionalit√† NAT √® implementata sia sul CPE che sui dispositivi ISP"], "correct": 2, "explanation": "DS-Lite sposta la funzione NAT44 dal router domestico (CPE) alla rete dell'ISP (AFTR), utilizzando IPv6 per il tunneling del traffico IPv4 verso l'operatore." },
      { "id": 7, "text": "La metrica (costo) utilizzata da un algoritmo di routing:", "options": ["Esprime la probabilit√† di usare il percorso pi√π breve", "Esprime la complessit√† dell'algoritmo nel calcolo del percorso", "Esprime il peso assegnato a un collegamento (canale) nella selezione del percorso", "Esprime il costo monetario dell'hardware"], "correct": 2, "explanation": "La metrica √® un valore (basato su banda, ritardo, hop count, ecc.) assegnato a un collegamento per aiutare l'algoritmo a determinare il percorso 'migliore' verso una destinazione." },
      { "id": 8, "text": "BGP √® utilizzato in Internet per:", "options": ["Trovare la posizione geografica di un host basandosi sull'IP", "Scoprire router vicini su una rete locale", "Comunicare lo stato dei link ai router vicini", "Lo scambio di informazioni di routing tra router appartenenti a diversi sistemi autonomi"], "correct": 3, "explanation": "BGP (Border Gateway Protocol) √® il protocollo di Exterior Gateway (EGP) standard utilizzato per instradare il traffico tra diversi Sistemi Autonomi (AS) su Internet." },
      { "id": 9, "text": "La differenza tra algoritmi di routing link state e distance vector si pu√≤ riassumere come:", "options": ["Link state invia info locali solo ai vicini; Distance vector invia info globali a tutti i nodi", "Link state invia info locali a tutti i nodi; Distance vector invia info globali solo ai vicini", "Link state invia info globali a tutti i nodi; Distance vector invia info locali solo ai vicini", "Non c'√® differenza significativa"], "correct": 1, "explanation": "I router Link State inondano (flooding) le informazioni sui propri collegamenti locali all'intera rete (mappa globale). I router Distance Vector inviano la loro intera tabella di routing (raggiungibilit√† globale) solo ai vicini diretti." },
      { "id": 10, "text": "RIP √® caratterizzato da:", "options": ["Idoneit√† sia per routing inter-dominio che intra-dominio", "Capacit√† di operare su grandi reti grazie alla funzione gerarchica", "Utilizzo di un algoritmo di routing link state", "Frequente instabilit√† e tendenza a creare percorsi circolari (loop di routing)"], "correct": 3, "explanation": "RIP √® un protocollo Distance Vector che soffre di una convergenza lenta e del problema del 'count-to-infinity', che pu√≤ portare a loop di routing durante i cambiamenti di topologia." },
      { "id": 11, "text": "Due reti IP 130.192.0.0/24 e 130.192.2.0/24 possono essere aggregate in:", "options": ["130.192.0.0/23", "Non possono essere aggregate", "130.192.0.0/22", "130.192.2.0/23"], "correct": 2, "explanation": "Per aggregare 0.0 e 2.0, serve una maschera che copra 0, 1, 2, 3. Una /23 copre solo 0 e 1. Una /22 copre da 0.0 a 3.255, rendendola il blocco di aggregazione corretto." },
      { "id": 12, "text": "Il protocollo Integrated IS-IS:", "options": ["√à usato dagli switch Ethernet per creare uno spanning tree", "√à un'evoluzione di BGP per routing inter-AS", "√à un protocollo link-state ampiamente usato in grandi reti", "√à un protocollo di routing obsoleto"], "correct": 2, "explanation": "IS-IS √® un protocollo Link State robusto, simile a OSPF, ed √® ampiamente preferito dai Service Provider per le grandi reti backbone." },
      { "id": 13, "text": "RSVP (Resource reSerVation Protocol) permette:", "options": ["Di monitorare ritardo e perdita per pacchetti multimediali", "Ai server di riservare risorse di calcolo", "Ai router di conoscere i requisiti QoS di un'applicazione", "Di limitare il jitter nei router"], "correct": 2, "explanation": "RSVP √® un protocollo di segnalazione utilizzato dalle applicazioni per richiedere una specifica Qualit√† del Servizio (banda, ritardo) ai router lungo il percorso." },
      { "id": 14, "text": "In DiffServ, una 'classe di servizio' identifica:", "options": ["Un insieme di pacchetti gestiti allo stesso modo dai router (es. tutto il traffico VoIP)", "Una modalit√† operativa dei router di bordo che classificano i pacchetti", "Un insieme di pacchetti appartenenti alla stessa sessione VoIP", "Un livello di priorit√† assegnato solo dal livello applicativo"], "correct": 0, "explanation": "DiffServ aggrega il traffico in classi. Tutti i pacchetti della stessa classe (marcati con lo stesso DSCP) ricevono lo stesso trattamento di inoltro (Per-Hop Behavior)." },
      { "id": 15, "text": "L'importanza di MPLS nelle reti moderne deriva dalla possibilit√† di:", "options": ["Avere un unico piano di controllo per diverse tecnologie di commutazione", "Bilanciare il traffico in una server farm", "Creare dispositivi che funzionano senza configurazione", "Creare switch con supporto specifico per QoS"], "correct": 0, "explanation": "MPLS (Multi-Protocol Label Switching) disaccoppia l'inoltro dal routing, permettendo a un piano di controllo unificato (routing IP) di gestire varie tecnologie di data link (Ethernet, ATM, Frame Relay)." },
      { "id": 16, "text": "Uno dei protocolli usati in MPLS per la distribuzione delle etichette √®:", "options": ["OSPF", "BGP", "L2TP", "IS-IS"], "correct": 1, "explanation": "Mentre LDP √® il protocollo base, MP-BGP (Multiprotocol BGP) √® estensivamente usato per distribuire etichette per i servizi VPN MPLS." },
      { "id": 17, "text": "Nell'architettura MPLS, gli LSP (Label Switched Paths):", "options": ["Consistono nel percorso pi√π breve verso una destinazione", "Rappresentano percorsi alternativi mantenuti nella tabella del router", "Sono impostati dai nodi che concordano sulle etichette per una specifica FEC", "Sono scambiati dai router per mappare la rete"], "correct": 2, "explanation": "Un LSP √® la sequenza di etichette stabilita attraverso la rete per inoltrare i pacchetti appartenenti a una specifica Forwarding Equivalence Class (FEC)." },
      { "id": 18, "text": "Le operazioni che un router MPLS pu√≤ eseguire sulle etichette sono:", "options": ["Le etichette non possono essere modificate", "Push (aggiungi esterna), Pop (rimuovi esterna), Swap (cambia esterna)", "Push solo se non ne esistono altre, Pop solo all'uscita, Swap", "Push/Pop/Swap in qualsiasi posizione dello stack"], "correct": 1, "explanation": "Le operazioni MPLS riguardano sempre la cima dello stack di etichette. Push aggiunge un'etichetta, Pop rimuove quella superiore, e Swap sostituisce quella superiore." },
      { "id": 19, "text": "Il protocollo IGMP:", "options": ["√à una nuova versione di ICMP", "Permette a un router IPv4 di scoprire gruppi multicast su una rete connessa", "Permette a un router IPv4 di scoprire gruppi multicast attivi su Internet", "Permette a un host IPv4 di creare un nuovo gruppo multicast"], "correct": 1, "explanation": "IGMP (Internet Group Management Protocol) √® usato tra host e router locali affinch√© il router sappia a quali gruppi multicast gli host vogliono unirsi." },
      { "id": 20, "text": "In una rete IPv4, un host viene raggiunto da un pacchetto multicast:", "options": ["Solo se si √® unito a quel gruppo (indipendentemente dalla tecnologia L2)", "Anche se non si √® unito a quel gruppo (dipende dalla config L2)", "Sempre, e lo consegna al livello applicativo", "Mai, IPv4 non supporta il multicast"], "correct": 1, "explanation": "Senza meccanismi come IGMP Snooping sugli switch, il traffico multicast viene spesso inondato come broadcast a Livello 2, raggiungendo host che non l'hanno richiesto." },
      { "id": 21, "text": "La procedura Neighbor Discovery in IPv6:", "options": ["Si basa su un pacchetto ICMPv6 multicast", "Si basa su ARPv6", "Richiede supporto IPv4 nella rete", "Si basa su un pacchetto ICMPv6 broadcast"], "correct": 0, "explanation": "IPv6 ha sostituito l'ARP broadcast con la Neighbor Discovery che utilizza messaggi ICMPv6 inviati all'indirizzo Multicast Solicited-Node specifico." },
      { "id": 22, "text": "Il pacchetto ICMPv6 Router Advertisement:", "options": ["Abilita l'autoconfigurazione stateless", "Viene inviato periodicamente a tutti i router", "√à un pacchetto broadcast", "Viene inviato come risposta a Neighbor Solicitation"], "correct": 0, "explanation": "I Router Advertisement (RA) forniscono il prefisso di rete agli host, permettendo loro di generare il proprio indirizzo IP tramite SLAAC (Stateless Address Autoconfiguration)." },
      { "id": 23, "text": "Indirizzi IPv6 Privati (Unique Local):", "options": ["Usati solo sui router", "Globalmente univoci con alta probabilit√†, ma non instradabili globalmente", "Usati per interconnettere reti private via rete pubblica", "Usati solo per comunicazioni on-link"], "correct": 1, "explanation": "Gli indirizzi Unique Local (fc00::/7) sono l'equivalente IPv6 degli IP privati. Usano un ID casuale per garantire un'alta probabilit√† di univocit√† in caso di fusione di reti, ma non sono instradati su Internet." },
      { "id": 24, "text": "Indirizzi IPv6 Site Local:", "options": ["Impostati automaticamente per on-link", "Deprecati ma possono essere usati", "Assegnati da autorit√† centrale", "Non esistono"], "correct": 1, "explanation": "Gli indirizzi Site-Local (fec0::/10) erano una funzionalit√† iniziale di IPv6 ma sono stati formalmente deprecati (RFC 3879) a favore degli indirizzi Unique Local." },
      { "id": 25, "text": "L'indirizzo IPv6 FE80::0201:06FF:FEA5:3A4C √®:", "options": ["Attualmente non disponibile", "Utilizzabile da un host per comunicare con un altro sullo stesso link", "Utilizzabile da un server per offrire servizio pubblico", "Utilizzabile da pi√π dispositivi sullo stesso link"], "correct": 1, "explanation": "Il prefisso FE80::/10 identifica un indirizzo Link-Local, che √® valido e univoco solo sullo specifico collegamento fisico (segmento di rete) a cui √® connesso." },
      { "id": 26, "text": "Routing centralizzato:", "options": ["Impone che il traffico attraversi un nodo specifico", "√à obsoleto", "Impone che i nodi non scambino info di routing", "Consiste in un nodo che calcola i percorsi per gli altri e li fornisce loro"], "correct": 3, "explanation": "Nel routing centralizzato (come in SDN), un controller centrale ha una visione globale e calcola i percorsi per tutti i dispositivi di inoltro, inviando loro le tabelle." },
      { "id": 27, "text": "Usando l'autoconfigurazione privacy-aware (RFC-4941), un indirizzo IPv6 ha:", "options": ["Sia prefisso che interface ID non tracciabili", "Prefisso non tracciabile", "Validit√† solo in VPN", "Interface ID non tracciabile"], "correct": 3, "explanation": "Le estensioni per la privacy generano un Interface ID casuale e temporaneo che cambia nel tempo per prevenire il tracciamento del dispositivo basato sul suo indirizzo MAC statico." },
      { "id": 28, "text": "Una delle propriet√† principali dell'infrastruttura 5G √®:", "options": ["Ritorno alla commutazione di circuito", "Uso congiunto di virtualizzazione e controllo flessibile (Network Slicing)", "Virtualizzazione sui terminali mobili", "Uso di emulatori software per la progettazione"], "correct": 1, "explanation": "Il 5G si basa pesantemente su NFV (Network Function Virtualization) e SDN per creare 'Network Slices', permettendo a diverse reti logiche di girare su hardware fisico condiviso." },
      { "id": 29, "text": "L'indirizzo MAC di un pacchetto ICMPv6 Neighbor Solicitation √®:", "options": ["Indirizzo Broadcast", "Indirizzo Anycast", "Indirizzo Multicast", "Indirizzo Unicast del target"], "correct": 2, "explanation": "La Neighbor Solicitation viene inviata all'indirizzo Multicast Solicited-Node, che mappa a uno specifico indirizzo MAC Multicast di Livello 2 (33:33:xx:xx:xx:xx)." },
      { "id": 30, "text": "Indica l'affermazione FALSA sulle VPN basate su SSL:", "options": ["Non c'√® autenticazione dell'header IP", "Sono deboli contro attacchi DoS", "Sono disponibili soluzioni standard", "Si usano tunnel su TCP o UDP"], "correct": 2, "explanation": "A differenza di IPsec, che √® uno standard IETF rigoroso, le VPN SSL sono spesso implementazioni proprietarie (Clientless o stile AnyConnect) e mancano di un singolo standard interoperabile." },
      { "id": 31, "text": "L'handover nelle reti cellulari si riferisce a:", "options": ["Spostamento tra celle senza interruzione della comunicazione attiva", "Roaming verso altro operatore", "Spostamento tra celle in stato idle", "Accensione del terminale"], "correct": 0, "explanation": "L'handover (o handoff) √® il processo di trasferimento di una chiamata attiva o sessione dati da una stazione base all'altra mentre l'utente si sposta." },
      { "id": 32, "text": "In una rete cellulare FDMA:", "options": ["Si usa una sola frequenza", "Le chiamate vocali non sono possibili", "Le frequenze sono scelte casualmente", "Le frequenze disponibili sono divise tra celle vicine e riutilizzate in quelle distanti"], "correct": 3, "explanation": "L'FDMA divide lo spettro in canali di frequenza. Per evitare interferenze, le celle adiacenti usano frequenze diverse, ma le frequenze possono essere riutilizzate in celle non adiacenti (Riuso di Frequenza)." },
      { "id": 33, "text": "In MPLS, il label binding consiste in:", "options": ["Includere un'etichetta in BGP", "Associare un'etichetta a un percorso di routing", "Associare un'etichetta a una Forwarding Equivalence Class (FEC)", "Inviare un'etichetta a un altro nodo"], "correct": 2, "explanation": "Il label binding √® la decisione locale di un LSR di assegnare uno specifico valore di etichetta per rappresentare una specifica destinazione (FEC)." },
      { "id": 34, "text": "La cifratura del traffico nelle VPN √®:", "options": ["Non utilizzata", "La base di ogni soluzione", "Importante ma non strettamente necessaria/disponibile in tutte le soluzioni", "Importante ma non strettamente necessaria, non supportata in alcune"], "correct": 2, "explanation": "Sebbene essenziale per la sicurezza, la cifratura √® tecnicamente opzionale in definizioni come le VPN MPLS (che separano il traffico logicamente ma non lo cifrano di default)." },
      { "id": 35, "text": "La pi√π piccola aggregazione per 130.192.0.0/25 e 130.192.1.0/25 √®:", "options": ["130.192.0.0/24", "130.192.1.0/24", "130.192.1.0/23", "130.192.0.0/23"], "correct": 3, "explanation": "0.0/25 √® nel blocco 0.0/24. 1.0/25 √® nel blocco 1.0/24. Il blocco pi√π piccolo che contiene sia 0.x che 1.x √® la supernet /23 (che copre da 0.0 a 1.255)." },
      { "id": 36, "text": "Il Count to Infinity:", "options": ["Algoritmo Link State per prevenire loop", "Periodo transitorio nell'algoritmo Distance Vector", "Stato stabile", "Aiuta a capire se un nodo √® irraggiungibile"], "correct": 1, "explanation": "Il count-to-infinity √® un problema di loop di routing nei protocolli Distance Vector dove i nodi continuano a incrementare la metrica verso un nodo irraggiungibile finch√© non colpiscono un limite." },
      { "id": 37, "text": "Il Solicited Node Multicast Address √®:", "options": ["Indirizzo sorgente in Neighbor Solicitation", "Inserito nel payload (Target Address)", "Indirizzo destinazione in Neighbor Solicitation", "Inserito nel payload ICMPv6"], "correct": 2, "explanation": "Quando risolve un indirizzo, il mittente invia la Neighbor Solicitation all'indirizzo Multicast Solicited-Node del target (destinazione)." },
      { "id": 38, "text": "Indica l'affermazione VERA sulle VPN:", "options": ["Nessuna delle altre", "End-to-end √® sempre meglio di site-to-site", "Skewed channel √® solo cifratura IPsec", "Firewall non possono essere messi dentro una VPN"], "correct": 3, "explanation": "Il design standard solitamente impedisce di posizionare un firewall *dentro* la rete protetta da un gateway VPN in modo che possa ispezionare il traffico cifrato prima che venga decifrato." },
      { "id": 39, "text": "In GSM, un 'Regular Burst' √® usato:", "options": ["Solo per controllo chiamate", "Per inviare campioni vocali o info di controllo", "Durante la fase di connessione", "Solo per campioni vocali"], "correct": 1, "explanation": "I regular burst trasportano i Traffic Channels (TCH) che contengono i dati utente effettivi (voce) e i dati del Fast Associated Control Channel (FACCH)." },
      { "id": 40, "text": "I gruppi multicast in IPv4:", "options": ["Identificati da lista indirizzi IP", "Identificati da indirizzi IP speciali non assegnati a singoli host", "Identificati da lista indirizzi MAC", "Non esistono"], "correct": 1, "explanation": "Gli indirizzi IP di Classe D (da 224.0.0.0 a 239.255.255.255) identificano gruppi multicast, non interfacce specifiche." },
      { "id": 41, "text": "La distribuzione delle etichette in MPLS:", "options": ["Eseguita implicitamente via OSPF", "Non necessaria con BGP", "Pu√≤ essere eseguita con RSVP", "Coinvolge gli host"], "correct": 2, "explanation": "RSVP-TE (Resource Reservation Protocol con estensioni Traffic Engineering) √® uno dei protocolli standard usati per distribuire etichette e riservare risorse per gli LSP." },
      { "id": 42, "text": "Le estensioni OSPF-TE e ISIS-TE servono a:", "options": ["Distribuire dati vincolati (constrained data)", "Velocizzare la convergenza", "Indipendenza piano controllo/dati", "Campi routing esplicito"], "correct": 0, "explanation": "Queste estensioni trasportano dati aggiuntivi (come la banda disponibile su un link) per permettere il calcolo di percorsi Constraint-based per il Traffic Engineering." },
      { "id": 43, "text": "L'indirizzo IPv6 2001:4600::0201:06FF:FEA5:3A4C √®:", "options": ["Utilizzabile su un server per servizio Internet IPv6 pubblico", "Utilizzabile solo on-link", "Indirizzo privato", "Indirizzo non valido"], "correct": 0, "explanation": "2000::/3 √® l'intervallo per gli indirizzi Global Unicast, il che significa che questo √® un indirizzo pubblicamente instradabile adatto per un server." },
      { "id": 44, "text": "Algoritmo Distance Vector:", "options": ["Convergenza pi√π rapida di Link State", "Usato in scenari specifici", "Migliore stabilit√† di Link State", "Obsoleto e non usato"], "correct": 1, "explanation": "Sebbene pi√π vecchio, il Distance Vector (come RIP o EIGRP) √® ancora distribuito in scenari specifici (piccole reti, o EIGRP in ambienti Cisco) nonostante la convergenza pi√π lenta rispetto al Link State." },
      { "id": 45, "text": "L'idea base di MPLS consiste nel:", "options": ["Inserire etichetta in pacchetti IP per determinare percorso", "Inserire etichetta in frame L2", "Associare etichetta affinch√© destinazione identifichi il flusso", "Associare etichetta affinch√© i nodi determinino come processare il pacchetto"], "correct": 3, "explanation": "MPLS attacca un'etichetta ai pacchetti. I nodi di rete (LSR) prendono decisioni di inoltro basate esclusivamente sul contenuto di questa etichetta, piuttosto che sulla complessa intestazione IP." },
      { "id": 46, "text": "Uno switch ottico √® capace di commutare:", "options": ["Diversi canali ottici su una fibra", "Pacchetti in arrivo su canale ottico", "Un canale ottico su una lunghezza d'onda da ingresso a diversa lunghezza in uscita", "Un canale ottico su una lunghezza d'onda da fibra ingresso a uscita"], "correct": 3, "explanation": "Uno switch ottico (OXC/ROADM) commuta fisicamente la luce di una specifica lunghezza d'onda da una porta di ingresso a una porta di uscita senza convertirla in elettricit√†." },
      { "id": 47, "text": "GRE (Generic Routing Encapsulation) √® usato per:", "options": ["Identificare il protocollo incapsulato in IP", "Identificare il protocollo in Ethernet", "Scambiare info di routing", "Tunneling cifrato"], "correct": 0, "explanation": "GRE aggiunge un'intestazione che indica l''EtherType' del protocollo payload, permettendo a protocolli non-IP (o IP stesso) di essere incapsulati su una rete IP." },
      { "id": 48, "text": "La redistribuzione nel routing consiste nel:", "options": ["Ridistribuire il traffico", "Imparare rotte senza scambio", "Distribuire la tabella di routing", "Distribuire tramite un protocollo rotte acquisite via un altro protocollo"], "correct": 3, "explanation": "La redistribuzione √® il processo di prendere rotte apprese da un protocollo (es. OSPF) e iniettarle in un altro protocollo (es. BGP)." },
      { "id": 49, "text": "In topology-based control-driven label binding:", "options": ["Traffico di app diverse usa LSP diversi", "LSP √® creato come risultato della scoperta di una rotta (un LSP per destinazione)", "Tabelle forwarding manuali", "Deve usare BGP"], "correct": 1, "explanation": "In questa modalit√† (come LDP), le etichette vengono assegnate e distribuite automaticamente non appena il protocollo di routing apprende una rotta verso un prefisso di destinazione." },
      { "id": 50, "text": "DWDM permette di:", "options": ["Impacchettare fibre", "Multiplare/demultiplare segnali ottici (lunghezze d'onda) sulla stessa fibra", "Multiplare flussi di bit", "Commutare segnale ottico"], "correct": 1, "explanation": "Il Dense Wavelength Division Multiplexing mette pi√π flussi di dati su una singola fibra assegnando a ciascun flusso un colore (lunghezza d'onda) diverso di luce." }
    ]
  }
}