<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz SAS - Architettura Software e Sistemi</title>
    <link rel="manifest" href="manifest.json" />
    <link rel="icon" type="image/png" href="assets/favicon.png">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="quiz-style.css">
</head>
<body>
<div class="container">
    <header class="header">
        <h1>üìö Quiz di Teoria</h1>
        <a href="index.html" class="back-link">‚Üê Torna alla homepage</a>
    </header>

    <section class="progress-section" aria-live="polite">
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-text-container">
            <span class="progress-text">
                Domanda <span id="currentQuestion">1</span> di <span id="totalQuestions">0</span>
            </span>
            <div class="question-jump-section">
                <label for="questionJump">Vai a:</label>
                <select id="questionJump" aria-label="Salta alla domanda"></select>
            </div>
        </div>
        <div id="questionMap" class="question-map" role="navigation" aria-label="Mappa delle domande"></div>
    </section>

    <main class="quiz-content" id="quizContent"></main>

    <footer class="controls">
        <button class="btn btn-secondary" id="prevBtn">‚Üê Precedente</button>
        <button class="btn btn-danger" id="stopBtn">Ferma Quiz</button>
        <div class="current-stats">
            <span class="correct-count">Corrette: <span id="currentCorrectCount">0</span></span>
            <span class="incorrect-count">Sbagliate: <span id="currentIncorrectCount">0</span></span>
        </div>
        <div>
            <button class="btn btn-primary" id="showAnswerBtn">Mostra Risposta</button>
            <button class="btn btn-primary hidden" id="nextBtn">Successiva ‚Üí</button>
        </div>
    </footer>

    <section class="results hidden" id="results" aria-live="assertive">
        <div class="score-circle" id="scoreCircle">
            <div class="score-inner">
                <div class="score-percentage" id="scorePercentage">0%</div>
                <div class="score-label">Punteggio Totale</div>
            </div>
        </div>
        <h2>Quiz Terminato!</h2>
        <p>Ecco il riepilogo della tua sessione.</p>
        <div class="stats">
            <div class="stat" id="correctStat"><div class="stat-value">0</div><div class="stat-label">Corrette (su Totali)</div></div>
            <div class="stat" id="incorrectStat"><div class="stat-value">0</div><div class="stat-label">Sbagliate (su Totali)</div></div>
            <div class="stat" id="answeredCorrectStat"><div class="stat-value">0 / 0</div><div class="stat-label">Corrette / Date</div></div>
            <div class="stat" id="answeredIncorrectStat"><div class="stat-value">0 / 0</div><div class="stat-label">Sbagliate / Date</div></div>
        </div>
        <button class="btn btn-primary" id="restartBtn">üîÑ Ricomincia Quiz</button>
    </section>
</div>

<script src="quiz-logic.js"></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
    const originalQuestions = [
        {
            id: 1,
            text: "In UP, la disciplina dei requisiti ha l'obiettivo di produrre una lista dei requisiti, capire il contesto del sistema, catturare i requisiti funzionali e i requisiti non-funzionali",
            correct: true,
            explanation: "La disciplina dei requisiti in UP ha effettivamente come obiettivi principali: produrre una lista dei requisiti, comprendere il contesto del sistema, e catturare sia i requisiti funzionali che non-funzionali."
        },
        {
            id: 2,
            text: "Il modello di dominio include la definizione di oggetti, associazioni e attributi di classi software",
            correct: false,
            explanation: "Il modello di dominio rappresenta classi CONCETTUALI del dominio del problema, non classi software. Include oggetti concettuali, associazioni e attributi del mondo reale."
        },
        {
            id: 3,
            text: "Il modello di dominio √® un dizionario visuale delle classi concettuali",
            correct: true,
            explanation: "Corretto. Il modello di dominio √® una rappresentazione visuale (dizionario visuale) delle classi concettuali rilevanti nel dominio del problema."
        },
        {
            id: 4,
            text: "Il modello di dominio √® una rappresentazione testuale delle classi concettuali, oggetti reali del dominio",
            correct: false,
            explanation: "Il modello di dominio √® una rappresentazione VISUALE (non testuale) delle classi concettuali. Utilizza diagrammi UML per rappresentare graficamente i concetti."
        },
        {
            id: 5,
            text: "Il modello di dominio non √® parte della disciplina dei requisiti",
            correct: true,
            explanation: "Il modello di dominio √® parte della disciplina di Modellazione del Business in UP. Aiuta a comprendere e documentare i concetti del dominio del problema."
        },
        {
            id: 6,
            text: "Nelle associazioni nel modello di dominio la direzione di lettura va sempre specificata",
            correct: false,
            explanation: "La direzione di lettura nelle associazioni del modello di dominio NON va sempre specificata. √à opzionale e si usa solo quando serve chiarire il significato dell'associazione."
        },
        {
            id: 7,
            text: "L'associazione nel modello di dominio √® per sua natura unidirezionale",
            correct: false,
            explanation: "Le associazioni nel modello di dominio sono per natura BIDIREZIONALI. Rappresentano relazioni concettuali che possono essere navigate in entrambe le direzioni."
        },
        {
            id: 8,
            text: "L'associazione nel modello di dominio rappresenta una relazione significativa tra classi",
            correct: true,
            explanation: "Corretto. Le associazioni nel modello di dominio rappresentano relazioni significative e rilevanti tra le classi concettuali del dominio."
        },
        {
            id: 9,
            text: "L'associazione nel modello di dominio rappresenta un valore logico degli oggetti di una classe",
            correct: false,
            explanation: "Le associazioni rappresentano RELAZIONI tra classi, non valori logici degli oggetti. I valori logici sono rappresentati dagli attributi."
        },
        {
            id: 10,
            text: "L'associazione nel modello di dominio rappresenta un'insieme di n-tuple di oggetti delle classi",
            correct: true,
            explanation: "Matematicamente, un'associazione pu√≤ essere vista come un insieme di n-tuple (coppie, triple, ecc.) di oggetti delle classi coinvolte nella relazione."
        },
        {
            id: 11,
            text: "Il modello di dominio √® una rappresentazione testuale delle classi concettuali, oggetti reali del dominio",
            correct: false,
            explanation: "Il modello di dominio √® una rappresentazione VISUALE (non testuale) delle classi concettuali, utilizzando diagrammi UML."
        },
        {
            id: 12,
            text: "Il modello di dominio √® un dizionario visuale delle classi concettuali",
            correct: true,
            explanation: "Corretto. Il modello di dominio funge da dizionario visuale che definisce e illustra le classi concettuali rilevanti nel dominio."
        },
        {
            id: 13,
            text: "Il MODELLO DI DOMINIO: Insieme di diagrammi di classi UML che includono associazioni tra classi software",
            correct: false,
            explanation: "Il modello di dominio include associazioni tra classi CONCETTUALI, non classi software. Le classi software appartengono al modello di progetto."
        },
        {
            id: 14,
            text: "Il MODELLO DI DOMINIO: Rappresentazione grafica degli oggetti software",
            correct: false,
            explanation: "Il modello di dominio rappresenta oggetti CONCETTUALI del dominio del problema, non oggetti software che appartengono all'implementazione."
        },
        {
            id: 15,
            text: "Il MODELLO DI DOMINIO: Rappresentazione visuale delle classi concettuali",
            correct: true,
            explanation: "Corretto. Il modello di dominio √® una rappresentazione visuale delle classi concettuali rilevanti nel dominio del problema."
        },
        {
            id: 16,
            text: "Il MODELLO DI DOMINIO: Insieme di diagrammi di classi UML che includono associazioni tra classi concettuali",
            correct: true,
            explanation: "Corretto. Il modello di dominio utilizza diagrammi di classi UML per rappresentare classi concettuali e le loro associazioni."
        },
        {
            id: 17,
            text: "Il MODELLO DI DOMINIO: Rappresentazione visuale delle classi JAVA",
            correct: false,
            explanation: "Il modello di dominio rappresenta classi CONCETTUALI del dominio, non classi Java che sono parte dell'implementazione software."
        },
        {
            id: 18,
            text: "Il MODELLO DI DOMINIO: Insieme di diagrammi di classi UML che includono le responsabilit√† di fare",
            correct: false,
            explanation: "Il modello di dominio NON include responsabilit√† 'di fare' (metodi). Le responsabilit√† sono assegnate durante la fase di progetto, non nell'analisi del dominio."
        },
        {
            id: 19,
            text: "Un caso d'uso rappresenta una maniera di utilizzare il sistema da parte di un utente per raggiungere un suo obiettivo",
            correct: true,
            explanation: "Corretto. Un caso d'uso descrive come un attore (utente) interagisce con il sistema per raggiungere un obiettivo specifico."
        },
        {
            id: 20,
            text: "La narrativa di un caso d'uso viene espressa a livello delle intenzioni dell'utente e della responsabilit√† del sistema",
            correct: true,
            explanation: "Corretto. I casi d'uso sono scritti dal punto di vista delle intenzioni dell'utente e delle responsabilit√† che il sistema deve assumere per soddisfarle."
        },
        {
            id: 21,
            text: "La narrativa di un caso d'uso viene espressa a livello delle azioni concrete dell'utente e delle responsabilit√† del sistema",
            correct: false,
            explanation: "I casi d'uso sono scritti a livello di INTENZIONI dell'utente, non di azioni concrete. Le azioni concrete appartengono a un livello di dettaglio troppo basso."
        },
        {
            id: 22,
            text: "Un caso d'uso √® sempre completato (implementato) in una solo iterazione",
            correct: false,
            explanation: "Un caso d'uso pu√≤ essere implementato in pi√π iterazioni. Spesso si implementano prima gli scenari base e successivamente quelli alternativi."
        },
        {
            id: 23,
            text: "Un caso d'uso rappresenta l'insieme di funzionalit√† di un sistema",
            correct: false,
            explanation: "Un caso d'uso rappresenta UN MODO SPECIFICO di utilizzare il sistema per raggiungere un obiettivo, non l'insieme di tutte le funzionalit√†."
        },
        {
            id: 24,
            text: "I requisiti funzionali non catturati dai casi d'uso vengono descritti nelle specifiche supplementari",
            correct: true,
            explanation: "Corretto. Le specifiche supplementari documentano i requisiti funzionali che non sono catturati dai casi d'uso (es. report, formati di file, ecc.)."
        },
        {
            id: 25,
            text: "L'analisi linguistica dei casi d'uso nel formato dettagliato √® una fonte di ispirazione per la costruzione del modello di dominio",
            correct: true,
            explanation: "Corretto. L'analisi dei sostantivi e dei concetti nei casi d'uso dettagliati aiuta a identificare le classi concettuali per il modello di dominio."
        },
        {
            id: 26,
            text: "Il modello di dominio riporta i concetti significativi relativi ai casi d'uso",
            correct: true,
            explanation: "Corretto. Il modello di dominio include i concetti del dominio che sono rilevanti per i casi d'uso del sistema."
        },
        {
            id: 27,
            text: "L'analisi linguistica dei casi d'uso nel formato dettagliato √® una fonte di ispirazione per la costruzione del modello di dominio",
            correct: true,
            explanation: "Corretto. L'analisi linguistica dei casi d'uso (identificazione di sostantivi, concetti) √® una tecnica fondamentale per costruire il modello di dominio."
        },
        {
            id: 28,
            text: "I requisiti non funzionali sono descritti completamente dai casi d'uso",
            correct: false,
            explanation: "I casi d'uso catturano principalmente requisiti FUNZIONALI. I requisiti non-funzionali (performance, sicurezza, usabilit√†) sono documentati nelle specifiche supplementari."
        },
        {
            id: 29,
            text: "I contratti sono considerati parte del modello dei casi d'uso poich√© forniscono maggiori dettagli dell'analisi, sull'effetto delle operazioni di sistema implicate dai casi d'uso",
            correct: true,
            explanation: "Corretto. I contratti delle operazioni di sistema forniscono dettagli aggiuntivi sugli effetti delle operazioni identificate nei casi d'uso."
        },
        {
            id: 30,
            text: "I CASI D'USO Sono una collezione di soli scenari di successo che descrivono un attore che usa il sistema per raggiungere un obiettivo specifico",
            correct: false,
            explanation: "I casi d'uso includono sia scenari di SUCCESSO che scenari ALTERNATIVI (inclusi quelli di fallimento). Non sono limitati ai soli scenari di successo."
        },
        {
            id: 31,
            text: "I casi d'uso sono descrizioni testuali di scenari di uso interessanti del sistema software che si deve realizzare",
            correct: true,
            explanation: "Corretto. I casi d'uso sono descrizioni testuali che documentano scenari di utilizzo significativi del sistema da sviluppare."
        },
        {
            id: 32,
            text: "I casi d'uso servono a catturare i requisiti funzionali",
            correct: true,
            explanation: "Corretto. Il principale scopo dei casi d'uso √® catturare e documentare i requisiti funzionali del sistema."
        },
        {
            id: 33,
            text: "In UP i casi d'uso vengono utilizzati per catturare i requisiti funzionali nella disciplina dei requisiti",
            correct: true,
            explanation: "Corretto. Nel Unified Process, i casi d'uso sono lo strumento principale per catturare i requisiti funzionali durante la disciplina dei requisiti."
        },
        {
            id: 34,
            text: "I casi d'uso sono caratteristiche del sistema",
            correct: false,
            explanation: "I casi d'uso NON sono caratteristiche del sistema, ma descrivono COME il sistema viene utilizzato dagli attori per raggiungere obiettivi specifici."
        },
        {
            id: 35,
            text: "I casi d'uso sono utilizzati per pianificare le iterazioni",
            correct: true,
            explanation: "Corretto. I casi d'uso sono utilizzati per organizzare e pianificare le iterazioni di sviluppo, implementando i casi d'uso pi√π critici nelle prime iterazioni."
        },
        {
            id: 36,
            text: "In UP i casi d'uso sono descritti mediante il linguaggio UML",
            correct: false,
            explanation: "I casi d'uso in UP sono descritti principalmente in linguaggio NATURALE (testo), non in UML. UML fornisce solo i diagrammi dei casi d'uso per mostrare le relazioni."
        },
        {
            id: 37,
            text: "DURANTE LA FASE DI ELABORAZIONE Si scrivono circa il 10% dei casi d'uso tra i pi√π critici in formato dettagliato utilizzando template appositi",
            correct: false,
            explanation: "Durante l'ideazione si scrive in dettaglio circa il 10% dei casi d'uso pi√π critici e rischiosi per guidare l'architettura. La fase di Elaborazione √® invece il momento in cui la maggior parte dei requisiti viene chiarita e stabilizzata, portando ad una percentuale molto pi√π alta (40-80%) di casi d'uso dettagliati entro la fine di questa fase. Vengono implementati il 100% dei requisiti funzionali del progetto (preso dai quiz)."
        },
        {
            id: 38,
            text: "In percentuale sul totale di casi d'uso complessivi di un progetto, sono pari al 5% quelli che dovrebbero essere realizzati entro la conclusione della fase di ideazione?",
            correct: true,
            explanation: "Corretto. Durante la fase di ideazione si implementa circa il 5% dei casi d'uso tra tutti quelli identificati."
        },
        {
            id: 39,
            text: "I casi d'uso mettono in risalto gli obiettivi degli utenti",
            correct: true,
            explanation: "Corretto. I casi d'uso sono organizzati attorno agli obiettivi che gli utenti (attori) vogliono raggiungere utilizzando il sistema."
        },
        {
            id: 40,
            text: "I casi d'uso sono utilizzati per la scoperta e la definizione dei requisiti non funzionali",
            correct: false,
            explanation: "I casi d'uso sono utilizzati principalmente per i requisiti FUNZIONALI. I requisiti non-funzionali sono documentati nelle specifiche supplementari."
        },
        {
            id: 41,
            text: "I casi d'uso sono utilizzati per la scoperta e la definizione dei requisiti funzionali",
            correct: true,
            explanation: "Corretto. I casi d'uso sono lo strumento principale per scoprire, definire e documentare i requisiti funzionali del sistema."
        },
        {
            id: 42,
            text: "I casi d'uso mettono in risalto gli obiettivi del sistema",
            correct: false,
            explanation: "I casi d'uso mettono in risalto gli obiettivi degli UTENTI (attori), non del sistema. Il sistema risponde agli obiettivi degli utenti."
        },
        {
            id: 43,
            text: "I casi d'uso sono utilizzati solo nelle prime iterazioni di sviluppo",
            correct: false,
            explanation: "I casi d'uso sono utilizzati durante TUTTO il processo di sviluppo, non solo nelle prime iterazioni. Guidano implementazione, test e validazione."
        },
        {
            id: 44,
            text: "Il principale input per la redazione dei contratti sono le operazioni di sistema e il modello di dominio",
            correct: true,
            explanation: "Corretto. I contratti sono scritti per le operazioni di sistema identificate negli SSD, utilizzando il modello di dominio per descrivere gli effetti."
        },
        {
            id: 45,
            text: "Le post-condizioni descrivono i cambiamenti di stato degli oggetti nel modello di dominio dopo il completamento dell'operazione",
            correct: true,
            explanation: "Corretto. Le post-condizioni nei contratti descrivono come cambiano gli stati degli oggetti del modello di dominio dopo l'esecuzione dell'operazione."
        },
        {
            id: 46,
            text: "I contratti servono come input per il modello di dominio",
            correct: false,
            explanation: "I contratti NON servono come input per il modello di dominio. √à il contrario: il modello di dominio serve come input per scrivere i contratti."
        },
        {
            id: 47,
            text: "La responsabilit√† sono assegnate ai concetti definiti nel modello di dominio",
            correct: false,
            explanation: "Le responsabilit√† sono assegnate alle CLASSI SOFTWARE durante la progettazione, non ai concetti del modello di dominio che rappresenta solo l'analisi."
        },
        {
            id: 48,
            text: "I contratti delle operazioni di sistema usano pre e post- condizioni per descrivere nel dettaglio i cambiamenti agli oggetti (concettuali) in un modello di dominio",
            correct: true,
            explanation: "Corretto. I contratti utilizzano pre-condizioni e post-condizioni per descrivere dettagliatamente come le operazioni di sistema modificano gli oggetti concettuali."
        },
        {
            id: 49,
            text: "I contratti servono come input per il modello di dominio",
            correct: false,
            explanation: "I contratti NON servono come input per il modello di dominio. Il modello di dominio √® creato prima e serve come base per scrivere i contratti."
        },
        {
            id: 50,
            text: "Le pre-condizioni descrivono i cambiamenti di stato degli oggetti nel modello di dominio dopo il completamento dell'operazione",
            correct: false,
            explanation: "Le pre-condizioni descrivono lo stato che deve esistere PRIMA dell'operazione. Sono le POST-condizioni che descrivono i cambiamenti dopo l'operazione."
        },
        {
            id: 51,
            text: "La composizione di oggetti √® definita staticamente attraverso la specifica delle classi e delle associazioni",
            correct: true,
            explanation: "Corretto. La composizione viene definita staticamente nel codice attraverso la definizione delle classi e delle loro relazioni di composizione."
        },
        {
            id: 52,
            text: "Il meccanismo di specializzazione per il riuso del codice √® detto white-box",
            correct: true,
            explanation: "Corretto. L'ereditariet√† (specializzazione) √® chiamata riuso 'white-box' perch√© la sottoclasse ha visibilit√† sui dettagli interni della superclasse."
        },
        {
            id: 53,
            text: "La modifica dell'interfaccia di una classe ha in generale un basso impatto nelle sottoclassi",
            correct: false,
            explanation: "La modifica dell'interfaccia di una classe ha generalmente un ALTO impatto sulle sottoclassi, che dipendono dall'interfaccia della superclasse."
        },
        {
            id: 54,
            text: "I pattern GRASP sono espressi in termini di responsabilit√†, ruoli e collaborazioni",
            correct: true,
            explanation: "Corretto. I pattern GRASP (General Responsibility Assignment Software Patterns) si concentrano sull'assegnazione di responsabilit√†, ruoli e collaborazioni tra oggetti."
        },
        {
            id: 55,
            text: "La decisione sull'assegnazione delle responsabilit√† precede sempre la codifica",
            correct: false,
            explanation: "L'assegnazione delle responsabilit√† √® parte della progettazione (OOD) che precede logicamente la fase di implementazione/codifica, ma le decisioni sull‚Äôassegnazione delle responsabilit√† agli oggetti possono anche essere prese mentre si esegue la codifica oppure durante la modellazione."
        },
        {
            id: 56,
            text: "L'utilizzo dei pattern GRASP √® svolto all'interno della disciplina dei requisiti di UP",
            correct: false,
            explanation: "I pattern GRASP sono utilizzati nella disciplina di PROGETTAZIONE (Design), non nella disciplina dei requisiti. Riguardano l'assegnazione di responsabilit√† alle classi software."
        },
        {
            id: 57,
            text: "Le responsabilit√† sono assegnate alle classi durante la OOD",
            correct: true,
            explanation: "Corretto. L'Object-Oriented Design (OOD) √® la fase in cui si assegnano le responsabilit√† alle classi software utilizzando principi come i pattern GRASP."
        },
        {
            id: 58,
            text: "Il meccanismo di delega √® preferibile al meccanismo di specializzazione per il riuso del codice",
            correct: true,
            explanation: "Corretto. La composizione/delega (riuso black-box) √® generalmente preferibile all'ereditariet√† perch√© √® pi√π flessibile e mantiene un minor accoppiamento."
        },
        {
            id: 59,
            text: "L'ereditariet√† rispetta l'incapsulamento",
            correct: false,
            explanation: "L'ereditariet√† NON rispetta completamente l'incapsulamento perch√© la sottoclasse ha accesso ai membri protetti della superclasse, rompendo l'incapsulamento."
        },
        {
            id: 60,
            text: "La composizione di oggetti √® un meccanismo di riuso del codice detto black-box",
            correct: true,
            explanation: "Corretto. La composizione √® chiamata riuso 'black-box' perch√© gli oggetti componenti sono utilizzati solo attraverso le loro interfacce pubbliche."
        },
        {
            id: 61,
            text: "Un metodo di una classe software rappresenta una responsabilit√† 'a fare' per le istanze di tale classe",
            correct: true,
            explanation: "Corretto. I metodi rappresentano le responsabilit√† 'doing' (a fare) di una classe, cio√® quello che gli oggetti di quella classe sanno fare."
        },
        {
            id: 62,
            text: "DURANTE LA FASE DI ELABORAZIONE Non vengono effettuati test al codice di sviluppo",
            correct: false,
            explanation: "Durante la fase di elaborazione SI effettuano test al codice. √à una fase in cui si programma il nucleo architetturale e lo si testa."
        },
        {
            id: 63,
            text: "DURANTE LA FASE DI ELABORAZIONE Non si sviluppa codice",
            correct: false,
            explanation: "Durante la fase di elaborazione SI sviluppa codice. Si programma il nucleo architetturale del sistema per validare l'architettura proposta."
        },
        {
            id: 64,
            text: "DURANTE LA FASE DI ELABORAZIONE Viene scoperta e stabilizzata la maggior parte dei requisiti",
            correct: true,
            explanation: "Corretto. L'elaborazione √® la fase in cui si scoprono e stabilizzano la maggior parte dei requisiti, completando l'analisi iniziata nell'ideazione."
        },
        {
            id: 65,
            text: "DURANTE LA FASE DI ELABORAZIONE Si realizza uno studio economico per stabilire l'ordine di grandezza del progetto e dei costi",
            correct: false,
            explanation: "Lo studio economico preliminare viene fatto durante la fase di IDEAZIONE, non di elaborazione. L'elaborazione raffina le stime."
        },
        {
            id: 66,
            text: "DURANTE LA FASE DI ELABORAZIONE Viene programmato il nucleo, rischioso, dell'architettura",
            correct: true,
            explanation: "Corretto. Durante l'elaborazione si programma e testa il nucleo architetturale del sistema, concentrandosi sulle parti pi√π rischiose."
        },
        {
            id: 67,
            text: "In UML per responsabilit√† si intende la specifica di un metodo associato ad una classe Java",
            correct: false,
            explanation: "In UML, responsabilit√† √® un concetto pi√π generale che include sia 'knowing' che 'doing'. Non √® limitato ai soli metodi Java."
        },
        {
            id: 68,
            text: "In UML per responsabilit√† si intende la specifica di una variabile di istanza di una classe Java",
            correct: false,
            explanation: "Le variabili di istanza sono parte delle responsabilit√† 'knowing', ma la responsabilit√† in UML √® un concetto pi√π ampio che include anche le azioni."
        },
        {
            id: 69,
            text: "In UML per responsabilit√† si intende un contratto o un obbligo di un classificatore",
            correct: true,
            explanation: "Corretto. In UML, una responsabilit√† √® definita come un contratto o obbligo di un classificatore (classe), che include sia knowing che doing."
        },
        {
            id: 70,
            text: "In UML per responsabilit√† si intende la specifica di una variabile di istanza o di un metodo associato ad una classe Java",
            correct: false,
            explanation: "La responsabilit√† in UML √® un concetto pi√π astratto di contratto/obbligo, non semplicemente l'implementazione in variabili o metodi Java."
        },
        {
            id: 71,
            text: "Gli SSD Sono espressi attraverso i diagrammi di comunicazione di UML",
            correct: false,
            explanation: "Gli SSD (System Sequence Diagrams) sono espressi attraverso i diagrammi di SEQUENZA di UML, non i diagrammi di comunicazione."
        },
        {
            id: 72,
            text: "Gli SSD Mostrano l'ordine degli eventi generati dagli attori esterni al sistema",
            correct: true,
            explanation: "Corretto. Gli SSD mostrano la sequenza temporale degli eventi di sistema generati dagli attori esterni per uno specifico scenario di caso d'uso."
        },
        {
            id: 73,
            text: "I contratti costituiscono un input per gli SSD delle operazioni e per la progettazione degli oggetti",
            correct: false,
            explanation: "√à il contrario: gli SSD sono input per i contratti. Gli SSD identificano le operazioni di sistema, per le quali poi si scrivono i contratti."
        },
        {
            id: 74,
            text: "Un evento di sistema √® un evento interno al sistema",
            correct: false,
            explanation: "Un evento di sistema √® un evento che arriva al sistema dall'ESTERNO, generato da un attore esterno. Gli eventi interni non sono eventi di sistema."
        },
        {
            id: 75,
            text: "Gli SSD mostrano gli eventi generati dagli attori esterni al sistema",
            correct: true,
            explanation: "Corretto. Gli SSD (System Sequence Diagrams) mostrano gli eventi di sistema generati dagli attori esterni durante l'esecuzione di un caso d'uso."
        },
        {
            id: 76,
            text: "In percentuale sul totale dei requisiti funzionali di un progetto, quelli che dovrebbero essere identificati entro la conclusione della fase di IDEAZIONE sono pari al 50%? ",
            correct: false,
            explanation: "Alla fine dell'ideazione si dovrebbe aver identificato circa il 70% dei requisiti funzionali, non il 50%. Il 50% √® troppo poco per completare l'ideazione."
        },
        {
            id: 77,
            text: "In percentuale sul totale dei requisiti funzionali di un progetto, quelli che dovrebbero essere identificati entro la conclusione della fase di ELABORAZIONE sono pari al 100%?",
            correct: true,
            explanation: "Corretto. Alla fine dell'elaborazione dovrebbero essere identificati praticamente tutti i requisiti funzionali, per poter pianificare accuratamente la costruzione."
        },
        {
            id: 78,
            text: "Il riuso white-box √® preferibile al riuso black-box",
            correct: false,
            explanation: "Il riuso black-box (composizione) √® generalmente preferibile al riuso white-box (ereditariet√†) perch√© offre maggiore flessibilit√† e minor accoppiamento."
        },
        {
            id: 79,
            text: "Il meccanismo di ereditariet√† non √® preferibile al meccanismo di delega per ottenere il riuso del software",
            correct: true,
            explanation: "Corretto. La delega (composizione) √® spesso preferibile all'ereditariet√† per il riuso perch√© √® pi√π flessibile e mantiene un accoppiamento pi√π basso."
        },
        {
            id: 80,
            text: "L'ereditariet√† si avvale del meccanismo di delega",
            correct: false,
            explanation: "L'ereditariet√† e la delega sono meccanismi ALTERNATIVI per il riuso del codice. L'ereditariet√† non si avvale della delega."
        },
        {
            id: 81,
            text: "Il meccanismo di composizione non rispetta l'incapsulamento",
            correct: false,
            explanation: "Il meccanismo di composizione RISPETTA l'incapsulamento perch√© accede agli oggetti componenti solo attraverso le loro interfacce pubbliche."
        },
        {
            id: 82,
            text: "Le operazioni di sistema possono essere identificate mentre si abbozzano gli SSD",
            correct: true,
            explanation: "Corretto. Le operazioni di sistema vengono identificate durante la creazione degli SSD, che mostrano gli eventi che il sistema deve gestire."
        },
        {
            id: 83,
            text: "I contratti descrivono in modo dettagliato i cambiamenti richiesti dall'esecuzione di una operazione di sistema, descrivono come devono essere ottenuti questi risultati",
            correct: false,
            explanation: "I contratti descrivono COSA deve succedere (post-condizioni), ma NON descrivono COME ottenere questi risultati. Il 'come' √® parte della progettazione."
        },
        {
            id: 84,
            text: "I pattern GoF incentivano l'uso dell'ereditariet√† come meccanismo di riuso del codice, in particolare attraverso il pattern composite",
            correct: false,
            explanation: "I pattern GoF generalmente SCORAGGIANO l'uso eccessivo dell'ereditariet√† per il riuso preferendo la composizione. Il pattern Composite usa l'ereditariet√† per il polimorfismo, non per il riuso."
        },
        {
            id: 85,
            text: "I pattern GoF prediligono l'utilizzo del meccanismo di ereditariet√† per ottenere la specializzazione",
            correct: false,
            explanation: "I pattern GoF enfatizzano il principio 'favor composition over inheritance' - preferire la composizione all'ereditariet√† anche per la specializzazione."
        },
        {
            id: 86,
            text: "I pattern GoF incentivano i meccanismi di riuso del software attraverso la definizione di gerarchie di classi",
            correct: false,
            explanation: "I pattern GoF promuovono il riuso attraverso la COMPOSIZIONE e la delega, non attraverso gerarchie di classi estese."
        },
        {
            id: 87,
            text: "I pattern GoF prediligono l'utilizzo del meccanismo di ereditariet√† per ottenere il polimorfismo",
            correct: true,
            explanation: "Corretto. I pattern GoF utilizzano l'ereditariet√† principalmente per ottenere il POLIMORFISMO (comportamenti diversi con interfaccia comune), non per il riuso del codice."
        },
        {
            id: 88,
            text: "I pattern GoF Composite fornisce caratteristiche addizionali ad elementi atomici (foglie), mantenendo una interfaccia comune",
            correct: false,
            explanation: "Il pattern Composite NON fornisce caratteristiche addizionali alle foglie. Permette di trattare oggetti semplici e composti uniformemente."
        },
        {
            id: 89,
            text: "Il pattern GoF Composite permette di costruire tassonomie di classi",
            correct: false,
            explanation: "Il pattern Composite permette di costruire strutture ad ALBERO di oggetti, non tassonomie di classi. Le tassonomie sono gerarchie di ereditariet√†."
        },
        {
            id: 90,
            text: "Il pattern GoF Composite utilizza il meccanismo di specializzazione per rendere l'interfaccia delle entit√† atomiche esattamente come l'interfaccia delle entit√† composte",
            correct: false,
            explanation: "Il Composite usa la generalizzazione per far s√¨ che foglie e nodi composti implementino la stessa interfaccia, permettendo un trattamento uniforme."
        },
        {
            id: 91,
            text: "Il pattern GoF Composite permette di evitare l'esplosione delle sottoclassi per supportare un ampio numero di estensioni e combinazioni di esse",
            correct: false,
            explanation: "Questo √® il pattern DECORATOR, non Composite. Il Composite organizza oggetti in strutture ad albero, non evita l'esplosione di sottoclassi."
        },
        {
            id: 92,
            text: "Il pattern GoF Composite permette di costruire strutture ricorsive in modo che ad un cliente l'intera struttura sia vista come una singola entit√†",
            correct: true,
            explanation: "Corretto. Il pattern Composite permette di costruire strutture ad albero dove i client possono trattare oggetti semplici e composti uniformemente."
        },
        {
            id: 93,
            text: "L'extreme programming promuove lo sviluppo seguito dai test",
            correct: false,
            explanation: "XP promuove il TDD (Test-Driven Development): prima si scrivono i test, POI si scrive il codice per farli passare. I test precedono lo sviluppo."
        },
        {
            id: 94,
            text: "I test unitari hanno lo scopo di verificare la comunicazione tra specifiche parti del sistema",
            correct: false,
            explanation: "I test unitari verificano il comportamento di singole UNIT√Ä (metodi, classi) in isolamento. I test di integrazione verificano la comunicazione tra parti."
        },
        {
            id: 95,
            text: "Preparazione, esecuzione, verifica e rilascio sono le parti del test unitario",
            correct: true,
            explanation: "Corretto. Le fasi tipiche di un test unitario sono: Setup (preparazione), Exercise (esecuzione), Verify (verifica) e Release (rilascio)."
        },
        {
            id: 96,
            text: "Il refactoring prevede di applicare piccole trasformazioni che preservano il comportamento",
            correct: true,
            explanation: "Corretto. Il refactoring consiste nell'applicare piccole trasformazioni al codice che migliorano la struttura senza modificare il comportamento esterno."
        },
        {
            id: 97,
            text: "I test unitari sono utilizzati per dimostrare che il refactoring non abbia causato una regressione",
            correct: true,
            explanation: "Corretto. I test unitari servono come rete di sicurezza durante il refactoring, assicurando che il comportamento rimanga invariato."
        },
        {
            id: 98,
            text: "La progettazione object-oriented in UP ha il fine di identificare le responsabilit√† e assegnarle ad un opportuno oggetto o classe",
            correct: true,
            explanation: "Corretto. L'OOD in UP si concentra sull'identificazione delle responsabilit√† software e sulla loro assegnazione alle classi appropriate."
        },
        {
            id: 99,
            text: "La coesione √® la misura di quanto fortemente un elemento √® connesso ad altri elementi, ha conoscenza di altri elementi e dipende da altri elementi",
            correct: false,
            explanation: "Questa √® la definizione di ACCOPPIAMENTO. La coesione misura quanto le responsabilit√† di un singolo elemento sono correlate tra loro."
        },
        {
            id: 100,
            text: "Il pattern GRASP Information Expert e High Cohesion sono pattern valutativi",
            correct: false,
            explanation: "Low Coupling e High Cohesion sono pattern GRASP valutativi che forniscono criteri per valutare la qualit√† delle soluzioni di design."
        },
        {
            id: 101,
            text: "La creazione di un oggetto √® di responsabilit√† di un oggetto che aggrega, contiene un'istanza dell'oggetto da creare",
            correct: true,
            explanation: "Corretto. Secondo il pattern GRASP Creator, la responsabilit√† di creare un oggetto spetta spesso a chi lo aggrega, contiene o usa intensivamente."
        },
        {
            id: 102,
            text: "Una classe con accoppiamento alto fa molte cose non correlate tra loro e svolge troppo lavoro",
            correct: false,
            explanation: "Questa √® la definizione di bassa COESIONE. L'alto accoppiamento indica molte dipendenze verso altre classi, non necessariamente molte responsabilit√†."
        },
        {
            id: 103,
            text: "Il refactoring √® una pratica promossa dal metodo iterativo e agile xp",
            correct: true,
            explanation: "Corretto. Il refactoring √® una delle pratiche fondamentali di XP (Extreme Programming) e dei metodi agili in generale."
        },
        {
            id: 104,
            text: "Il refactoring prevede lo sviluppo guidato dai test, ovvero uno sviluppo preceduto dai test",
            correct: false,
            explanation: "Il refactoring e il TDD sono pratiche SEPARATE. Il refactoring migliora il codice esistente, il TDD √® una tecnica di sviluppo guidata dai test."
        },
        {
            id: 105,
            text: "Il refactoring √® un metodo strutturato e disciplinato per scrivere o ristrutturare del codice esistente",
            correct: true,
            explanation: "Corretto. Il refactoring √® un processo disciplinato per ristrutturare codice esistente migliorandone la struttura senza cambiarne il comportamento."
        },
        {
            id: 106,
            text: "DURANTE LA FASE DI ELABORAZIONE: I requisiti e le iterazioni sono organizzati in base alla richiesta dell'utente finale",
            correct: false,
            explanation: "Durante l'elaborazione i requisiti sono organizzati in base a RISCHIO e CRITICIT√Ä ARCHITETTURALE, non alle richieste dell'utente finale."
        },
        {
            id: 107,
            text: "DURANTE LA FASE DI ELABORAZIONE: I requisiti e le iterazioni sono organizzati in base al rischio, copertura (devono coprire tutto il sistema) e criticit√†",
            correct: true,
            explanation: "Corretto. L'elaborazione organizza le iterazioni in base a rischio, criticit√† architetturale e necessit√† di coprire tutti gli aspetti del sistema."
        },
        {
            id: 108,
            text: "DURANTE LA FASE DI ELABORAZIONE: Si effettua attivit√† di programmazione di qualit√†-produzione e test",
            correct: true,
            explanation: "Corretto. Durante l'elaborazione si sviluppa codice di qualit√† produzione per il nucleo architetturale e si effettuano test appropriati."
        },
        {
            id: 109,
            text: "DURANTE LA FASE DI ELABORAZIONE: Vengono realizzati prototipi 'usa e getta' per ottenere i rischi maggiori",
            correct: false,
            explanation: "Durante l'elaborazione si sviluppa il nucleo architetturale EVOLUTIVO, non prototipi 'usa e getta'. I prototipi usa e getta sono tipici dell'ideazione."
        },
        {
            id: 110,
            text: "La responsabilit√† √® un'astrazione di ci√≤ che fa o rappresenta un oggetto o un componente software",
            correct: true,
            explanation: "Corretto. La responsabilit√† √® un'astrazione di ci√≤ che un oggetto SA (knowing) o FA (doing)."
        },
        {
            id: 111,
            text: "Nel Responsibility-Driven Development gli oggetti software sono considerati come dotati di responsabilit√†",
            correct: true,
            explanation: "Corretto. Il RDD (Responsibility-Driven Development) vede gli oggetti come entit√† che hanno responsabilit√† specifiche nel sistema."
        },
        {
            id: 112,
            text: "La disciplina dei requisiti √® il processo per scoprire cosa deve essere costruito",
            correct: true,
            explanation: "Corretto. La disciplina dei requisiti in UP ha l'obiettivo di scoprire, documentare e validare cosa il sistema deve fare."
        },
        {
            id: 113,
            text: "La disciplina dei requisiti deve orientare lo sviluppo verso il sistema corretto",
            correct: true,
            explanation: "Corretto. La disciplina dei requisiti assicura che si sviluppi il sistema GIUSTO (quello che soddisfa realmente i bisogni degli utenti)."
        },
        {
            id: 114,
            text: "I contratti usano pre-condizioni e post-condizioni per descrivere nel dettaglio i cambiamenti agli oggetti in un modello di progetto (software)",
            correct: false,
            explanation: "I contratti descrivono cambiamenti agli oggetti del MODELLO DI DOMINIO (concettuali), non del modello di progetto (software)."
        },
        {
            id: 115,
            text: "Le operazioni di sistema possono essere identificate mentre si abbozzano gli DSD",
            correct: false,
            explanation: "Le operazioni di sistema vengono identificate prima, durante l'abbozzo degli SSD, e non dei DSD. I DSD mostrano come tali operazioni vengono realizzate internamente."
        },
        {
            id: 116,
            text: "Nella fase di Analisi dei Requisiti, la prima attivit√† consiste nel tradurre le informazioni raccolte in un documento che definisce un insieme di requisiti.",
            correct: false,
            explanation: "La prima fase principale dell'Analisi dei Requisiti √® la Deduzione e analisi dei requisiti; la Specifica dei requisiti, che consiste nel tradurre le informazioni in un documento, viene successivamente."
        },
        {
            id: 117,
            text: "Nelle metodologie agili, la progettazione e l'implementazione del software sono solitamente separate e producono documenti formali dettagliati prima della codifica.",
            correct: false,
            explanation: "Nelle metodologie agili, la progettazione e l'implementazione sono intrecciate e non producono documenti formali; il progetto √® spesso registrato informalmente."
        },
        {
            id: 118,
            text: "L'Unified Process (UP) √® una metodologia di sviluppo software che segue un approccio strettamente sequenziale e a cascata.",
            correct: false,
            explanation: "UP incoraggia uno sviluppo iterativo e guidato dal rischio. La programmazione e il test iniziano prima che l'analisi di tutti i requisiti sia completata."
        },
        {
            id: 119,
            text: "Lo scopo principale della fase di Ideazione in UP √® quello di definire tutti i requisiti dettagliati del progetto e generare una stima affidabile dei costi.",
            correct: false,
            explanation: "Lo scopo della fase di ideazione non √® quello di definire tutti i requisiti, n√© di generare una stima o un piano di progetto affidabili. Si tratta piuttosto di decidere se il progetto merita un'indagine pi√π seria."
        },
        {
            id: 120,
            text: "Il documento Visione in UP riassume i requisiti di alto livello ed √® utile per stabilire una visione comune del progetto tra i partecipanti.",
            correct: true,
            explanation: "Il documento Visione riassume alcune informazioni contenute nel modello dei casi d'uso e nelle specifiche supplementari, descrivendo brevemente il progetto come contesto per i partecipanti e stabilendo una visione comune."
        },
        {
            id: 121,
            text: "In UP, il Glossario ha anche la funzione di dizionario dei dati, includendo informazioni relative ad altri dati (metadati), come le regole di validazione.",
            correct: true,
            explanation: "In UP, il Glossario svolge anche il ruolo di un dizionario di dati, un documento dati relativi ad altri dati, ovvero metadati, inclusi esempi di regole di validazione."
        },
        {
            id: 122,
            text: "La Disciplina dei Requisiti in UP si concentra principalmente sul 'come' il sistema deve essere costruito, definendo le soluzioni tecniche e architetturali.",
            correct: false,
            explanation: "La Disciplina dei Requisiti √® il processo per scoprire 'cosa' deve essere costruito e orientare lo sviluppo verso il sistema corretto, definendo le capacit√† e condizioni a cui il sistema deve essere conforme."
        },
        {
            id: 123,
            text: "Secondo le fonti, i casi d'uso in UP sono principalmente rappresentati da diagrammi UML per visualizzare le interazioni tra attori e sistema.",
            correct: false,
            explanation: "I casi d'uso in UP sono descrizioni testuali di scenari di uso interessanti del sistema software. Le fonti specificano chiaramente che i casi d'uso sono documenti testuali, non diagrammi."
        },
        {
            id: 124,
            text: "Un Attore Primario in un caso d'uso √® colui che offre un servizio al sistema.",
            correct: false,
            explanation: "L'Attore Primario √® colui che raggiunge gli obiettivi utente utilizzando i servizi del sistema. L'attore di supporto √® colui che offre un servizio al sistema."
        },
        {
            id: 125,
            text: "Nel formato dettagliato di un caso d'uso, la sezione 'Estensioni' √® utilizzata per descrivere scenari alternativi, sia di successo che di fallimento, rispetto allo scenario principale.",
            correct: true,
            explanation: "Le Estensioni descrivono scenari alternativi, di successo o di fallimento, e la loro gestione."
        },
        {
            id: 126,
            text: "Quando si scrive un caso d'uso in stile essenziale, √® fondamentale includere dettagli precisi sull'interfaccia utente (GUI) con cui l'attore interagisce.",
            correct: false,
            explanation: "Lo stile essenziale implica ignorare l'interfaccia utente e concentrarsi sull'obiettivo utente e le responsabilit√† del sistema a un livello astratto, indipendente dai dettagli tecnologici e di UI."
        },
        {
            id: 127,
            text: "L'approccio Black-box nella scrittura dei casi d'uso significa descrivere esattamente 'come' il sistema esegue una determinata azione, inclusi dettagli implementativi come l'uso di database o istruzioni SQL.",
            correct: false,
            explanation: "L'approccio Black-box significa descrivere 'che cosa' il sistema deve fare (comportamento o requisiti funzionali) senza decidere come."
        },
        {
            id: 128,
            text: "Per verificare l'utilit√† di un caso d'uso, il Test del capo chiede se l'attivit√† descritta rappresenta un'azione significativa per l'utente che giustifichi lo sforzo di implementazione.",
            correct: true,
            explanation: "Il Test del capo implica chiedersi se un capo sarebbe contento se il lavoro di un giorno fosse solo l'attivit√† descritta nel caso d'uso; se la risposta √® no, il caso d'uso non √® utile."
        },
        {
            id: 129,
            text: "Il Modello di Dominio rappresenta i concetti chiave del sistema come oggetti software con nomi e informazioni simili al dominio del mondo reale.",
            correct: false,
            explanation: "Il Modello di Dominio √® uno strumento di analisi che rappresenta i concetti del mondo reale (classi concettuali) in modo indipendente dall'implementazione software, mentre gli oggetti software con nomi simili al dominio vengono creati in una fase successiva (progettazione e implementazione) e rappresentati, ad esempio, nel Modello di Progetto (tramite DCD), ispirandosi al Modello di Dominio."
        },
        {
            id: 130,
            text: "I Diagrammi di Sequenza di Sistema (SSD) mostrano le interazioni tra gli oggetti interni del sistema per realizzare un'operazione.",
            correct: false,
            explanation: "Il Diagramma di Sequenza di Sistema serve a rappresentare gli eventi di input e output che coinvolgono il sistema durante un'interazione con gli attori esterni, vedendo il sistema come una scatola nera."
        },
        {
            id: 131,
            text: "I Contratti delle operazioni di sistema descrivono in dettaglio 'come' vengono realizzati i cambiamenti nello stato del sistema dopo l'esecuzione di un'operazione.",
            correct: false,
            explanation: "Un contratto descrive in modo molto dettagliato i cambiamenti richiesti dall'esecuzione di una operazione di sistema senza per√≤ descrivere come devono essere ottenuti."
        },
        {
            id: 132,
            text: "Un'operazione di sistema di Interrogazione modifica lo stato del sistema e per questo motivo deve avere delle post-condizioni nel suo contratto.",
            correct: false,
            explanation: "Un'operazione di sistema di Interrogazione non modifica lo stato del sistema, si limita a calcolare e restituire un valore, e per questo non ha post-condizioni. Le post-condizioni descrivono i cambiamenti nello stato degli oggetti."
        },
        {
            id: 133,
            text: "La progettazione orientata agli oggetti (OOD) pone l'enfasi sulla definizione degli oggetti software e sul modo in cui questi collaborano per soddisfare i requisiti.",
            correct: true,
            explanation: "La progettazione orientata agli oggetti pone l'enfasi sulla definizione di oggetti software e del modo in cui questi collaborano per soddisfare i requisiti."
        },
        {
            id: 134,
            text: "I pattern GRASP sono un repertorio di soluzioni progettuali specifiche per problemi ricorrenti nell'implementazione di software, simili ai pattern GoF.",
            correct: false,
            explanation: "I pattern GRASP sono principi per l'assegnazione di responsabilit√†. I pattern GoF sono descrizioni con nome di problemi di progettazione ricorrenti e di una soluzione."
        },
        {
            id: 135,
            text: "Secondo il pattern GRASP Information Expert, una responsabilit√† dovrebbe essere assegnata alla classe che possiede le informazioni necessarie per soddisfarla.",
            correct: true,
            explanation: "Il pattern Information Expert suggerisce di assegnare una responsabilit√† alla classe che possiede le informazioni necessarie per soddisfarla, all'esperto delle informazioni."
        },
        {
            id: 136,
            text: "I test unitari sono un tipo di test progettato per verificare il sistema software completo, considerando le interazioni tra tutti i componenti principali.",
            correct: false,
            explanation: "I test unitari testano singole unit√† di codice. I test di integrazione testano la comunicazione tra specifiche parti, mentre i test end-to-end testano l'intero sistema."
        },
        {
            id: 137,
            text: "Nella metodologia eXtreme Programming, i test vengono scritti prima di scrivere il codice corrispondente (sviluppo guidato dai test).",
            correct: true,
            explanation: "In alcune metodologie agili come l'eXtreme Programming, si scrivono i test prima di scrivere il codice."
        },
        {
            id: 138,
            text: "Nel modello a cascata, si presume che i requisiti siano prevedibili e stabili fin dall'inizio con un basso tasso di cambiamenti.",
            correct: true,
            explanation: "Il modello a cascata parte dal presupposto che le specifiche sono prevedibili e stabili e possono essere definite correttamente sin dall'inizio, a fronte di un basso tasso di cambiamenti."
        },
        {
            id: 139,
            text: "Secondo le fonti, i metodi di sviluppo iterativi sono statisticamente associati a percentuali di successo pi√π basse rispetto al modello a cascata.",
            correct: false,
            explanation: "In base a dati statistici, i metodi iterativi sono associati a percentuali di successo e di produttivit√† pi√π elevate, nonch√© a livelli minori di difetti. Al contrario, l'approccio a cascata √® caratterizzato da una minore produttivit√† e da maggiori percentuali di difetti."
        },
        {
            id: 140,
            text: "Uno dei motivi principali per cui i requisiti cambiano √® l'impossibilit√† per i clienti di prevedere appieno come un sistema influenzer√† le pratiche operative prima che sia consegnato e utilizzato.",
            correct: true,
            explanation: "I requisiti cambiano perch√© per i clienti √® impossibile prevedere come un sistema influenzer√† le pratiche operative, come interagir√† con gli altri sistemi e quali operazioni degli utenti dovranno essere automatizzate; i requisiti reali diventano chiari solo dopo che il sistema √® stato consegnato e utilizzato."
        },
        {
            id: 141,
            text: "In Unified Process (UP), la Disciplina dei Requisiti √® un insieme di attivit√† che si svolgono esclusivamente all'inizio del progetto, prima di qualsiasi altra disciplina.",
            correct: false,
            explanation: "In UP, le discipline (tipologie di attivit√†) non sono sequenziali e si eseguono nel progetto in ogni iterazione. La Disciplina dei Requisiti √® il processo per scoprire \"cosa\" deve essere costruito e orientare lo sviluppo verso il sistema corretto."
        },
        {
            id: 142,
            text: "Secondo UP, √® necessario definire il 100% dei requisiti dettagliati prima di iniziare qualsiasi attivit√† di programmazione o test.",
            correct: false,
            explanation: "In UP si iniziano programmazione e test quando √® stato specificato solo il 10% o il 20% dei requisiti pi√π significativi. Inoltre, non si cerca di definire tutti i requisiti prima di iniziare la progettazione o l'implementazione."
        },
        {
            id: 143,
            text: "Il documento Specifiche Supplementari in UP √® destinato a contenere tutti i requisiti funzionali del sistema, inclusi quelli descritti nei casi d'uso.",
            correct: false,
            explanation: "Le Specifiche Supplementari contengono ci√≤ che non rientra nei casi d'uso, come requisiti non funzionali o funzionali non esprimibili attraverso casi d'uso. I requisiti funzionali principali sono descritti nel Modello dei Casi d'Uso."
        },
        {
            id: 144,
            text: "Durante la fase di Ideazione in UP, l'obiettivo √® analizzare in dettaglio la maggior parte dei casi d'uso per ottenere una comprensione completa dei requisiti funzionali.",
            correct: false,
            explanation: "Durante l'ideazione si analizzano circa il 10% dei casi d'uso in dettaglio. Lo scopo dell'Ideazione non √® raccogliere tutti i requisiti, ma capire se il progetto merita un'indagine pi√π seria (fattibilit√†)."
        },
        {
            id: 145,
            text: "Nel contesto di UP, l'Agile Modeling suggerisce che il valore della modellazione risiede principalmente nella creazione di documenti di specifiche affidabili e completi.",
            correct: false,
            explanation: "L'Agile Modeling suggerisce che il valore della modellazione √® quello di migliorare la comprensione, anzich√© quello di documentare delle specifiche affidabili."
        },
        {
            id: 146,
            text: "Un Attore di Supporto in un caso d'uso √® colui che utilizza il sistema per raggiungere i propri obiettivi utente.",
            correct: false,
            explanation: "L'Attore di Supporto √® colui che offre un servizio al sistema. L'Attore Primario √® colui che raggiunge gli obiettivi utente utilizzando i servizi del sistema."
        },
        {
            id: 147,
            text: "Quando si scrive un caso d'uso in stile essenziale, la descrizione si concentra sulle azioni concrete dell'utente e i dettagli specifici dell'interfaccia utente.",
            correct: false,
            explanation: "Lo stile essenziale implica che la narrativa √® espressa a livello di intenzioni e responsabilit√†, ignorando l'interfaccia utente e rimanendo indipendente dai dettagli tecnologici."
        },
        {
            id: 148,
            text: "Il \"Test EBP\" (Elementary Business Process) per verificare l'utilit√† di un caso d'uso chiede se l'attivit√† descritta dal caso d'uso aggiunge un valore di business misurabile.",
            correct: true,
            explanation: "Un processo di business elementare √® un'attivit√† che aggiunge un valore di business misurabile. Il Test EBP valuta se il caso d'uso rappresenta una interazione di valore."
        },
        {
            id: 149,
            text: "Un caso d'uso dettagliato, per superare il Test della Dimensione, dovrebbe idealmente essere descritto in una singola pagina.",
            correct: false,
            explanation: "Per superare il Test della Dimensione, un caso d'uso dettagliato normalmente comprende diversi passi e richiede da 3 a 10 pagine di testo. Una singola azione o passo raramente costituisce un caso d'uso utile."
        },
        {
            id: 150,
            text: "Il Modello di Dominio ha lo scopo di descrivere i concetti chiave del dominio del problema e le loro relazioni, servendo anche come ispirazione per le classi del software.",
            correct: true,
            explanation: "Il Modello di Dominio descrive i concetti significativi del sistema come oggetti del dominio e relaziona i concetti. Serve a comprendere il dominio e il suo vocabolario, definire un linguaggio comune, ed √® una fonte di ispirazione per l'OOD, riducendo il \"gap di rappresentazione\"."
        },
        {
            id: 151,
            text: "In un diagramma delle classi UML che rappresenta un Modello di Dominio, le associazioni dovrebbero indicare la direzione di navigabilit√† tra le classi software.",
            correct: false,
            explanation: "Le associazioni in un modello di dominio sono per natura bidirezionali. La direzione di lettura (indicata opzionalmente) non √® una specifica di visibilit√† o navigabilit√† tra entit√† software."
        },
        {
            id: 152,
            text: "I Diagrammi di Sequenza di Sistema (SSD) mostrano l'ordine e la logica delle interazioni tra gli oggetti interni del sistema software.",
            correct: false,
            explanation: "I Diagrammi di Sequenza di Sistema servono a rappresentare gli eventi di input e output che coinvolgono il sistema durante un'interazione con gli attori esterni, vedendo il sistema come una scatola nera. I diagrammi di sequenza (non di sistema) mostrano le interazioni tra gli oggetti interni."
        },
        {
            id: 153,
            text: "Le post-condizioni in un contratto descrivono le azioni che il sistema deve eseguire per soddisfare l'operazione, come istruzioni di database o chiamate a metodi specifici.",
            correct: false,
            explanation: "Un contratto descrive i cambiamenti richiesti dall'esecuzione di una operazione di sistema in termini di oggetti del Modello di Dominio, senza per√≤ descrivere come devono essere ottenuti. Le post-condizioni descrivono lo stato degli oggetti dopo l'operazione, non le azioni per arrivarci."
        },
        {
            id: 154,
            text: "Un'operazione di sistema di \"Trasformazione\" non modifica lo stato del sistema e per questo non richiede post-condizioni nel suo contratto.",
            correct: false,
            explanation: "Un'operazione di sistema di Trasformazione modifica lo stato del sistema e per questo motivo dovrebbe avere delle post-condizioni che descrivono tali modifiche. Le operazioni di Interrogazione non modificano lo stato e non hanno post-condizioni."
        },
        {
            id: 155,
            text: "La Progettazione Orientata agli Oggetti (OOD) si concentra principalmente sulla definizione di oggetti software e su come questi dovrebbero collaborare per soddisfare i requisiti.",
            correct: true,
            explanation: "La progettazione orientata agli oggetti pone l'enfasi sulla definizione di oggetti software e del modo in cui questi collaborano per soddisfare i requisiti."
        },
        {
            id: 156,
            text: "Secondo il principio GRASP \"Information Expert\", la responsabilit√† di salvare un oggetto nel database dovrebbe essere assegnata alla classe che rappresenta quell'oggetto (ad es. la classe Sale dovrebbe salvare se stessa).",
            correct: false,
            explanation: "In generale, l'Expert non si applica alla persistenza (salvataggio in DB) perch√© assegnare questa responsabilit√† alla classe stessa causerebbe problemi di bassa coesione (si occupa anche di persistenza), alto accoppiamento (legata a classi di sistema come i driver DB) e duplicazione logica. Questo principio architetturale di base suggerisce di separare diverse logiche in sottosistemi."
        },
        {
            id: 157,
            text: "Il pattern GoF Strategy consente di definire una famiglia di algoritmi e di renderli intercambiabili, permettendo ai clienti di utilizzare diversi algoritmi in modo indipendente.",
            correct: true,
            explanation: "Il pattern Strategy consente la definizione di una famiglia d'algoritmi, incapsula ognuno e gli fa intercambiabili fra di loro. Permette di modificare gli algoritmi in modo indipendente dai clienti e disaccoppia gli algoritmi dai clienti."
        },
        {
            id: 158,
            text: "Il pattern GoF Iterator espone la struttura interna di una collezione per permettere al chiamante di accedere e percorrere i suoi elementi.",
            correct: false,
            explanation: "Il pattern Iterator suggerisce l'implementazione di un oggetto che consenta l'accesso e percorso della collezione, fornendo una interfaccia standard che nasconde la struttura interna."
        },
        {
            id: 159,
            text: "Nel pattern GoF Visitor, il ConcreteVisitor √® l'oggetto che viene visitato dalla struttura dati.",
            correct: false,
            explanation: "Nel pattern Visitor, il ConcreteVisitor √® l'oggetto che percorre la collezione e applica un metodo specifico su ogni oggetto (Element) visitato. Gli oggetti della collezione (Element) sono quelli che vengono visitati."
        },
        {
            id: 160,
            text: "Il Modello-Vista (Model-View) Separation Principle suggerisce di separare gli oggetti che gestiscono la logica applicativa (Modello/Dominio) da quelli che gestiscono l'interfaccia utente (Vista/UI).",
            correct: true,
            explanation: "Il principio di separazione Modello-Vista stabilisce che il Modello (strato di dominio, oggetti con logica applicativa) e la Vista (strato UI, oggetti interfaccia utente) devono essere separati. Gli oggetti UI delegano le richieste di logica applicativa agli oggetti non UI (oggetti di dominio)."
        },
        {
            id: 161,
            text: "I test unitari hanno lo scopo di verificare il funzionamento complessivo del sistema software dal punto di vista dell'utente, considerando il sistema come una scatola nera.",
            correct: false,
            explanation: "I test unitari testano singole unit√† di codice, non il sistema nel suo complesso. I test di accettazione sono quelli che verificano il funzionamento complessivo del sistema a scatola nera dal punto di vista dell'utente, con riferimento ai casi d'uso."
        },
        {
            id: 162,
            text: "La fase di Verifica in un test unitario consiste nel preparare gli oggetti e le risorse necessarie per l'esecuzione del test.",
            correct: false,
            explanation: "La fase di Preparazione (Setup) crea l'oggetto o il gruppo di oggetti da verificare e prepara risorse. La fase di Verifica valuta se i risultati ottenuti corrispondono a quelli attesi."
        },
        {
            id: 163,
            text: "L‚Äôanalisi orientata agli oggetti √® guidata dalle responsabilit√†.",
            correct: false,
            explanation: "No, √® la progettazione orientata agli oggetti ad essere guidata dalle responsabilit√†."
        },
        {
            id: 164,
            text: "L‚Äôanalisi orientata agli oggetti considera un progetto software come una ‚Äúcomunit√† di oggetti‚Äù con responsabilit√† che collaborano.",
            correct: false,
            explanation: "No, √® la progettazione orientata agli oggetti che considera un progetto software come una ‚Äúcomunit√† di oggetti‚Äù con responsabilit√† che collaborano."
        },
        {
            id: 165,
            text: "Identificazione delle responsabilit√†, assegnazione di queste responsabilit√†, indagine di come soddisfare queste responsabilit√† sono i passi della ‚Äúresponsibility-driven development‚Äù.",
            correct: true,
            explanation: "Il Responsibility-Driven Development si basa esattamente su quei passaggi: identificare responsabilit√†, assegnarle agli oggetti e determinare come realizzarle."
        },
        {
            id: 166,
            text: "Controller, High Cohesion, Abstract Factory sono alcuni esempi di pattern GRASP.",
            correct: false,
            explanation: "Controller e High Cohesion fanno parte dei pattern GRASP, mentre Abstract Factory √® un pattern GoF, non GRASP."
        },
        {
            id: 167,
            text: "I pattern GRASP sono lo strumento principale utilizzato nella disciplina dei requisiti di UP.",
            correct: false,
            explanation: "I pattern GRASP vengono impiegati nella progettazione orientata agli oggetti, non come strumento principale per la raccolta dei requisiti in UP."
        },
        {
            id: 168,
            text: "UP organizza temporalmente il ciclo di sviluppo in quattro iterazioni e le iterazioni in diverse fasi.",
            correct: false,
            explanation: "In UP si parla di quattro fasi (ideazione, elaborazione, costruzione, transizione), ciascuna delle quali pu√≤ contenere pi√π iterazioni; non di quattro iterazioni complessive."
        },
        {
            id: 169,
            text: "Ideazione, elaborazione, costruzione e transizione di UP sono separate temporalmente e non si intrecciano mai.",
            correct: true,
            explanation: "Sono fasi distinte e non si intrecciano mai. "
        },
        {
            id: 170,
            text: "Specifica, sviluppo, convalida ed evoluzione in UP sono attivit√† separate temporalmente e non si intrecciano mai.",
            correct: false,
            explanation: "In UP le discipline (specifica, sviluppo, convalida, evoluzione, ecc.) avvengono in modo concorrente durante le iterazioni, non in sequenza isolata."
        },
        {
            id: 171,
            text: "Durante lo sviluppo tramite UP non si fa uso di meccanismi di refactoring per far fronte ai cambiamenti.",
            correct: false,
            explanation: "UP incoraggia il refactoring continuo all‚Äôinterno delle iterazioni per gestire i cambiamenti in modo iterativo."
        },
        {
            id: 172,
            text: "Modellazione del business, requisiti, progettazione, implementazione, test, rilascio in UP sono separate temporalmente e non si intrecciano mai.",
            correct: false,
            explanation: "Le discipline di UP (modellazione del business, requisiti, progettazione, implementazione, test, rilascio, ecc.) si svolgono in parallelo all‚Äôinterno di ciascuna iterazione, non in fasi separate."
        },
        {
            id: 173,
            text: "Il test-driven development √® una pratica promossa dal metodo a cascata che prevede lo sviluppo preceduto dai test.",
            correct: false,
            explanation: "Il TDD √® nato nell‚Äôambito dell‚ÄôExtreme Programming, non nel modello a cascata."
        },
        {
            id: 174,
            text: "I test unitari hanno lo scopo di verificare la comunicazione tra specifiche parti del sistema.",
            correct: false,
            explanation: "I test unitari verificano il corretto funzionamento di singole unit√† di codice, non la comunicazione tra moduli."
        },
        {
            id: 175,
            text: "I test unitari hanno lo scopo di verificare il collegamento complessivo tra tutti gli elementi del sistema.",
            correct: false,
            explanation: "Il test unitario controlla componenti isolate; verificare il collegamento complessivo √® compito dei test di integrazione o di sistema."
        },
        {
            id: 176,
            text: "I test unitari si compongono di preparazione, esecuzione, verifica e rilascio.",
            correct: true,
            explanation: "Un tipico ciclo di un test unitario include setup (preparazione), esecuzione, assertion (verifica) e teardown (rilascio)."
        },
        {
            id: 177,
            text: "Il test-driven development e il refactoring sono pratiche promosse in particolar modo dallo sviluppo noto come extreme programming.",
            correct: true,
            explanation: "TDD e refactoring sono due pratiche cardine dell‚ÄôExtreme Programming."
        },
        {
            id: 178,
            text: "Il pattern Strategy si occupa del modo in cui un oggetto esegue un determinato compito ed incapsula un algoritmo.",
            correct: true,
            explanation: "Strategy definisce una famiglia di algoritmi intercambiabili e la scelta del comportamento √® delegata a classi diverse che incapsulano ciascun algoritmo."
        },
        {
            id: 179,
            text: "Il pattern State si occupa del modo in cui un oggetto esegue un determinato compito ed incapsula un algoritmo.",
            correct: false,
            explanation: "State incapsula stati diversi di un oggetto e cambia comportamento in base allo stato, non in base a algoritmi intercambiabili."
        },
        {
            id: 180,
            text: "Il pattern State consente la definizione di una famiglia di algoritmi, intercambiabili tra loro.",
            correct: false,
            explanation: "La definizione di una famiglia di algoritmi intercambiabili √® caratteristica del pattern Strategy, non dello State."
        },
        {
            id: 181,
            text: "Il pattern State disaccoppia gli algoritmi dei clienti che vogliono usarli dinamicamente.",
            correct: false,
            explanation: "Disaccoppiare algoritmi e clienti √® compito del pattern Strategy; State disaccoppia invece il comportamento in base allo stato interno."
        },
        {
            id: 182,
            text: "Il pattern State e il pattern Strategy sono sintatticamente equivalenti ma differiscono nell‚Äôapplicazione.",
            correct: false,
            explanation: "Sono sintatticamente diversi."
        },
        {
            id: 183,
            text: "Le caratteristiche essenziali di un software sono Mantenibilit√†, Fidatezza, Efficienza e Accettabilit√†.",
            correct: true,
            explanation: "Si, sono proprio loro."
        },
        {
            id: 184,
            text: "Un processo per lo sviluppo del software descrive un approccio disciplinato alla costruzione, rilascio ed eventualmente manutenzione del software. Ci sono quattro attivit√† fondamentali di processo: Specifiche, Sviluppo, Convalida e Evoluzione/manutenzione.",
            correct: true,
            explanation: "Si, sono proprio loro."
        },
        {
            id: 185,
            text: "La problematica maggiore durante lo sviluppo del software sono i cambiamenti (dovuti dal cliente, adeguamenti tecnici o di contesto).",
            correct: true,
            explanation: "Occupano del tempo, durante il quale non √® garantito che le cose rimangano invariate."
        },
        {
            id: 186,
            text: "Unified Process (UP) organizza il lavoro e le iterazioni in quattro fasi NON sequenziali. La fine di ogni fase corrisponde a una milestone: Ideazione, Elaborazione, Costruzione e Transizione.",
            correct: false,
            explanation: "Unified Process (UP) organizza il lavoro e le iterazioni in quattro fasi sequenziali. La fine di ogni fase corrisponde a una milestone: Ideazione, Elaborazione, Costruzione e Transizione."
        },
        {
            id: 187,
            text: "L‚Äôelaborazione √® la serie finale di iterazioni in cui si consolidano i requisiti e si sviluppa il nucleo dell'architettura del sistema.",
            correct: false,
            explanation: "L‚Äôelaborazione √® la serie INIZIALE di iterazioni in cui si consolidano i requisiti e si sviluppa il nucleo dell'architettura del sistema."
        },
        {
            id: 188,
            text: "Il modello di dominio √® una parte della fase dei requisiti che consiste in una rappresentazione testuale che descrive i concetti fondamentali di un sistema, mettendo in evidenza le entit√† principali del dominio e le loro relazioni.",
            correct: false,
            explanation: "Il modello di dominio √® una parte di modellazione del business che consiste in una rappresentazione visuale che descrive i concetti fondamentali di un sistema, mettendo in evidenza le entit√† principali del dominio e le loro relazioni. "
        },
        {
            id: 189,
            text: "Il Diagramma di Sequenza di Sistema (SSD) √® uno strumento della disciplina dei requisiti che serve a rappresentare gli eventi di input e output che coinvolgono il sistema durante un'interazione con gli attori esterni.",
            correct: true,
            explanation: "Definizione corretta."
        },
        {
            id: 190,
            text: "L‚Äôarchitettura a strati (layered architecture) suddivide un sistema complesso in un insieme di elementi software che, per quanto possibile, possano essere sviluppati e modificati ciascuno indipendentemente dagli altri.",
            correct: true,
            explanation: "Definizione corretta."
        },
        {
            id: 191,
            text: "I modelli statici descrivono il comportamento del sistema e le interazioni tra gli oggetti (ad esempio, con i diagrammi di sequenza).",
            correct: false,
            explanation: "I modelli dinamici descrivono il comportamento del sistema e le interazioni tra gli oggetti (ad esempio, con i diagrammi di sequenza)."
        },
        {
            id: 192,
            text: "I modelli dinamici rappresentano la struttura del sistema, definendo classi, attributi e relazioni (tipicamente attraverso i diagrammi delle classi).",
            correct: false,
            explanation: "I modelli statici rappresentano la struttura del sistema, definendo classi, attributi e relazioni (tipicamente attraverso i diagrammi delle classi)."
        },
        {
            id: 193,
            text: "I GRASP (General Responsibility Assignment Software Patterns) sono un insieme di pattern utilizzati per assegnare in modo efficace le responsabilit√† agli oggetti in un sistema Object Oriented.",
            correct: true,
            explanation: "Definizione corretta."
        },
        {
            id: 194,
            text: "I pattern GoF promuovono l‚Äôuso dell'ereditariet√† rispetto alla composizione, in quanto la composizione evita i problemi di dipendenza.",
            correct: false,
            explanation: "I pattern GoF promuovono l‚Äôuso della composizione rispetto all‚Äôereditariet√†, in quanto la composizione evita i problemi di dipendenza."
        },
        {
            id: 195,
            text: "I test end-to-end verificano il funzionamento delle piccole parti (unit√†) del sistema.",
            correct: false,
            explanation: "I test end-to-end verificano il collegamento complessivo tra tutti gli elementi del sistema."
        },
        {
            id: 196,
            text: "Il refactoring √® un metodo strutturato e disciplinato per scrivere o ristrutturare del codice esistente modificando il comportamento esterno.",
            correct: false,
            explanation: "Il refactoring √® un metodo strutturato e disciplinato per scrivere o ristrutturare del codice esistente senza per√≤ modificare il comportamento esterno."
        },
        {
            id: 197,
            text: "I test unitari verificano il funzionamento delle piccole parti (unit√†) del sistema. Un metodo di test unitario √® logicamente composto da quattro parti: Preparazione, Esecuzione, Verifica e Rilascio.",
            correct: true,
            explanation: "I test unitari verificano il funzionamento delle piccole parti (unit√†) del sistema. Un metodo di test unitario √® logicamente composto da quattro parti: Preparazione, Esecuzione, Verifica e Rilascio."
        },
        {
            id: 198,
            text: "L‚Äôarchitettura logica di un sistema software √® la macro-organizzazione su larga scala delle classi software in package, sottoinsiemi e strati.",
            correct: true,
            explanation: "Definizione corretta."
        },
        {
            id: 199,
            text: "Nei contratti le pre-condizioni definiscono lo stato del sistema necessario affinch√© un‚Äôoperazione possa essere eseguita mentre le post-condizioni descrivono gli effetti dell‚Äôoperazione sul modello di dominio.",
            correct: true,
            explanation: "Definizione corretta."
        }

    ];

    function renderTheoryQuestion(question, state) {
        return `
            <div class="question-card" data-question-id="${question.id}">
                <div class="question-number">Domanda ${state.currentQuestionIndex + 1}</div>
                <div class="question-text">${question.text}</div>
                <div class="options true-false">
                    <div class="option" data-answer="true">‚úì Vero</div>
                    <div class="option" data-answer="false">‚úó Falso</div>
                </div>
                <div class="explanation hidden">
                    <h4>Spiegazione:</h4>
                    <p>${question.explanation}</p>
                </div>
            </div>
        `;
    }

    function getQueryParam(param) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(param);
    }
    
    let questionsToLoad = shuffleArray(originalQuestions);
    const numQuestionsRequestedStr = getQueryParam('numQuestions');

    if (numQuestionsRequestedStr && numQuestionsRequestedStr !== 'all') {
        const count = parseInt(numQuestionsRequestedStr, 10);
        if (!isNaN(count) && count > 0) {
            questionsToLoad = questionsToLoad.slice(0, count);
        }
    }

    initializeQuiz(questionsToLoad, renderTheoryQuestion);
});
</script>
</body>
</html>