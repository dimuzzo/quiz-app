<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz SAS - Architettura Software e Sistemi</title>
    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#ffffff">

    <style>
        /* Reset e Stili di Base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
        }
        .container {
            max-width: 900px;
            width: 100%;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(12px);
            border-radius: 24px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .header {
            background: linear-gradient(135deg, #4f46e5, #06b6d4);
            color: white;
            padding: 40px;
            text-align: center;
            position: relative;
        }
        .header h1 { font-size: 2.5rem; font-weight: 700; }
        .header p { font-size: 1.1rem; opacity: 0.9; margin-top: 5px; }
        .back-link {
            position: absolute; top: 20px; left: 20px; color: #cbd5e1;
            text-decoration: none; font-size: 0.95rem; transition: color 0.2s ease;
        }
        .back-link:hover { color: white; }

        .progress-section {
            padding: 20px 40px; background: #f8fafc;
            border-bottom: 1px solid #e2e8f0; transition: opacity 0.3s ease-in-out;
        }
        .progress-bar {
            width: 100%; height: 8px; background: #e2e8f0;
            border-radius: 4px; overflow: hidden; margin-bottom: 10px;
        }
        .progress-fill {
            height: 100%; background: linear-gradient(90deg, #4f46e5, #06b6d4);
            width: 0%; transition: width 0.4s cubic-bezier(0.25, 1, 0.5, 1); border-radius: 4px;
        }
        .progress-text-container {
            display: flex; justify-content: space-between; align-items: center;
            flex-wrap: wrap; gap: 10px; margin-top: 10px; margin-bottom: 15px;
        }
        .progress-text { font-weight: 600; color: #475569; }
        .question-jump-section { display: flex; align-items: center; gap: 8px; }
        .question-jump-section label { font-weight: 500; color: #475569; font-size: 0.9rem; }
        #questionJump {
            padding: 6px 10px; border-radius: 6px; border: 1px solid #cbd5e1;
            background-color: white; font-family: 'Inter', sans-serif;
            font-size: 0.9rem; cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        #questionJump:focus {
            outline: none; border-color: #4f46e5; box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.2);
        }
        .question-map {
            display: flex; flex-wrap: wrap; gap: 6px;
            padding-top: 10px; border-top: 1px solid #e2e8f0; margin-top: 10px;
        }
        .question-marker {
            width: 28px; height: 28px; border: 1px solid #d1d5db;
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 0.8rem; font-weight: 600; color: #4b5563;
            cursor: pointer; background-color: #f9fafb; transition: all 0.2s ease-in-out;
        }
        .question-marker:hover { border-color: #6366f1; background-color: #eef2ff; color: #4338ca;}
        .question-marker.current {
            border-color: #4f46e5; background-color: #4f46e5; color: white;
            transform: scale(1.15); box-shadow: 0 2px 8px rgba(79, 70, 229, 0.3);
        }
        .question-marker.answered { background-color: #e5e7eb; border-color: #9ca3af; color: #374151;}
        .question-marker.correct { background-color: #10b981; color: white; border-color: #059669;}
        .question-marker.incorrect { background-color: #ef4444; color: white; border-color: #dc2626;}

        .quiz-content { padding: 40px; flex-grow: 1; transition: opacity 0.3s ease-in-out; }
        .question-card {
            background: white; border-radius: 16px; padding: 35px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05); border: 1px solid #f1f5f9;
            animation: fadeInQuestion 0.5s forwards;
        }
        @keyframes fadeInQuestion { /* Rinominato per evitare conflitti se presente altrove */
            from { opacity: 0; transform: translateY(15px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .question-number {
            display: inline-block; background: linear-gradient(135deg, #4f46e5, #06b6d4);
            color: white; padding: 8px 16px; border-radius: 20px;
            font-weight: 600; font-size: 0.9rem; margin-bottom: 20px;
        }
        .question-text { font-size: 1.15rem; line-height: 1.6; color: #1e293b; margin-bottom: 25px; }
        .options { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .option {
            padding: 15px 25px; border: 2px solid #e2e8f0; border-radius: 12px;
            background: white; cursor: pointer; transition: all 0.2s ease;
            font-weight: 500; text-align: center;
        }
        .option:not(.selected):not(.correct):not(.incorrect):hover {
            border-color: #4f46e5; transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(79, 70, 229, 0.1);
        }
        .option.selected {
            border-color: #4f46e5; background: linear-gradient(135deg, #4f46e5, #06b6d4);
            color: white; box-shadow: 0 6px 20px rgba(79, 70, 229, 0.2);
        }
        .option.correct {
            border-color: #10b981; background: linear-gradient(135deg, #10b981, #059669); color: white;
        }
        .option.incorrect {
            border-color: #ef4444; background: linear-gradient(135deg, #ef4444, #dc2626); color: white;
        }
        .option.disabled { cursor: not-allowed; opacity: 0.7; }
        .explanation {
            margin-top: 25px; padding: 20px; background: #f1f5f9;
            border-radius: 10px; border-left: 4px solid #4f46e5; animation: fadeInQuestion 0.5s 0.2s forwards;
        }
        .explanation h4 { color: #4f46e5; margin-bottom: 10px; }
        .explanation p { color: #475569; line-height: 1.6; }

        .controls {
            padding: 30px 40px; background: #f8fafc; border-top: 1px solid #e2e8f0;
            display: flex; justify-content: space-between; align-items: center;
            flex-wrap: wrap; gap: 15px;
        }
        .btn {
            padding: 12px 28px; border: none; border-radius: 10px;
            font-weight: 600; cursor: pointer; transition: all 0.2s ease; font-size: 0.95rem;
        }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background: linear-gradient(135deg, #4f46e5, #06b6d4); color: white; }
        .btn-secondary { background: #e2e8f0; color: #475569; }
        .btn-danger { background: linear-gradient(135deg, #ef4444, #b91c1c); color: white; }
        .current-stats {
            display: flex; gap: 20px; font-weight: 600; color: #475569;
            flex-grow: 1; justify-content: center;
        }
        .current-stats span { display: flex; align-items: center; gap: 5px; }
        .current-stats .correct-count { color: #10b981; }
        .current-stats .incorrect-count { color: #ef4444; }

        .results { text-align: center; padding: 60px 40px; }
        .score-circle {
            width: 150px; height: 150px; border-radius: 50%; display: flex;
            align-items: center; justify-content: center; margin: 0 auto 30px;
        }
        .score-inner {
            width: 120px; height: 120px; background: white; border-radius: 50%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .score-percentage { font-size: 2.2rem; font-weight: 700; color: #4f46e5; }
        .score-label { font-size: 0.9rem; color: #6b7280; margin-top: 5px; }
        .results h2 { font-size: 2rem; color: #1e293b; margin-bottom: 15px; }
        .results p { font-size: 1.1rem; color: #6b7280; margin-bottom: 30px; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 20px; margin: 40px 0; }
        .stat { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05); }
        .stat-value { font-size: 1.8rem; font-weight: 700; }
        #correctStat .stat-value { color: #10b981; }
        #incorrectStat .stat-value { color: #ef4444; }
        .stat-label { font-size: 0.9rem; color: #6b7280; margin-top: 5px; }

        .hidden { display: none !important; }

        @media (max-width: 768px) {
            body { padding: 0; }
            .container { border-radius: 0; min-height: 100vh; }
            .header { padding: 30px 20px; }
            .header h1 { font-size: 2rem; }
            .back-link { top: 15px; left: 15px; }
            .quiz-content, .controls, .progress-section { padding: 20px; }
            .options { grid-template-columns: 1fr; }
            .controls { flex-direction: column; gap: 15px; }
            .current-stats { width: 100%; justify-content: space-around; }
            .progress-text-container { flex-direction: column; align-items: flex-start; gap: 12px; }
            .question-jump-section { width: 100%; }
            #questionJump { flex-grow: 1; }
            .question-map { justify-content: center; }
        }
    </style>
</head>
<body>
<div class="container">
    <header class="header">
        <h1>Quiz SAS</h1>
        <p>Unified Process & Design Patterns</p>
        <a href="index.html" class="back-link">‚Üê Torna alla homepage</a>
    </header>

    <section class="progress-section" aria-live="polite">
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-text-container">
            <span class="progress-text">
                Domanda <span id="currentQuestion">1</span> di <span id="totalQuestions">0</span>
            </span>
            <div class="question-jump-section">
                <label for="questionJump">Vai a:</label>
                <select id="questionJump" aria-label="Salta alla domanda"></select>
            </div>
        </div>
        <div id="questionMap" class="question-map" role="navigation" aria-label="Mappa delle domande">
            </div>
    </section>

    <main class="quiz-content" id="quizContent">
        </main>

    <footer class="controls">
        <button class="btn btn-secondary" id="prevBtn">‚Üê Precedente</button>
        <button class="btn btn-danger" id="stopBtn">Ferma Quiz</button>
        <div class="current-stats">
            <span class="correct-count">Corrette: <span id="currentCorrectCount">0</span></span>
            <span class="incorrect-count">Sbagliate: <span id="currentIncorrectCount">0</span></span>
        </div>
        <div>
            <button class="btn btn-primary" id="showAnswerBtn">Mostra Risposta</button>
            <button class="btn btn-primary hidden" id="nextBtn">Successiva ‚Üí</button>
        </div>
    </footer>

    <section class="results hidden" id="results" aria-live="assertive">
        <div class="score-circle" id="scoreCircle">
            <div class="score-inner">
                <div class="score-percentage" id="scorePercentage">0%</div>
                <div class="score-label">Punteggio Totale</div>
            </div>
        </div>
        <h2>Quiz Terminato!</h2>
        <p>Ecco il riepilogo della tua sessione.</p>

        <div class="stats">
            <div class="stat" id="correctStat">
                <div class="stat-value">0</div>
                <div class="stat-label">Corrette (su Totali)</div>
            </div>
            <div class="stat" id="incorrectStat">
                <div class="stat-value">0</div>
                <div class="stat-label">Sbagliate (su Totali)</div>
            </div>
            <div class="stat" id="answeredCorrectStat">
                <div class="stat-value">0 / 0</div>
                <div class="stat-label">Corrette / Date</div>
            </div>
            <div class="stat" id="answeredIncorrectStat">
                <div class="stat-value">0 / 0</div>
                <div class="stat-label">Sbagliate / Date</div>
            </div>
        </div>

        <button class="btn btn-primary" id="restartBtn">
            üîÑ Ricomincia Quiz
        </button>
    </section>
</div>

<script>
    function getQueryParam(param) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(param);
    }

    // Quiz questions with correct answers and explanations
    const originalQuestions = [
        {
            id: 1,
            text: "In UP, la disciplina dei requisiti ha l'obiettivo di produrre una lista dei requisiti, capire il contesto del sistema, catturare i requisiti funzionali e i requisiti non-funzionali",
            correct: true,
            explanation: "La disciplina dei requisiti in UP ha effettivamente come obiettivi principali: produrre una lista dei requisiti, comprendere il contesto del sistema, e catturare sia i requisiti funzionali che non-funzionali."
        },
        {
            id: 2,
            text: "Il modello di dominio include la definizione di oggetti, associazioni e attributi di classi software",
            correct: false,
            explanation: "Il modello di dominio rappresenta classi CONCETTUALI del dominio del problema, non classi software. Include oggetti concettuali, associazioni e attributi del mondo reale."
        },
        {
            id: 3,
            text: "Il modello di dominio √® un dizionario visuale delle classi concettuali",
            correct: true,
            explanation: "Corretto. Il modello di dominio √® una rappresentazione visuale (dizionario visuale) delle classi concettuali rilevanti nel dominio del problema."
        },
        {
            id: 4,
            text: "Il modello di dominio √® una rappresentazione testuale delle classi concettuali, oggetti reali del dominio",
            correct: false,
            explanation: "Il modello di dominio √® una rappresentazione VISUALE (non testuale) delle classi concettuali. Utilizza diagrammi UML per rappresentare graficamente i concetti."
        },
        {
            id: 5,
            text: "Il modello di dominio non √® parte della disciplina dei requisiti",
            correct: true,
            explanation: "Il modello di dominio √® parte della disciplina di Modellazione del Business in UP. Aiuta a comprendere e documentare i concetti del dominio del problema."
        },
        {
            id: 6,
            text: "Nelle associazioni nel modello di dominio la direzione di lettura va sempre specificata",
            correct: false,
            explanation: "La direzione di lettura nelle associazioni del modello di dominio NON va sempre specificata. √à opzionale e si usa solo quando serve chiarire il significato dell'associazione."
        },
        {
            id: 7,
            text: "L'associazione nel modello di dominio √® per sua natura unidirezionale",
            correct: false,
            explanation: "Le associazioni nel modello di dominio sono per natura BIDIREZIONALI. Rappresentano relazioni concettuali che possono essere navigate in entrambe le direzioni."
        },
        {
            id: 8,
            text: "L'associazione nel modello di dominio rappresenta una relazione significativa tra classi",
            correct: true,
            explanation: "Corretto. Le associazioni nel modello di dominio rappresentano relazioni significative e rilevanti tra le classi concettuali del dominio."
        },
        {
            id: 9,
            text: "L'associazione nel modello di dominio rappresenta un valore logico degli oggetti di una classe",
            correct: false,
            explanation: "Le associazioni rappresentano RELAZIONI tra classi, non valori logici degli oggetti. I valori logici sono rappresentati dagli attributi."
        },
        {
            id: 10,
            text: "L'associazione nel modello di dominio rappresenta un'insieme di n-tuple di oggetti delle classi",
            correct: true,
            explanation: "Matematicamente, un'associazione pu√≤ essere vista come un insieme di n-tuple (coppie, triple, ecc.) di oggetti delle classi coinvolte nella relazione."
        },
        {
            id: 11,
            text: "Il modello di dominio √® una rappresentazione testuale delle classi concettuali, oggetti reali del dominio",
            correct: false,
            explanation: "Il modello di dominio √® una rappresentazione VISUALE (non testuale) delle classi concettuali, utilizzando diagrammi UML."
        },
        {
            id: 12,
            text: "Il modello di dominio √® un dizionario visuale delle classi concettuali",
            correct: true,
            explanation: "Corretto. Il modello di dominio funge da dizionario visuale che definisce e illustra le classi concettuali rilevanti nel dominio."
        },
        {
            id: 13,
            text: "Il MODELLO DI DOMINIO: Insieme di diagrammi di classi UML che includono associazioni tra classi software",
            correct: false,
            explanation: "Il modello di dominio include associazioni tra classi CONCETTUALI, non classi software. Le classi software appartengono al modello di progetto."
        },
        {
            id: 14,
            text: "Il MODELLO DI DOMINIO: Rappresentazione grafica degli oggetti software",
            correct: false,
            explanation: "Il modello di dominio rappresenta oggetti CONCETTUALI del dominio del problema, non oggetti software che appartengono all'implementazione."
        },
        {
            id: 15,
            text: "Il MODELLO DI DOMINIO: Rappresentazione visuale delle classi concettuali",
            correct: true,
            explanation: "Corretto. Il modello di dominio √® una rappresentazione visuale delle classi concettuali rilevanti nel dominio del problema."
        },
        {
            id: 16,
            text: "Il MODELLO DI DOMINIO: Insieme di diagrammi di classi UML che includono associazioni tra classi concettuali",
            correct: true,
            explanation: "Corretto. Il modello di dominio utilizza diagrammi di classi UML per rappresentare classi concettuali e le loro associazioni."
        },
        {
            id: 17,
            text: "Il MODELLO DI DOMINIO: Rappresentazione visuale delle classi JAVA",
            correct: false,
            explanation: "Il modello di dominio rappresenta classi CONCETTUALI del dominio, non classi Java che sono parte dell'implementazione software."
        },
        {
            id: 18,
            text: "Il MODELLO DI DOMINIO: Insieme di diagrammi di classi UML che includono le responsabilit√† di fare",
            correct: false,
            explanation: "Il modello di dominio NON include responsabilit√† 'di fare' (metodi). Le responsabilit√† sono assegnate durante la fase di progetto, non nell'analisi del dominio."
        },
        {
            id: 19,
            text: "Un caso d'uso rappresenta una maniera di utilizzare il sistema da parte di un utente per raggiungere un suo obiettivo",
            correct: true,
            explanation: "Corretto. Un caso d'uso descrive come un attore (utente) interagisce con il sistema per raggiungere un obiettivo specifico."
        },
        {
            id: 20,
            text: "La narrativa di un caso d'uso viene espressa a livello delle intenzioni dell'utente e della responsabilit√† del sistema",
            correct: true,
            explanation: "Corretto. I casi d'uso sono scritti dal punto di vista delle intenzioni dell'utente e delle responsabilit√† che il sistema deve assumere per soddisfarle."
        },
        {
            id: 21,
            text: "La narrativa di un caso d'uso viene espressa a livello delle azioni concrete dell'utente e delle responsabilit√† del sistema",
            correct: false,
            explanation: "I casi d'uso sono scritti a livello di INTENZIONI dell'utente, non di azioni concrete. Le azioni concrete appartengono a un livello di dettaglio troppo basso."
        },
        {
            id: 22,
            text: "Un caso d'uso √® sempre completato (implementato) in una solo iterazione",
            correct: false,
            explanation: "Un caso d'uso pu√≤ essere implementato in pi√π iterazioni. Spesso si implementano prima gli scenari base e successivamente quelli alternativi."
        },
        {
            id: 23,
            text: "Un caso d'uso rappresenta l'insieme di funzionalit√† di un sistema",
            correct: false,
            explanation: "Un caso d'uso rappresenta UN MODO SPECIFICO di utilizzare il sistema per raggiungere un obiettivo, non l'insieme di tutte le funzionalit√†."
        },
        {
            id: 24,
            text: "I requisiti funzionali non catturati dai casi d'uso vengono descritti nelle specifiche supplementari",
            correct: true,
            explanation: "Corretto. Le specifiche supplementari documentano i requisiti funzionali che non sono catturati dai casi d'uso (es. report, formati di file, ecc.)."
        },
        {
            id: 25,
            text: "L'analisi linguistica dei casi d'uso nel formato dettagliato √® una fonte di ispirazione per la costruzione del modello di dominio",
            correct: true,
            explanation: "Corretto. L'analisi dei sostantivi e dei concetti nei casi d'uso dettagliati aiuta a identificare le classi concettuali per il modello di dominio."
        },
        {
            id: 26,
            text: "Il modello di dominio riporta i concetti significativi relativi ai casi d'uso",
            correct: true,
            explanation: "Corretto. Il modello di dominio include i concetti del dominio che sono rilevanti per i casi d'uso del sistema."
        },
        {
            id: 27,
            text: "L'analisi linguistica dei casi d'uso nel formato dettagliato √® una fonte di ispirazione per la costruzione del modello di dominio",
            correct: true,
            explanation: "Corretto. L'analisi linguistica dei casi d'uso (identificazione di sostantivi, concetti) √® una tecnica fondamentale per costruire il modello di dominio."
        },
        {
            id: 28,
            text: "I requisiti non funzionali sono descritti completamente dai casi d'uso",
            correct: false,
            explanation: "I casi d'uso catturano principalmente requisiti FUNZIONALI. I requisiti non-funzionali (performance, sicurezza, usabilit√†) sono documentati nelle specifiche supplementari."
        },
        {
            id: 29,
            text: "I contratti sono considerati parte del modello dei casi d'uso poich√© forniscono maggiori dettagli dell'analisi, sull'effetto delle operazioni di sistema implicate dai casi d'uso",
            correct: true,
            explanation: "Corretto. I contratti delle operazioni di sistema forniscono dettagli aggiuntivi sugli effetti delle operazioni identificate nei casi d'uso."
        },
        {
            id: 30,
            text: "I CASI D'USO Sono una collezione di soli scenari di successo che descrivono un attore che usa il sistema per raggiungere un obiettivo specifico",
            correct: false,
            explanation: "I casi d'uso includono sia scenari di SUCCESSO che scenari ALTERNATIVI (inclusi quelli di fallimento). Non sono limitati ai soli scenari di successo."
        },
        {
            id: 31,
            text: "I casi d'uso sono descrizioni testuali di scenari di uso interessanti del sistema software che si deve realizzare",
            correct: true,
            explanation: "Corretto. I casi d'uso sono descrizioni testuali che documentano scenari di utilizzo significativi del sistema da sviluppare."
        },
        {
            id: 32,
            text: "I casi d'uso servono a catturare i requisiti funzionali",
            correct: true,
            explanation: "Corretto. Il principale scopo dei casi d'uso √® catturare e documentare i requisiti funzionali del sistema."
        },
        {
            id: 33,
            text: "In UP i casi d'uso vengono utilizzati per catturare i requisiti funzionali nella disciplina dei requisiti",
            correct: true,
            explanation: "Corretto. Nel Unified Process, i casi d'uso sono lo strumento principale per catturare i requisiti funzionali durante la disciplina dei requisiti."
        },
        {
            id: 34,
            text: "I casi d'uso sono caratteristiche del sistema",
            correct: false,
            explanation: "I casi d'uso NON sono caratteristiche del sistema, ma descrivono COME il sistema viene utilizzato dagli attori per raggiungere obiettivi specifici."
        },
        {
            id: 35,
            text: "I casi d'uso sono utilizzati per pianificare le iterazioni",
            correct: true,
            explanation: "Corretto. I casi d'uso sono utilizzati per organizzare e pianificare le iterazioni di sviluppo, implementando i casi d'uso pi√π critici nelle prime iterazioni."
        },
        {
            id: 36,
            text: "In UP i casi d'uso sono descritti mediante il linguaggio UML",
            correct: false,
            explanation: "I casi d'uso in UP sono descritti principalmente in linguaggio NATURALE (testo), non in UML. UML fornisce solo i diagrammi dei casi d'uso per mostrare le relazioni."
        },
        {
            id: 37,
            text: "DURANTE LA FASE DI ELABORAZIONE Si scrivono circa il 10% dei casi d'uso tra i pi√π critici in formato dettagliato utilizzando template appositi",
            correct: false,
            explanation: "Durante l'ideazione si scrive in dettaglio circa il 10% dei casi d'uso pi√π critici e rischiosi per guidare l'architettura. La fase di Elaborazione √® invece il momento in cui la maggior parte dei requisiti viene chiarita e stabilizzata, portando ad una percentuale molto pi√π alta (40-80%) di casi d'uso dettagliati entro la fine di questa fase. Vengono implementati il 100% dei requisiti funzionali del progetto (preso dai quiz)."
        },
        {
            id: 38,
            text: "In percentuale sul totale di casi d'uso complessivi di un progetto, sono pari al 5% quelli che dovrebbero essere realizzati entro la conclusione della fase di ideazione?",
            correct: true,
            explanation: "Corretto. Durante la fase di ideazione si implementa circa il 5% dei casi d'uso tra tutti quelli identificati."
        },
        {
            id: 39,
            text: "I casi d'uso mettono in risalto gli obiettivi degli utenti",
            correct: true,
            explanation: "Corretto. I casi d'uso sono organizzati attorno agli obiettivi che gli utenti (attori) vogliono raggiungere utilizzando il sistema."
        },
        {
            id: 40,
            text: "I casi d'uso sono utilizzati per la scoperta e la definizione dei requisiti non funzionali",
            correct: false,
            explanation: "I casi d'uso sono utilizzati principalmente per i requisiti FUNZIONALI. I requisiti non-funzionali sono documentati nelle specifiche supplementari."
        },
        {
            id: 41,
            text: "I casi d'uso sono utilizzati per la scoperta e la definizione dei requisiti funzionali",
            correct: true,
            explanation: "Corretto. I casi d'uso sono lo strumento principale per scoprire, definire e documentare i requisiti funzionali del sistema."
        },
        {
            id: 42,
            text: "I casi d'uso mettono in risalto gli obiettivi del sistema",
            correct: false,
            explanation: "I casi d'uso mettono in risalto gli obiettivi degli UTENTI (attori), non del sistema. Il sistema risponde agli obiettivi degli utenti."
        },
        {
            id: 43,
            text: "I casi d'uso sono utilizzati solo nelle prime iterazioni di sviluppo",
            correct: false,
            explanation: "I casi d'uso sono utilizzati durante TUTTO il processo di sviluppo, non solo nelle prime iterazioni. Guidano implementazione, test e validazione."
        },
        {
            id: 44,
            text: "Il principale input per la redazione dei contratti sono le operazioni di sistema e il modello di dominio",
            correct: true,
            explanation: "Corretto. I contratti sono scritti per le operazioni di sistema identificate negli SSD, utilizzando il modello di dominio per descrivere gli effetti."
        },
        {
            id: 45,
            text: "Le post-condizioni descrivono i cambiamenti di stato degli oggetti nel modello di dominio dopo il completamento dell'operazione",
            correct: true,
            explanation: "Corretto. Le post-condizioni nei contratti descrivono come cambiano gli stati degli oggetti del modello di dominio dopo l'esecuzione dell'operazione."
        },
        {
            id: 46,
            text: "I contratti servono come input per il modello di dominio",
            correct: false,
            explanation: "I contratti NON servono come input per il modello di dominio. √à il contrario: il modello di dominio serve come input per scrivere i contratti."
        },
        {
            id: 47,
            text: "La responsabilit√† sono assegnate ai concetti definiti nel modello di dominio",
            correct: false,
            explanation: "Le responsabilit√† sono assegnate alle CLASSI SOFTWARE durante la progettazione, non ai concetti del modello di dominio che rappresenta solo l'analisi."
        },
        {
            id: 48,
            text: "I contratti delle operazioni di sistema usano pre e post- condizioni per descrivere nel dettaglio i cambiamenti agli oggetti (concettuali) in un modello di dominio",
            correct: true,
            explanation: "Corretto. I contratti utilizzano pre-condizioni e post-condizioni per descrivere dettagliatamente come le operazioni di sistema modificano gli oggetti concettuali."
        },
        {
            id: 49,
            text: "I contratti servono come input per il modello di dominio",
            correct: false,
            explanation: "I contratti NON servono come input per il modello di dominio. Il modello di dominio √® creato prima e serve come base per scrivere i contratti."
        },
        {
            id: 50,
            text: "Le pre-condizioni descrivono i cambiamenti di stato degli oggetti nel modello di dominio dopo il completamento dell'operazione",
            correct: false,
            explanation: "Le pre-condizioni descrivono lo stato che deve esistere PRIMA dell'operazione. Sono le POST-condizioni che descrivono i cambiamenti dopo l'operazione."
        },
        {
            id: 51,
            text: "La composizione di oggetti √® definita staticamente attraverso la specifica delle classi e delle associazioni",
            correct: true,
            explanation: "Corretto. La composizione viene definita staticamente nel codice attraverso la definizione delle classi e delle loro relazioni di composizione."
        },
        {
            id: 52,
            text: "Il meccanismo di specializzazione per il riuso del codice √® detto white-box",
            correct: true,
            explanation: "Corretto. L'ereditariet√† (specializzazione) √® chiamata riuso 'white-box' perch√© la sottoclasse ha visibilit√† sui dettagli interni della superclasse."
        },
        {
            id: 53,
            text: "La modifica dell'interfaccia di una classe ha in generale un basso impatto nelle sottoclassi",
            correct: false,
            explanation: "La modifica dell'interfaccia di una classe ha generalmente un ALTO impatto sulle sottoclassi, che dipendono dall'interfaccia della superclasse."
        },
        {
            id: 54,
            text: "I pattern GRASP sono espressi in termini di responsabilit√†, ruoli e collaborazioni",
            correct: true,
            explanation: "Corretto. I pattern GRASP (General Responsibility Assignment Software Patterns) si concentrano sull'assegnazione di responsabilit√†, ruoli e collaborazioni tra oggetti."
        },
        {
            id: 55,
            text: "La decisione sull'assegnazione delle responsabilit√† precede sempre la codifica",
            correct: false,
            explanation: "L'assegnazione delle responsabilit√† √® parte della progettazione (OOD) che precede logicamente la fase di implementazione/codifica, ma le decisioni sull‚Äôassegnazione delle responsabilit√† agli oggetti possono anche essere prese mentre si esegue la codifica oppure durante la modellazione."
        },
        {
            id: 56,
            text: "L'utilizzo dei pattern GRASP √® svolto all'interno della disciplina dei requisiti di UP",
            correct: false,
            explanation: "I pattern GRASP sono utilizzati nella disciplina di PROGETTAZIONE (Design), non nella disciplina dei requisiti. Riguardano l'assegnazione di responsabilit√† alle classi software."
        },
        {
            id: 57,
            text: "Le responsabilit√† sono assegnate alle classi durante la OOD",
            correct: true,
            explanation: "Corretto. L'Object-Oriented Design (OOD) √® la fase in cui si assegnano le responsabilit√† alle classi software utilizzando principi come i pattern GRASP."
        },
        {
            id: 58,
            text: "Il meccanismo di delega √® preferibile al meccanismo di specializzazione per il riuso del codice",
            correct: true,
            explanation: "Corretto. La composizione/delega (riuso black-box) √® generalmente preferibile all'ereditariet√† perch√© √® pi√π flessibile e mantiene un minor accoppiamento."
        },
        {
            id: 59,
            text: "L'ereditariet√† rispetta l'incapsulamento",
            correct: false,
            explanation: "L'ereditariet√† NON rispetta completamente l'incapsulamento perch√© la sottoclasse ha accesso ai membri protetti della superclasse, rompendo l'incapsulamento."
        },
        {
            id: 60,
            text: "La composizione di oggetti √® un meccanismo di riuso del codice detto black-box",
            correct: true,
            explanation: "Corretto. La composizione √® chiamata riuso 'black-box' perch√© gli oggetti componenti sono utilizzati solo attraverso le loro interfacce pubbliche."
        },
        {
            id: 61,
            text: "Un metodo di una classe software rappresenta una responsabilit√† 'a fare' per le istanze di tale classe",
            correct: true,
            explanation: "Corretto. I metodi rappresentano le responsabilit√† 'doing' (a fare) di una classe, cio√® quello che gli oggetti di quella classe sanno fare."
        },
        {
            id: 62,
            text: "DURANTE LA FASE DI ELABORAZIONE Non vengono effettuati test al codice di sviluppo",
            correct: false,
            explanation: "Durante la fase di elaborazione SI effettuano test al codice. √à una fase in cui si programma il nucleo architetturale e lo si testa."
        },
        {
            id: 63,
            text: "DURANTE LA FASE DI ELABORAZIONE Non si sviluppa codice",
            correct: false,
            explanation: "Durante la fase di elaborazione SI sviluppa codice. Si programma il nucleo architetturale del sistema per validare l'architettura proposta."
        },
        {
            id: 64,
            text: "DURANTE LA FASE DI ELABORAZIONE Viene scoperta e stabilizzata la maggior parte dei requisiti",
            correct: true,
            explanation: "Corretto. L'elaborazione √® la fase in cui si scoprono e stabilizzano la maggior parte dei requisiti, completando l'analisi iniziata nell'ideazione."
        },
        {
            id: 65,
            text: "DURANTE LA FASE DI ELABORAZIONE Si realizza uno studio economico per stabilire l'ordine di grandezza del progetto e dei costi",
            correct: false,
            explanation: "Lo studio economico preliminare viene fatto durante la fase di IDEAZIONE, non di elaborazione. L'elaborazione raffina le stime."
        },
        {
            id: 66,
            text: "DURANTE LA FASE DI ELABORAZIONE Viene programmato il nucleo, rischioso, dell'architettura",
            correct: true,
            explanation: "Corretto. Durante l'elaborazione si programma e testa il nucleo architetturale del sistema, concentrandosi sulle parti pi√π rischiose."
        },
        {
            id: 67,
            text: "In UML per responsabilit√† si intende la specifica di un metodo associato ad una classe Java",
            correct: false,
            explanation: "In UML, responsabilit√† √® un concetto pi√π generale che include sia 'knowing' che 'doing'. Non √® limitato ai soli metodi Java."
        },
        {
            id: 68,
            text: "In UML per responsabilit√† si intende la specifica di una variabile di istanza di una classe Java",
            correct: false,
            explanation: "Le variabili di istanza sono parte delle responsabilit√† 'knowing', ma la responsabilit√† in UML √® un concetto pi√π ampio che include anche le azioni."
        },
        {
            id: 69,
            text: "In UML per responsabilit√† si intende un contratto o un obbligo di un classificatore",
            correct: true,
            explanation: "Corretto. In UML, una responsabilit√† √® definita come un contratto o obbligo di un classificatore (classe), che include sia knowing che doing."
        },
        {
            id: 70,
            text: "In UML per responsabilit√† si intende la specifica di una variabile di istanza o di un metodo associato ad una classe Java",
            correct: false,
            explanation: "La responsabilit√† in UML √® un concetto pi√π astratto di contratto/obbligo, non semplicemente l'implementazione in variabili o metodi Java."
        },
        {
            id: 71,
            text: "Gli SSD Sono espressi attraverso i diagrammi di comunicazione di UML",
            correct: false,
            explanation: "Gli SSD (System Sequence Diagrams) sono espressi attraverso i diagrammi di SEQUENZA di UML, non i diagrammi di comunicazione."
        },
        {
            id: 72,
            text: "Gli SSD Mostrano l'ordine degli eventi generati dagli attori esterni al sistema",
            correct: true,
            explanation: "Corretto. Gli SSD mostrano la sequenza temporale degli eventi di sistema generati dagli attori esterni per uno specifico scenario di caso d'uso."
        },
        {
            id: 73,
            text: "I contratti costituiscono un input per gli SSD delle operazioni e per la progettazione degli oggetti",
            correct: false,
            explanation: "√à il contrario: gli SSD sono input per i contratti. Gli SSD identificano le operazioni di sistema, per le quali poi si scrivono i contratti."
        },
        {
            id: 74,
            text: "Un evento di sistema √® un evento interno al sistema",
            correct: false,
            explanation: "Un evento di sistema √® un evento che arriva al sistema dall'ESTERNO, generato da un attore esterno. Gli eventi interni non sono eventi di sistema."
        },
        {
            id: 75,
            text: "Gli SSD mostrano gli eventi generati dagli attori esterni al sistema",
            correct: true,
            explanation: "Corretto. Gli SSD (System Sequence Diagrams) mostrano gli eventi di sistema generati dagli attori esterni durante l'esecuzione di un caso d'uso."
        },
        {
            id: 76,
            text: "In percentuale sul totale dei requisiti funzionali di un progetto, quelli che dovrebbero essere identificati entro la conclusione della fase di IDEAZIONE sono pari al 50%? ",
            correct: false,
            explanation: "Alla fine dell'ideazione si dovrebbe aver identificato circa il 70% dei requisiti funzionali, non il 50%. Il 50% √® troppo poco per completare l'ideazione."
        },
        {
            id: 77,
            text: "In percentuale sul totale dei requisiti funzionali di un progetto, quelli che dovrebbero essere identificati entro la conclusione della fase di ELABORAZIONE sono pari al 100%?",
            correct: true,
            explanation: "Corretto. Alla fine dell'elaborazione dovrebbero essere identificati praticamente tutti i requisiti funzionali, per poter pianificare accuratamente la costruzione."
        },
        {
            id: 78,
            text: "Il riuso white-box √® preferibile al riuso black-box",
            correct: false,
            explanation: "Il riuso black-box (composizione) √® generalmente preferibile al riuso white-box (ereditariet√†) perch√© offre maggiore flessibilit√† e minor accoppiamento."
        },
        {
            id: 79,
            text: "Il meccanismo di ereditariet√† non √® preferibile al meccanismo di delega per ottenere il riuso del software",
            correct: true,
            explanation: "Corretto. La delega (composizione) √® spesso preferibile all'ereditariet√† per il riuso perch√© √® pi√π flessibile e mantiene un accoppiamento pi√π basso."
        },
        {
            id: 80,
            text: "L'ereditariet√† si avvale del meccanismo di delega",
            correct: false,
            explanation: "L'ereditariet√† e la delega sono meccanismi ALTERNATIVI per il riuso del codice. L'ereditariet√† non si avvale della delega."
        },
        {
            id: 81,
            text: "Il meccanismo di composizione non rispetta l'incapsulamento",
            correct: false,
            explanation: "Il meccanismo di composizione RISPETTA l'incapsulamento perch√© accede agli oggetti componenti solo attraverso le loro interfacce pubbliche."
        },
        {
            id: 82,
            text: "Le operazioni di sistema possono essere identificate mentre si abbozzano gli SSD",
            correct: true,
            explanation: "Corretto. Le operazioni di sistema vengono identificate durante la creazione degli SSD, che mostrano gli eventi che il sistema deve gestire."
        },
        {
            id: 83,
            text: "I contratti descrivono in modo dettagliato i cambiamenti richiesti dall'esecuzione di una operazione di sistema, descrivono come devono essere ottenuti questi risultati",
            correct: false,
            explanation: "I contratti descrivono COSA deve succedere (post-condizioni), ma NON descrivono COME ottenere questi risultati. Il 'come' √® parte della progettazione."
        },
        {
            id: 84,
            text: "I pattern GoF incentivano l'uso dell'ereditariet√† come meccanismo di riuso del codice, in particolare attraverso il pattern composite",
            correct: false,
            explanation: "I pattern GoF generalmente SCORAGGIANO l'uso eccessivo dell'ereditariet√† per il riuso preferendo la composizione. Il pattern Composite usa l'ereditariet√† per il polimorfismo, non per il riuso."
        },
        {
            id: 85,
            text: "I pattern GoF prediligono l'utilizzo del meccanismo di ereditariet√† per ottenere la specializzazione",
            correct: false,
            explanation: "I pattern GoF enfatizzano il principio 'favor composition over inheritance' - preferire la composizione all'ereditariet√† anche per la specializzazione."
        },
        {
            id: 86,
            text: "I pattern GoF incentivano i meccanismi di riuso del software attraverso la definizione di gerarchie di classi",
            correct: false,
            explanation: "I pattern GoF promuovono il riuso attraverso la COMPOSIZIONE e la delega, non attraverso gerarchie di classi estese."
        },
        {
            id: 87,
            text: "I pattern GoF prediligono l'utilizzo del meccanismo di ereditariet√† per ottenere il polimorfismo",
            correct: true,
            explanation: "Corretto. I pattern GoF utilizzano l'ereditariet√† principalmente per ottenere il POLIMORFISMO (comportamenti diversi con interfaccia comune), non per il riuso del codice."
        },
        {
            id: 88,
            text: "I pattern GoF Composite fornisce caratteristiche addizionali ad elementi atomici (foglie), mantenendo una interfaccia comune",
            correct: false,
            explanation: "Il pattern Composite NON fornisce caratteristiche addizionali alle foglie. Permette di trattare oggetti semplici e composti uniformemente."
        },
        {
            id: 89,
            text: "Il pattern GoF Composite permette di costruire tassonomie di classi",
            correct: false,
            explanation: "Il pattern Composite permette di costruire strutture ad ALBERO di oggetti, non tassonomie di classi. Le tassonomie sono gerarchie di ereditariet√†."
        },
        {
            id: 90,
            text: "Il pattern GoF Composite utilizza il meccanismo di specializzazione per rendere l'interfaccia delle entit√† atomiche esattamente come l'interfaccia delle entit√† composte",
            correct: false,
            explanation: "Il Composite usa la generalizzazione per far s√¨ che foglie e nodi composti implementino la stessa interfaccia, permettendo un trattamento uniforme."
        },
        {
            id: 91,
            text: "Il pattern GoF Composite permette di evitare l'esplosione delle sottoclassi per supportare un ampio numero di estensioni e combinazioni di esse",
            correct: false,
            explanation: "Questo √® il pattern DECORATOR, non Composite. Il Composite organizza oggetti in strutture ad albero, non evita l'esplosione di sottoclassi."
        },
        {
            id: 92,
            text: "Il pattern GoF Composite permette di costruire strutture ricorsive in modo che ad un cliente l'intera struttura sia vista come una singola entit√†",
            correct: true,
            explanation: "Corretto. Il pattern Composite permette di costruire strutture ad albero dove i client possono trattare oggetti semplici e composti uniformemente."
        },
        {
            id: 93,
            text: "L'extreme programming promuove lo sviluppo seguito dai test",
            correct: false,
            explanation: "XP promuove il TDD (Test-Driven Development): prima si scrivono i test, POI si scrive il codice per farli passare. I test precedono lo sviluppo."
        },
        {
            id: 94,
            text: "I test unitari hanno lo scopo di verificare la comunicazione tra specifiche parti del sistema",
            correct: false,
            explanation: "I test unitari verificano il comportamento di singole UNIT√Ä (metodi, classi) in isolamento. I test di integrazione verificano la comunicazione tra parti."
        },
        {
            id: 95,
            text: "Preparazione, esecuzione, verifica e rilascio sono le parti del test unitario",
            correct: true,
            explanation: "Corretto. Le fasi tipiche di un test unitario sono: Setup (preparazione), Exercise (esecuzione), Verify (verifica) e Release (rilascio)."
        },
        {
            id: 96,
            text: "Il refactoring prevede di applicare piccole trasformazioni che preservano il comportamento",
            correct: true,
            explanation: "Corretto. Il refactoring consiste nell'applicare piccole trasformazioni al codice che migliorano la struttura senza modificare il comportamento esterno."
        },
        {
            id: 97,
            text: "I test unitari sono utilizzati per dimostrare che il refactoring non abbia causato una regressione",
            correct: true,
            explanation: "Corretto. I test unitari servono come rete di sicurezza durante il refactoring, assicurando che il comportamento rimanga invariato."
        },
        {
            id: 98,
            text: "La progettazione object-oriented in UP ha il fine di identificare le responsabilit√† e assegnarle ad un opportuno oggetto o classe",
            correct: true,
            explanation: "Corretto. L'OOD in UP si concentra sull'identificazione delle responsabilit√† software e sulla loro assegnazione alle classi appropriate."
        },
        {
            id: 99,
            text: "La coesione √® la misura di quanto fortemente un elemento √® connesso ad altri elementi, ha conoscenza di altri elementi e dipende da altri elementi",
            correct: false,
            explanation: "Questa √® la definizione di ACCOPPIAMENTO. La coesione misura quanto le responsabilit√† di un singolo elemento sono correlate tra loro."
        },
        {
            id: 100,
            text: "Il pattern GRASP Information Expert e High Cohesion sono pattern valutativi",
            correct: false,
            explanation: "Low Coupling e High Cohesion sono pattern GRASP valutativi che forniscono criteri per valutare la qualit√† delle soluzioni di design."
        },
        {
            id: 101,
            text: "La creazione di un oggetto √® di responsabilit√† di un oggetto che aggrega, contiene un'istanza dell'oggetto da creare",
            correct: true,
            explanation: "Corretto. Secondo il pattern GRASP Creator, la responsabilit√† di creare un oggetto spetta spesso a chi lo aggrega, contiene o usa intensivamente."
        },
        {
            id: 102,
            text: "Una classe con accoppiamento alto fa molte cose non correlate tra loro e svolge troppo lavoro",
            correct: false,
            explanation: "Questa √® la definizione di bassa COESIONE. L'alto accoppiamento indica molte dipendenze verso altre classi, non necessariamente molte responsabilit√†."
        },
        {
            id: 103,
            text: "Il refactoring √® una pratica promossa dal metodo iterativo e agile xp",
            correct: true,
            explanation: "Corretto. Il refactoring √® una delle pratiche fondamentali di XP (Extreme Programming) e dei metodi agili in generale."
        },
        {
            id: 104,
            text: "Il refactoring prevede lo sviluppo guidato dai test, ovvero uno sviluppo preceduto dai test",
            correct: false,
            explanation: "Il refactoring e il TDD sono pratiche SEPARATE. Il refactoring migliora il codice esistente, il TDD √® una tecnica di sviluppo guidata dai test."
        },
        {
            id: 105,
            text: "Il refactoring √® un metodo strutturato e disciplinato per scrivere o ristrutturare del codice esistente",
            correct: true,
            explanation: "Corretto. Il refactoring √® un processo disciplinato per ristrutturare codice esistente migliorandone la struttura senza cambiarne il comportamento."
        },
        {
            id: 106,
            text: "DURANTE LA FASE DI ELABORAZIONE: I requisiti e le iterazioni sono organizzati in base alla richiesta dell'utente finale",
            correct: false,
            explanation: "Durante l'elaborazione i requisiti sono organizzati in base a RISCHIO e CRITICIT√Ä ARCHITETTURALE, non alle richieste dell'utente finale."
        },
        {
            id: 107,
            text: "DURANTE LA FASE DI ELABORAZIONE: I requisiti e le iterazioni sono organizzati in base al rischio, copertura (devono coprire tutto il sistema) e criticit√†",
            correct: true,
            explanation: "Corretto. L'elaborazione organizza le iterazioni in base a rischio, criticit√† architetturale e necessit√† di coprire tutti gli aspetti del sistema."
        },
        {
            id: 108,
            text: "DURANTE LA FASE DI ELABORAZIONE: Si effettua attivit√† di programmazione di qualit√†-produzione e test",
            correct: true,
            explanation: "Corretto. Durante l'elaborazione si sviluppa codice di qualit√† produzione per il nucleo architetturale e si effettuano test appropriati."
        },
        {
            id: 109,
            text: "DURANTE LA FASE DI ELABORAZIONE: Vengono realizzati prototipi 'usa e getta' per ottenere i rischi maggiori",
            correct: false,
            explanation: "Durante l'elaborazione si sviluppa il nucleo architetturale EVOLUTIVO, non prototipi 'usa e getta'. I prototipi usa e getta sono tipici dell'ideazione."
        },
        {
            id: 110,
            text: "La responsabilit√† √® un'astrazione di ci√≤ che fa o rappresenta un oggetto o un componente software",
            correct: true,
            explanation: "Corretto. La responsabilit√† √® un'astrazione di ci√≤ che un oggetto SA (knowing) o FA (doing)."
        },
        {
            id: 111,
            text: "Nel Responsibility-Driven Development gli oggetti software sono considerati come dotati di responsabilit√†",
            correct: true,
            explanation: "Corretto. Il RDD (Responsibility-Driven Development) vede gli oggetti come entit√† che hanno responsabilit√† specifiche nel sistema."
        },
        {
            id: 112,
            text: "La disciplina dei requisiti √® il processo per scoprire cosa deve essere costruito",
            correct: true,
            explanation: "Corretto. La disciplina dei requisiti in UP ha l'obiettivo di scoprire, documentare e validare cosa il sistema deve fare."
        },
        {
            id: 113,
            text: "La disciplina dei requisiti deve orientare lo sviluppo verso il sistema corretto",
            correct: true,
            explanation: "Corretto. La disciplina dei requisiti assicura che si sviluppi il sistema GIUSTO (quello che soddisfa realmente i bisogni degli utenti)."
        },
        {
            id: 114,
            text: "I contratti usano pre-condizioni e post-condizioni per descrivere nel dettaglio i cambiamenti agli oggetti in un modello di progetto (software)",
            correct: false,
            explanation: "I contratti descrivono cambiamenti agli oggetti del MODELLO DI DOMINIO (concettuali), non del modello di progetto (software)."
        },
        {
            id: 115,
            text: "Le operazioni di sistema possono essere identificate mentre si abbozzano gli DSD",
            correct: false,
            explanation: "Le operazioni di sistema vengono identificate prima, durante l'abbozzo degli SSD, e non dei DSD. I DSD mostrano come tali operazioni vengono realizzate internamente."
        },
        {
            id: 116,
            text: "Nella fase di Analisi dei Requisiti, la prima attivit√† consiste nel tradurre le informazioni raccolte in un documento che definisce un insieme di requisiti.",
            correct: false,
            explanation: "La prima fase principale dell'Analisi dei Requisiti √® la Deduzione e analisi dei requisiti; la Specifica dei requisiti, che consiste nel tradurre le informazioni in un documento, viene successivamente."
        },
        {
            id: 117,
            text: "Nelle metodologie agili, la progettazione e l'implementazione del software sono solitamente separate e producono documenti formali dettagliati prima della codifica.",
            correct: false,
            explanation: "Nelle metodologie agili, la progettazione e l'implementazione sono intrecciate e non producono documenti formali; il progetto √® spesso registrato informalmente."
        },
        {
            id: 118,
            text: "L'Unified Process (UP) √® una metodologia di sviluppo software che segue un approccio strettamente sequenziale e a cascata.",
            correct: false,
            explanation: "UP incoraggia uno sviluppo iterativo e guidato dal rischio. La programmazione e il test iniziano prima che l'analisi di tutti i requisiti sia completata."
        },
        {
            id: 119,
            text: "Lo scopo principale della fase di Ideazione in UP √® quello di definire tutti i requisiti dettagliati del progetto e generare una stima affidabile dei costi.",
            correct: false,
            explanation: "Lo scopo della fase di ideazione non √® quello di definire tutti i requisiti, n√© di generare una stima o un piano di progetto affidabili. Si tratta piuttosto di decidere se il progetto merita un'indagine pi√π seria."
        },
        {
            id: 120,
            text: "Il documento Visione in UP riassume i requisiti di alto livello ed √® utile per stabilire una visione comune del progetto tra i partecipanti.",
            correct: true,
            explanation: "Il documento Visione riassume alcune informazioni contenute nel modello dei casi d'uso e nelle specifiche supplementari, descrivendo brevemente il progetto come contesto per i partecipanti e stabilendo una visione comune."
        },
        {
            id: 121,
            text: "In UP, il Glossario ha anche la funzione di dizionario dei dati, includendo informazioni relative ad altri dati (metadati), come le regole di validazione.",
            correct: true,
            explanation: "In UP, il Glossario svolge anche il ruolo di un dizionario di dati, un documento dati relativi ad altri dati, ovvero metadati, inclusi esempi di regole di validazione."
        },
        {
            id: 122,
            text: "La Disciplina dei Requisiti in UP si concentra principalmente sul 'come' il sistema deve essere costruito, definendo le soluzioni tecniche e architetturali.",
            correct: false,
            explanation: "La Disciplina dei Requisiti √® il processo per scoprire 'cosa' deve essere costruito e orientare lo sviluppo verso il sistema corretto, definendo le capacit√† e condizioni a cui il sistema deve essere conforme."
        },
        {
            id: 123,
            text: "Secondo le fonti, i casi d'uso in UP sono principalmente rappresentati da diagrammi UML per visualizzare le interazioni tra attori e sistema.",
            correct: false,
            explanation: "I casi d'uso in UP sono descrizioni testuali di scenari di uso interessanti del sistema software. Le fonti specificano chiaramente che i casi d'uso sono documenti testuali, non diagrammi."
        },
        {
            id: 124,
            text: "Un Attore Primario in un caso d'uso √® colui che offre un servizio al sistema.",
            correct: false,
            explanation: "L'Attore Primario √® colui che raggiunge gli obiettivi utente utilizzando i servizi del sistema. L'attore di supporto √® colui che offre un servizio al sistema."
        },
        {
            id: 125,
            text: "Nel formato dettagliato di un caso d'uso, la sezione 'Estensioni' √® utilizzata per descrivere scenari alternativi, sia di successo che di fallimento, rispetto allo scenario principale.",
            correct: true,
            explanation: "Le Estensioni descrivono scenari alternativi, di successo o di fallimento, e la loro gestione."
        },
        {
            id: 126,
            text: "Quando si scrive un caso d'uso in stile essenziale, √® fondamentale includere dettagli precisi sull'interfaccia utente (GUI) con cui l'attore interagisce.",
            correct: false,
            explanation: "Lo stile essenziale implica ignorare l'interfaccia utente e concentrarsi sull'obiettivo utente e le responsabilit√† del sistema a un livello astratto, indipendente dai dettagli tecnologici e di UI."
        },
        {
            id: 127,
            text: "L'approccio Black-box nella scrittura dei casi d'uso significa descrivere esattamente 'come' il sistema esegue una determinata azione, inclusi dettagli implementativi come l'uso di database o istruzioni SQL.",
            correct: false,
            explanation: "L'approccio Black-box significa descrivere 'che cosa' il sistema deve fare (comportamento o requisiti funzionali) senza decidere come."
        },
        {
            id: 128,
            text: "Per verificare l'utilit√† di un caso d'uso, il Test del capo chiede se l'attivit√† descritta rappresenta un'azione significativa per l'utente che giustifichi lo sforzo di implementazione.",
            correct: true,
            explanation: "Il Test del capo implica chiedersi se un capo sarebbe contento se il lavoro di un giorno fosse solo l'attivit√† descritta nel caso d'uso; se la risposta √® no, il caso d'uso non √® utile."
        },
        {
            id: 129,
            text: "Il Modello di Dominio rappresenta i concetti chiave del sistema come oggetti software con nomi e informazioni simili al dominio del mondo reale.",
            correct: false,
            explanation: "Il Modello di Dominio √® uno strumento di analisi che rappresenta i concetti del mondo reale (classi concettuali) in modo indipendente dall'implementazione software, mentre gli oggetti software con nomi simili al dominio vengono creati in una fase successiva (progettazione e implementazione) e rappresentati, ad esempio, nel Modello di Progetto (tramite DCD), ispirandosi al Modello di Dominio."
        },
        {
            id: 130,
            text: "I Diagrammi di Sequenza di Sistema (SSD) mostrano le interazioni tra gli oggetti interni del sistema per realizzare un'operazione.",
            correct: false,
            explanation: "Il Diagramma di Sequenza di Sistema serve a rappresentare gli eventi di input e output che coinvolgono il sistema durante un'interazione con gli attori esterni, vedendo il sistema come una scatola nera."
        },
        {
            id: 131,
            text: "I Contratti delle operazioni di sistema descrivono in dettaglio 'come' vengono realizzati i cambiamenti nello stato del sistema dopo l'esecuzione di un'operazione.",
            correct: false,
            explanation: "Un contratto descrive in modo molto dettagliato i cambiamenti richiesti dall'esecuzione di una operazione di sistema senza per√≤ descrivere come devono essere ottenuti."
        },
        {
            id: 132,
            text: "Un'operazione di sistema di Interrogazione modifica lo stato del sistema e per questo motivo deve avere delle post-condizioni nel suo contratto.",
            correct: false,
            explanation: "Un'operazione di sistema di Interrogazione non modifica lo stato del sistema, si limita a calcolare e restituire un valore, e per questo non ha post-condizioni. Le post-condizioni descrivono i cambiamenti nello stato degli oggetti."
        },
        {
            id: 133,
            text: "La progettazione orientata agli oggetti (OOD) pone l'enfasi sulla definizione degli oggetti software e sul modo in cui questi collaborano per soddisfare i requisiti.",
            correct: true,
            explanation: "La progettazione orientata agli oggetti pone l'enfasi sulla definizione di oggetti software e del modo in cui questi collaborano per soddisfare i requisiti."
        },
        {
            id: 134,
            text: "I pattern GRASP sono un repertorio di soluzioni progettuali specifiche per problemi ricorrenti nell'implementazione di software, simili ai pattern GoF.",
            correct: false,
            explanation: "I pattern GRASP sono principi per l'assegnazione di responsabilit√†. I pattern GoF sono descrizioni con nome di problemi di progettazione ricorrenti e di una soluzione."
        },
        {
            id: 135,
            text: "Secondo il pattern GRASP Information Expert, una responsabilit√† dovrebbe essere assegnata alla classe che possiede le informazioni necessarie per soddisfarla.",
            correct: true,
            explanation: "Il pattern Information Expert suggerisce di assegnare una responsabilit√† alla classe che possiede le informazioni necessarie per soddisfarla, all'esperto delle informazioni."
        },
        {
            id: 136,
            text: "I test unitari sono un tipo di test progettato per verificare il sistema software completo, considerando le interazioni tra tutti i componenti principali.",
            correct: false,
            explanation: "I test unitari testano singole unit√† di codice. I test di integrazione testano la comunicazione tra specifiche parti, mentre i test end-to-end testano l'intero sistema."
        },
        {
            id: 137,
            text: "Nella metodologia eXtreme Programming, i test vengono scritti prima di scrivere il codice corrispondente (sviluppo guidato dai test).",
            correct: true,
            explanation: "In alcune metodologie agili come l'eXtreme Programming, si scrivono i test prima di scrivere il codice."
        },
        {
            id: 138,
            text: "Nel modello a cascata, si presume che i requisiti siano prevedibili e stabili fin dall'inizio con un basso tasso di cambiamenti.",
            correct: true,
            explanation: "Il modello a cascata parte dal presupposto che le specifiche sono prevedibili e stabili e possono essere definite correttamente sin dall'inizio, a fronte di un basso tasso di cambiamenti."
        },
        {
            id: 139,
            text: "Secondo le fonti, i metodi di sviluppo iterativi sono statisticamente associati a percentuali di successo pi√π basse rispetto al modello a cascata.",
            correct: false,
            explanation: "In base a dati statistici, i metodi iterativi sono associati a percentuali di successo e di produttivit√† pi√π elevate, nonch√© a livelli minori di difetti. Al contrario, l'approccio a cascata √® caratterizzato da una minore produttivit√† e da maggiori percentuali di difetti."
        },
        {
            id: 140,
            text: "Uno dei motivi principali per cui i requisiti cambiano √® l'impossibilit√† per i clienti di prevedere appieno come un sistema influenzer√† le pratiche operative prima che sia consegnato e utilizzato.",
            correct: true,
            explanation: "I requisiti cambiano perch√© per i clienti √® impossibile prevedere come un sistema influenzer√† le pratiche operative, come interagir√† con gli altri sistemi e quali operazioni degli utenti dovranno essere automatizzate; i requisiti reali diventano chiari solo dopo che il sistema √® stato consegnato e utilizzato."
        },
        {
            id: 141,
            text: "In Unified Process (UP), la Disciplina dei Requisiti √® un insieme di attivit√† che si svolgono esclusivamente all'inizio del progetto, prima di qualsiasi altra disciplina.",
            correct: false,
            explanation: "In UP, le discipline (tipologie di attivit√†) non sono sequenziali e si eseguono nel progetto in ogni iterazione. La Disciplina dei Requisiti √® il processo per scoprire \"cosa\" deve essere costruito e orientare lo sviluppo verso il sistema corretto."
        },
        {
            id: 142,
            text: "Secondo UP, √® necessario definire il 100% dei requisiti dettagliati prima di iniziare qualsiasi attivit√† di programmazione o test.",
            correct: false,
            explanation: "In UP si iniziano programmazione e test quando √® stato specificato solo il 10% o il 20% dei requisiti pi√π significativi. Inoltre, non si cerca di definire tutti i requisiti prima di iniziare la progettazione o l'implementazione."
        },
        {
            id: 143,
            text: "Il documento Specifiche Supplementari in UP √® destinato a contenere tutti i requisiti funzionali del sistema, inclusi quelli descritti nei casi d'uso.",
            correct: false,
            explanation: "Le Specifiche Supplementari contengono ci√≤ che non rientra nei casi d'uso, come requisiti non funzionali o funzionali non esprimibili attraverso casi d'uso. I requisiti funzionali principali sono descritti nel Modello dei Casi d'Uso."
        },
        {
            id: 144,
            text: "Durante la fase di Ideazione in UP, l'obiettivo √® analizzare in dettaglio la maggior parte dei casi d'uso per ottenere una comprensione completa dei requisiti funzionali.",
            correct: false,
            explanation: "Durante l'ideazione si analizzano circa il 10% dei casi d'uso in dettaglio. Lo scopo dell'Ideazione non √® raccogliere tutti i requisiti, ma capire se il progetto merita un'indagine pi√π seria (fattibilit√†)."
        },
        {
            id: 145,
            text: "Nel contesto di UP, l'Agile Modeling suggerisce che il valore della modellazione risiede principalmente nella creazione di documenti di specifiche affidabili e completi.",
            correct: false,
            explanation: "L'Agile Modeling suggerisce che il valore della modellazione √® quello di migliorare la comprensione, anzich√© quello di documentare delle specifiche affidabili."
        },
        {
            id: 146,
            text: "Un Attore di Supporto in un caso d'uso √® colui che utilizza il sistema per raggiungere i propri obiettivi utente.",
            correct: false,
            explanation: "L'Attore di Supporto √® colui che offre un servizio al sistema. L'Attore Primario √® colui che raggiunge gli obiettivi utente utilizzando i servizi del sistema."
        },
        {
            id: 147,
            text: "Quando si scrive un caso d'uso in stile essenziale, la descrizione si concentra sulle azioni concrete dell'utente e i dettagli specifici dell'interfaccia utente.",
            correct: false,
            explanation: "Lo stile essenziale implica che la narrativa √® espressa a livello di intenzioni e responsabilit√†, ignorando l'interfaccia utente e rimanendo indipendente dai dettagli tecnologici."
        },
        {
            id: 148,
            text: "Il \"Test EBP\" (Elementary Business Process) per verificare l'utilit√† di un caso d'uso chiede se l'attivit√† descritta dal caso d'uso aggiunge un valore di business misurabile.",
            correct: true,
            explanation: "Un processo di business elementare √® un'attivit√† che aggiunge un valore di business misurabile. Il Test EBP valuta se il caso d'uso rappresenta una interazione di valore."
        },
        {
            id: 149,
            text: "Un caso d'uso dettagliato, per superare il Test della Dimensione, dovrebbe idealmente essere descritto in una singola pagina.",
            correct: false,
            explanation: "Per superare il Test della Dimensione, un caso d'uso dettagliato normalmente comprende diversi passi e richiede da 3 a 10 pagine di testo. Una singola azione o passo raramente costituisce un caso d'uso utile."
        },
        {
            id: 150,
            text: "Il Modello di Dominio ha lo scopo di descrivere i concetti chiave del dominio del problema e le loro relazioni, servendo anche come ispirazione per le classi del software.",
            correct: true,
            explanation: "Il Modello di Dominio descrive i concetti significativi del sistema come oggetti del dominio e relaziona i concetti. Serve a comprendere il dominio e il suo vocabolario, definire un linguaggio comune, ed √® una fonte di ispirazione per l'OOD, riducendo il \"gap di rappresentazione\"."
        },
        {
            id: 151,
            text: "In un diagramma delle classi UML che rappresenta un Modello di Dominio, le associazioni dovrebbero indicare la direzione di navigabilit√† tra le classi software.",
            correct: false,
            explanation: "Le associazioni in un modello di dominio sono per natura bidirezionali. La direzione di lettura (indicata opzionalmente) non √® una specifica di visibilit√† o navigabilit√† tra entit√† software."
        },
        {
            id: 152,
            text: "I Diagrammi di Sequenza di Sistema (SSD) mostrano l'ordine e la logica delle interazioni tra gli oggetti interni del sistema software.",
            correct: false,
            explanation: "I Diagrammi di Sequenza di Sistema servono a rappresentare gli eventi di input e output che coinvolgono il sistema durante un'interazione con gli attori esterni, vedendo il sistema come una scatola nera. I diagrammi di sequenza (non di sistema) mostrano le interazioni tra gli oggetti interni."
        },
        {
            id: 153,
            text: "Le post-condizioni in un contratto descrivono le azioni che il sistema deve eseguire per soddisfare l'operazione, come istruzioni di database o chiamate a metodi specifici.",
            correct: false,
            explanation: "Un contratto descrive i cambiamenti richiesti dall'esecuzione di una operazione di sistema in termini di oggetti del Modello di Dominio, senza per√≤ descrivere come devono essere ottenuti. Le post-condizioni descrivono lo stato degli oggetti dopo l'operazione, non le azioni per arrivarci."
        },
        {
            id: 154,
            text: "Un'operazione di sistema di \"Trasformazione\" non modifica lo stato del sistema e per questo non richiede post-condizioni nel suo contratto.",
            correct: false,
            explanation: "Un'operazione di sistema di Trasformazione modifica lo stato del sistema e per questo motivo dovrebbe avere delle post-condizioni che descrivono tali modifiche. Le operazioni di Interrogazione non modificano lo stato e non hanno post-condizioni."
        },
        {
            id: 155,
            text: "La Progettazione Orientata agli Oggetti (OOD) si concentra principalmente sulla definizione di oggetti software e su come questi dovrebbero collaborare per soddisfare i requisiti.",
            correct: true,
            explanation: "La progettazione orientata agli oggetti pone l'enfasi sulla definizione di oggetti software e del modo in cui questi collaborano per soddisfare i requisiti."
        },
        {
            id: 156,
            text: "Secondo il principio GRASP \"Information Expert\", la responsabilit√† di salvare un oggetto nel database dovrebbe essere assegnata alla classe che rappresenta quell'oggetto (ad es. la classe Sale dovrebbe salvare se stessa).",
            correct: false,
            explanation: "In generale, l'Expert non si applica alla persistenza (salvataggio in DB) perch√© assegnare questa responsabilit√† alla classe stessa causerebbe problemi di bassa coesione (si occupa anche di persistenza), alto accoppiamento (legata a classi di sistema come i driver DB) e duplicazione logica. Questo principio architetturale di base suggerisce di separare diverse logiche in sottosistemi."
        },
        {
            id: 157,
            text: "Il pattern GoF Strategy consente di definire una famiglia di algoritmi e di renderli intercambiabili, permettendo ai clienti di utilizzare diversi algoritmi in modo indipendente.",
            correct: true,
            explanation: "Il pattern Strategy consente la definizione di una famiglia d'algoritmi, incapsula ognuno e gli fa intercambiabili fra di loro. Permette di modificare gli algoritmi in modo indipendente dai clienti e disaccoppia gli algoritmi dai clienti."
        },
        {
            id: 158,
            text: "Il pattern GoF Iterator espone la struttura interna di una collezione per permettere al chiamante di accedere e percorrere i suoi elementi.",
            correct: false,
            explanation: "Il pattern Iterator suggerisce l'implementazione di un oggetto che consenta l'accesso e percorso della collezione, fornendo una interfaccia standard che nasconde la struttura interna."
        },
        {
            id: 159,
            text: "Nel pattern GoF Visitor, il ConcreteVisitor √® l'oggetto che viene visitato dalla struttura dati.",
            correct: false,
            explanation: "Nel pattern Visitor, il ConcreteVisitor √® l'oggetto che percorre la collezione e applica un metodo specifico su ogni oggetto (Element) visitato. Gli oggetti della collezione (Element) sono quelli che vengono visitati."
        },
        {
            id: 160,
            text: "Il Modello-Vista (Model-View) Separation Principle suggerisce di separare gli oggetti che gestiscono la logica applicativa (Modello/Dominio) da quelli che gestiscono l'interfaccia utente (Vista/UI).",
            correct: true,
            explanation: "Il principio di separazione Modello-Vista stabilisce che il Modello (strato di dominio, oggetti con logica applicativa) e la Vista (strato UI, oggetti interfaccia utente) devono essere separati. Gli oggetti UI delegano le richieste di logica applicativa agli oggetti non UI (oggetti di dominio)."
        },
        {
            id: 161,
            text: "I test unitari hanno lo scopo di verificare il funzionamento complessivo del sistema software dal punto di vista dell'utente, considerando il sistema come una scatola nera.",
            correct: false,
            explanation: "I test unitari testano singole unit√† di codice, non il sistema nel suo complesso. I test di accettazione sono quelli che verificano il funzionamento complessivo del sistema a scatola nera dal punto di vista dell'utente, con riferimento ai casi d'uso."
        },
        {
            id: 162,
            text: "La fase di Verifica in un test unitario consiste nel preparare gli oggetti e le risorse necessarie per l'esecuzione del test.",
            correct: false,
            explanation: "La fase di Preparazione (Setup) crea l'oggetto o il gruppo di oggetti da verificare e prepara risorse. La fase di Verifica valuta se i risultati ottenuti corrispondono a quelli attesi."
        },
        {
            id: 163,
            text: "L‚Äôanalisi orientata agli oggetti √® guidata dalle responsabilit√†.",
            correct: false,
            explanation: "No, √® la progettazione orientata agli oggetti ad essere guidata dalle responsabilit√†."
        },
        {
            id: 164,
            text: "L‚Äôanalisi orientata agli oggetti considera un progetto software come una ‚Äúcomunit√† di oggetti‚Äù con responsabilit√† che collaborano.",
            correct: false,
            explanation: "No, √® la progettazione orientata agli oggetti che considera un progetto software come una ‚Äúcomunit√† di oggetti‚Äù con responsabilit√† che collaborano."
        },
        {
            id: 165,
            text: "Identificazione delle responsabilit√†, assegnazione di queste responsabilit√†, indagine di come soddisfare queste responsabilit√† sono i passi della ‚Äúresponsibility-driven development‚Äù.",
            correct: true,
            explanation: "Il Responsibility-Driven Development si basa esattamente su quei passaggi: identificare responsabilit√†, assegnarle agli oggetti e determinare come realizzarle."
        },
        {
            id: 166,
            text: "Controller, High Cohesion, Abstract Factory sono alcuni esempi di pattern GRASP.",
            correct: false,
            explanation: "Controller e High Cohesion fanno parte dei pattern GRASP, mentre Abstract Factory √® un pattern GoF, non GRASP."
        },
        {
            id: 167,
            text: "I pattern GRASP sono lo strumento principale utilizzato nella disciplina dei requisiti di UP.",
            correct: false,
            explanation: "I pattern GRASP vengono impiegati nella progettazione orientata agli oggetti, non come strumento principale per la raccolta dei requisiti in UP."
        },
        {
            id: 168,
            text: "UP organizza temporalmente il ciclo di sviluppo in quattro iterazioni e le iterazioni in diverse fasi.",
            correct: false,
            explanation: "In UP si parla di quattro fasi (ideazione, elaborazione, costruzione, transizione), ciascuna delle quali pu√≤ contenere pi√π iterazioni; non di quattro iterazioni complessive."
        },
        {
            id: 169,
            text: "Ideazione, elaborazione, costruzione e transizione di UP sono separate temporalmente e non si intrecciano mai.",
            correct: true,
            explanation: "Sono fasi distinte e non si intrecciano mai. "
        },
        {
            id: 170,
            text: "Specifica, sviluppo, convalida ed evoluzione in UP sono attivit√† separate temporalmente e non si intrecciano mai.",
            correct: false,
            explanation: "In UP le discipline (specifica, sviluppo, convalida, evoluzione, ecc.) avvengono in modo concorrente durante le iterazioni, non in sequenza isolata."
        },
        {
            id: 171,
            text: "Durante lo sviluppo tramite UP non si fa uso di meccanismi di refactoring per far fronte ai cambiamenti.",
            correct: false,
            explanation: "UP incoraggia il refactoring continuo all‚Äôinterno delle iterazioni per gestire i cambiamenti in modo iterativo."
        },
        {
            id: 172,
            text: "Modellazione del business, requisiti, progettazione, implementazione, test, rilascio in UP sono separate temporalmente e non si intrecciano mai.",
            correct: false,
            explanation: "Le discipline di UP (modellazione del business, requisiti, progettazione, implementazione, test, rilascio, ecc.) si svolgono in parallelo all‚Äôinterno di ciascuna iterazione, non in fasi separate."
        },
        {
            id: 173,
            text: "Il test-driven development √® una pratica promossa dal metodo a cascata che prevede lo sviluppo preceduto dai test.",
            correct: false,
            explanation: "Il TDD √® nato nell‚Äôambito dell‚ÄôExtreme Programming, non nel modello a cascata."
        },
        {
            id: 174,
            text: "I test unitari hanno lo scopo di verificare la comunicazione tra specifiche parti del sistema.",
            correct: false,
            explanation: "I test unitari verificano il corretto funzionamento di singole unit√† di codice, non la comunicazione tra moduli."
        },
        {
            id: 175,
            text: "I test unitari hanno lo scopo di verificare il collegamento complessivo tra tutti gli elementi del sistema.",
            correct: false,
            explanation: "Il test unitario controlla componenti isolate; verificare il collegamento complessivo √® compito dei test di integrazione o di sistema."
        },
        {
            id: 176,
            text: "I test unitari si compongono di preparazione, esecuzione, verifica e rilascio.",
            correct: true,
            explanation: "Un tipico ciclo di un test unitario include setup (preparazione), esecuzione, assertion (verifica) e teardown (rilascio)."
        },
        {
            id: 177,
            text: "Il test-driven development e il refactoring sono pratiche promosse in particolar modo dallo sviluppo noto come extreme programming.",
            correct: true,
            explanation: "TDD e refactoring sono due pratiche cardine dell‚ÄôExtreme Programming."
        },
        {
            id: 178,
            text: "Il pattern Strategy si occupa del modo in cui un oggetto esegue un determinato compito ed incapsula un algoritmo.",
            correct: true,
            explanation: "Strategy definisce una famiglia di algoritmi intercambiabili e la scelta del comportamento √® delegata a classi diverse che incapsulano ciascun algoritmo."
        },
        {
            id: 179,
            text: "Il pattern State si occupa del modo in cui un oggetto esegue un determinato compito ed incapsula un algoritmo.",
            correct: false,
            explanation: "State incapsula stati diversi di un oggetto e cambia comportamento in base allo stato, non in base a algoritmi intercambiabili."
        },
        {
            id: 180,
            text: "Il pattern State consente la definizione di una famiglia di algoritmi, intercambiabili tra loro.",
            correct: false,
            explanation: "La definizione di una famiglia di algoritmi intercambiabili √® caratteristica del pattern Strategy, non dello State."
        },
        {
            id: 181,
            text: "Il pattern State disaccoppia gli algoritmi dei clienti che vogliono usarli dinamicamente.",
            correct: false,
            explanation: "Disaccoppiare algoritmi e clienti √® compito del pattern Strategy; State disaccoppia invece il comportamento in base allo stato interno."
        },
        {
            id: 182,
            text: "Il pattern State e il pattern Strategy sono sintatticamente equivalenti ma differiscono nell‚Äôapplicazione.",
            correct: false,
            explanation: "Sono sintatticamente diversi."
        },
        {
            id: 183,
            text: "Le caratteristiche essenziali di un software sono Mantenibilit√†, Fidatezza, Efficienza e Accettabilit√†.",
            correct: true,
            explanation: "Si, sono proprio loro."
        },
        {
            id: 184,
            text: "Un processo per lo sviluppo del software descrive un approccio disciplinato alla costruzione, rilascio ed eventualmente manutenzione del software. Ci sono quattro attivit√† fondamentali di processo: Specifiche, Sviluppo, Convalida e Evoluzione/manutenzione.",
            correct: true,
            explanation: "Si, sono proprio loro."
        },
        {
            id: 185,
            text: "La problematica maggiore durante lo sviluppo del software sono i cambiamenti (dovuti dal cliente, adeguamenti tecnici o di contesto).",
            correct: true,
            explanation: "Occupano del tempo, durante il quale non √® garantito che le cose rimangano invariate."
        },
        {
            id: 186,
            text: "Unified Process (UP) organizza il lavoro e le iterazioni in quattro fasi NON sequenziali. La fine di ogni fase corrisponde a una milestone: Ideazione, Elaborazione, Costruzione e Transizione.",
            correct: false,
            explanation: "Unified Process (UP) organizza il lavoro e le iterazioni in quattro fasi sequenziali. La fine di ogni fase corrisponde a una milestone: Ideazione, Elaborazione, Costruzione e Transizione."
        },
        {
            id: 187,
            text: "L‚Äôelaborazione √® la serie finale di iterazioni in cui si consolidano i requisiti e si sviluppa il nucleo dell'architettura del sistema.",
            correct: false,
            explanation: "L‚Äôelaborazione √® la serie INIZIALE di iterazioni in cui si consolidano i requisiti e si sviluppa il nucleo dell'architettura del sistema."
        },
        {
            id: 188,
            text: "Il modello di dominio √® una parte della fase dei requisiti che consiste in una rappresentazione testuale che descrive i concetti fondamentali di un sistema, mettendo in evidenza le entit√† principali del dominio e le loro relazioni.",
            correct: false,
            explanation: "Il modello di dominio √® una parte di modellazione del business che consiste in una rappresentazione visuale che descrive i concetti fondamentali di un sistema, mettendo in evidenza le entit√† principali del dominio e le loro relazioni. "
        },
        {
            id: 189,
            text: "Il Diagramma di Sequenza di Sistema (SSD) √® uno strumento della disciplina dei requisiti che serve a rappresentare gli eventi di input e output che coinvolgono il sistema durante un'interazione con gli attori esterni.",
            correct: true,
            explanation: "Definizione corretta."
        },
        {
            id: 190,
            text: "L‚Äôarchitettura a strati (layered architecture) suddivide un sistema complesso in un insieme di elementi software che, per quanto possibile, possano essere sviluppati e modificati ciascuno indipendentemente dagli altri.",
            correct: true,
            explanation: "Definizione corretta."
        },
        {
            id: 191,
            text: "I modelli statici descrivono il comportamento del sistema e le interazioni tra gli oggetti (ad esempio, con i diagrammi di sequenza).",
            correct: false,
            explanation: "I modelli dinamici descrivono il comportamento del sistema e le interazioni tra gli oggetti (ad esempio, con i diagrammi di sequenza)."
        },
        {
            id: 192,
            text: "I modelli dinamici rappresentano la struttura del sistema, definendo classi, attributi e relazioni (tipicamente attraverso i diagrammi delle classi).",
            correct: false,
            explanation: "I modelli statici rappresentano la struttura del sistema, definendo classi, attributi e relazioni (tipicamente attraverso i diagrammi delle classi)."
        },
        {
            id: 193,
            text: "I GRASP (General Responsibility Assignment Software Patterns) sono un insieme di pattern utilizzati per assegnare in modo efficace le responsabilit√† agli oggetti in un sistema Object Oriented.",
            correct: true,
            explanation: "Definizione corretta."
        },
        {
            id: 194,
            text: "I pattern GoF promuovono l‚Äôuso dell'ereditariet√† rispetto alla composizione, in quanto la composizione evita i problemi di dipendenza.",
            correct: false,
            explanation: "I pattern GoF promuovono l‚Äôuso della composizione rispetto all‚Äôereditariet√†, in quanto la composizione evita i problemi di dipendenza."
        },
        {
            id: 195,
            text: "I test end-to-end verificano il funzionamento delle piccole parti (unit√†) del sistema.",
            correct: false,
            explanation: "I test end-to-end verificano il collegamento complessivo tra tutti gli elementi del sistema."
        },
        {
            id: 196,
            text: "Il refactoring √® un metodo strutturato e disciplinato per scrivere o ristrutturare del codice esistente modificando il comportamento esterno.",
            correct: false,
            explanation: "Il refactoring √® un metodo strutturato e disciplinato per scrivere o ristrutturare del codice esistente senza per√≤ modificare il comportamento esterno."
        },
        {
            id: 197,
            text: "I test unitari verificano il funzionamento delle piccole parti (unit√†) del sistema. Un metodo di test unitario √® logicamente composto da quattro parti: Preparazione, Esecuzione, Verifica e Rilascio.",
            correct: true,
            explanation: "I test unitari verificano il funzionamento delle piccole parti (unit√†) del sistema. Un metodo di test unitario √® logicamente composto da quattro parti: Preparazione, Esecuzione, Verifica e Rilascio."
        },
        {
            id: 198,
            text: "L‚Äôarchitettura logica di un sistema software √® la macro-organizzazione su larga scala delle classi software in package, sottoinsiemi e strati.",
            correct: true,
            explanation: "Definizione corretta."
        },
        {
            id: 199,
            text: "Nei contratti le pre-condizioni definiscono lo stato del sistema necessario affinch√© un‚Äôoperazione possa essere eseguita mentre le post-condizioni descrivono gli effetti dell‚Äôoperazione sul modello di dominio.",
            correct: true,
            explanation: "Definizione corretta."
        }

    ];

    let questions = []; 

    function shuffleArray(array) {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
    }

    document.addEventListener('DOMContentLoaded', () => {
        const dom = {
            quizContent: document.getElementById('quizContent'),
            progressFill: document.getElementById('progressFill'),
            currentQuestion: document.getElementById('currentQuestion'),
            totalQuestions: document.getElementById('totalQuestions'),
            questionJumpSelect: document.getElementById('questionJump'),
            questionMapContainer: document.getElementById('questionMap'),
            prevBtn: document.getElementById('prevBtn'),
            nextBtn: document.getElementById('nextBtn'),
            showAnswerBtn: document.getElementById('showAnswerBtn'),
            stopBtn: document.getElementById('stopBtn'),
            restartBtn: document.getElementById('restartBtn'),
            results: document.getElementById('results'),
            scorePercentage: document.getElementById('scorePercentage'),
            correctStat: document.querySelector('#correctStat .stat-value'),
            incorrectStat: document.querySelector('#incorrectStat .stat-value'),
            answeredCorrectStat: document.querySelector('#answeredCorrectStat .stat-value'),
            answeredIncorrectStat: document.querySelector('#answeredIncorrectStat .stat-value'),
            scoreCircle: document.getElementById('scoreCircle'),
            progressSection: document.querySelector('.progress-section'),
            controls: document.querySelector('.controls'),
            currentCorrectCount: document.getElementById('currentCorrectCount'),
            currentIncorrectCount: document.getElementById('currentIncorrectCount'),
        };

        let state = {
            currentQuestionIndex: 0,
            userAnswers: [],
            isShowingAnswer: false, 
        };

        function initQuiz() {
            const numQuestionsRequestedStr = getQueryParam('numQuestions');
            let tempQuestionsFull = shuffleArray([...originalQuestions]); 

            if (numQuestionsRequestedStr && numQuestionsRequestedStr !== 'all') {
                const count = parseInt(numQuestionsRequestedStr, 10);
                if (!isNaN(count) && count > 0 && count < tempQuestionsFull.length) {
                    questions = tempQuestionsFull.slice(0, count); 
                } else if (!isNaN(count) && count >= tempQuestionsFull.length) {
                    questions = tempQuestionsFull; 
                } else {
                    questions = tempQuestionsFull; 
                }
            } else {
                questions = tempQuestionsFull;
            }
            
            state.currentQuestionIndex = 0;
            state.userAnswers = new Array(questions.length).fill(null).map(() => ({
                answer: null, 
                correct: null // Indica se la domanda √® stata valutata (Mostra Risposta cliccato)
            }));

            dom.results.classList.add('hidden');
            dom.quizContent.classList.remove('hidden');
            dom.controls.classList.remove('hidden');
            dom.progressSection.classList.remove('hidden');

            if (questions.length === 0) {
                dom.quizContent.innerHTML = "<p style='text-align:center; font-size:1.2rem; color:#6b7280;'>Nessuna domanda disponibile per i criteri selezionati.</p>";
                dom.controls.classList.add('hidden');
                dom.progressSection.classList.add('hidden');
                if (dom.questionJumpSelect) dom.questionJumpSelect.disabled = true;
                if (dom.questionMapContainer) dom.questionMapContainer.innerHTML = '';
                if (dom.totalQuestions) dom.totalQuestions.textContent = '0'; 
                return;
            }
            if (dom.questionJumpSelect) dom.questionJumpSelect.disabled = false;
            if (dom.totalQuestions) dom.totalQuestions.textContent = questions.length; 

            populateQuestionJump();
            populateQuestionMap();
            loadQuestion(); // Carica la prima domanda (o la domanda corrente dopo un restart)
            updateProgress(); 
            updateNavigation();
            updateCurrentStats();
        }

        function loadQuestion() {
            if (questions.length === 0) {
                console.log("Array 'questions' √® vuoto. Impossibile caricare la domanda.");
                return;
            }
            if (state.currentQuestionIndex < 0 || state.currentQuestionIndex >= questions.length) {
                console.error("Indice della domanda corrente (" + state.currentQuestionIndex + ") √® fuori dai limiti per l'array 'questions' di lunghezza " + questions.length);
                return;
            }

            // RESETTA isShowingAnswer per la NUOVA domanda che stiamo caricando
            state.isShowingAnswer = false; 

            const question = questions[state.currentQuestionIndex];
            const userAnswerObj = state.userAnswers[state.currentQuestionIndex];

            console.log("--- DEBUG loadQuestion ---");
            console.log("Indice corrente:", state.currentQuestionIndex);
            console.log("Oggetto 'question':", question); 
            if (question) {
                console.log("Testo della domanda:", question.text);
                console.log("Spiegazione:", question.explanation);
                console.log("ID domanda:", question.id);
            } else {
                console.error("L'oggetto 'question' √® undefined per l'indice corrente!");
                 dom.quizContent.innerHTML = '<p>Errore: Dati della domanda non disponibili.</p>';
                return; // Esce se la domanda non √® valida
            }
            console.log("--- FINE DEBUG ---");

            dom.quizContent.innerHTML = `  
                <div class="question-card" data-question-id="${question.id}">
                    <div class="question-number">Domanda ${state.currentQuestionIndex + 1}</div>
                    <div class="question-text">${question.text}</div>
                    <div class="options">
                        <div class="option" data-answer="true">‚úì Vero</div>
                        <div class="option" data-answer="false">‚úó Falso</div>
                    </div>
                    <div class="explanation hidden">
                        <h4>Spiegazione:</h4>
                        <p>${question.explanation}</p>
                    </div>
                </div>
            `;

            const optionsContainer = dom.quizContent.querySelector('.options');
            if (optionsContainer) {
                 optionsContainer.addEventListener('click', handleOptionClick);
            }
            
            // Controlla se questa domanda √® GIA' STATA VALUTATA (Mostra Risposta premuto in precedenza per questa domanda)
            if (userAnswerObj.correct !== null) { 
                state.isShowingAnswer = true; // La risposta √® gi√† stata mostrata per questa domanda
                
                // Applica gli stili selected/correct/incorrect e disabilita le opzioni
                const selectedOptionEl = dom.quizContent.querySelector(`.option[data-answer="${userAnswerObj.answer}"]`);
                if (selectedOptionEl) selectedOptionEl.classList.add('selected');

                dom.quizContent.querySelectorAll('.option').forEach(opt => {
                    opt.classList.add('disabled');
                    const optionValue = opt.dataset.answer === 'true';
                    if (optionValue === question.correct) {
                        opt.classList.add('correct');
                    } else if (opt === selectedOptionEl && !userAnswerObj.correct) { 
                        opt.classList.add('incorrect');
                    }
                });
                dom.quizContent.querySelector('.explanation').classList.remove('hidden');
            } else if (userAnswerObj.answer !== null) {
                // La domanda √® stata risposta ma non ancora valutata (Mostra Risposta non premuto)
                // Ripristina solo lo stato 'selected'
                const selectedOptionEl = dom.quizContent.querySelector(`.option[data-answer="${userAnswerObj.answer}"]`);
                if (selectedOptionEl) selectedOptionEl.classList.add('selected');
            }


            // Aggiorna la visibilit√† dei bottoni in base a state.isShowingAnswer
            // (che ora riflette se la risposta per la *domanda corrente* √® stata mostrata)
            dom.showAnswerBtn.classList.toggle('hidden', state.isShowingAnswer);
            dom.nextBtn.classList.toggle('hidden', !state.isShowingAnswer);

            updateQuestionJumpHighlight();
            updateQuestionMapStyles();
            updateNavigation();
            updateCurrentStats();
        }

        function handleOptionClick(event) {
            const target = event.target.closest('.option');
            // MODIFICA: controlla se la risposta √® stata mostrata per la domanda corrente
            // O se la domanda corrente √® gi√† stata VALUTATA (state.userAnswers[state.currentQuestionIndex].correct !== null)
            if (!target || state.isShowingAnswer || state.userAnswers[state.currentQuestionIndex].correct !== null || !target.classList.contains('option')) {
                 console.log("Click ignorato. isShowingAnswer:", state.isShowingAnswer, "Gi√† valutata:", state.userAnswers[state.currentQuestionIndex].correct !== null);
                return;
            }

            const optionsContainer = target.closest('.options');
            if (!optionsContainer) return;

            optionsContainer.querySelectorAll('.option').forEach(opt => opt.classList.remove('selected'));
            target.classList.add('selected');

            const answer = target.dataset.answer === 'true';
            state.userAnswers[state.currentQuestionIndex].answer = answer;
        }

        function showAnswer() {
            // Se la risposta √® gi√† stata mostrata per questa domanda, non fare nulla
            if (state.isShowingAnswer) return; 

            if (state.userAnswers[state.currentQuestionIndex].answer === null) {
                alert("Per favore, seleziona una risposta prima.");
                return;
            }

            state.isShowingAnswer = true; 
            const question = questions[state.currentQuestionIndex];
            const isCorrect = state.userAnswers[state.currentQuestionIndex].answer === question.correct;
            state.userAnswers[state.currentQuestionIndex].correct = isCorrect; // Segna come valutata
            
            const options = dom.quizContent.querySelectorAll('.option');
            //  Usa userAnswerObj.answer per trovare l'opzione selezionata
            const userAnswerObj = state.userAnswers[state.currentQuestionIndex];
            const selectedOption = userAnswerObj.answer !== null ? dom.quizContent.querySelector(`.option[data-answer="${userAnswerObj.answer}"]`) : null;


            options.forEach(opt => {
                opt.classList.add('disabled');
                const optionValue = opt.dataset.answer === 'true';
                if (optionValue === question.correct) {
                    opt.classList.add('correct');
                } else if (opt === selectedOption) { // Se √® quella selezionata ed √® sbagliata
                    opt.classList.add('incorrect');
                }
            });
            
            dom.quizContent.querySelector('.explanation').classList.remove('hidden');
            dom.showAnswerBtn.classList.add('hidden');
            dom.nextBtn.classList.remove('hidden');

            updateCurrentStats();
            updateQuestionMapStyles(); // Aggiorna la mappa per riflettere lo stato corretto/sbagliato
        }

        function navigate(direction) {
            const newIndex = state.currentQuestionIndex + direction;
            if (newIndex >= 0 && newIndex < questions.length) {
                state.currentQuestionIndex = newIndex;
                loadQuestion(); 
                updateProgress();
            } else if (newIndex === questions.length) {
                showResults();
            }
        }

        function updateProgress() {
            if (questions.length === 0) return;
            const progress = ((state.currentQuestionIndex + 1) / questions.length) * 100;
            dom.progressFill.style.width = `${progress}%`;
            dom.currentQuestion.textContent = state.currentQuestionIndex + 1;
            dom.totalQuestions.textContent = questions.length; 
        }

        function updateNavigation() {
            if (questions.length === 0) {
                dom.prevBtn.disabled = true;
                dom.nextBtn.disabled = true;
                return;
            }
            dom.prevBtn.disabled = state.currentQuestionIndex === 0;
            dom.nextBtn.textContent = state.currentQuestionIndex === questions.length - 1 ? 'üèÅ Termina Quiz' : 'Successiva ‚Üí';
        }

        function updateCurrentStats() {
            const correctCount = state.userAnswers.filter(a => a.correct === true).length;
            const incorrectCount = state.userAnswers.filter(a => a.correct === false).length;
            dom.currentCorrectCount.textContent = correctCount;
            dom.currentIncorrectCount.textContent = incorrectCount;
        }

        function showResults() {
            dom.quizContent.classList.add('hidden');
            dom.controls.classList.add('hidden');
            dom.progressSection.classList.add('hidden');
            dom.results.classList.remove('hidden');

            const totalValidQuestions = questions.length; 
            const answeredCount = state.userAnswers.filter(a => a.answer !== null).length;
            const correctTotal = state.userAnswers.filter(a => a.correct === true).length;
            const incorrectTotal = state.userAnswers.filter(a => a.correct === false).length;

            const percentageTotal = totalValidQuestions > 0 ? Math.round((correctTotal / totalValidQuestions) * 100) : 0;

            dom.scorePercentage.textContent = `${percentageTotal}%`;
            dom.correctStat.textContent = correctTotal;
            dom.incorrectStat.textContent = incorrectTotal;
            dom.answeredCorrectStat.textContent = `${correctTotal} / ${answeredCount}`;
            dom.answeredIncorrectStat.textContent = `${incorrectTotal} / ${answeredCount}`;

            const gradientDegrees = (percentageTotal / 100) * 360;
            dom.scoreCircle.style.background = `conic-gradient(#4f46e5 ${gradientDegrees}deg, #e2e8f0 ${gradientDegrees}deg)`;
        }

        function populateQuestionJump() {
            if (!dom.questionJumpSelect || questions.length === 0) return;
            dom.questionJumpSelect.innerHTML = '';
            questions.forEach((_, index) => { 
                const option = document.createElement('option');
                option.value = index;
                option.textContent = index + 1;
                dom.questionJumpSelect.appendChild(option);
            });
            dom.questionJumpSelect.value = state.currentQuestionIndex;
        }

        function updateQuestionJumpHighlight() {
            if (dom.questionJumpSelect) {
                dom.questionJumpSelect.value = state.currentQuestionIndex;
            }
        }

        function handleQuestionJump(event) {
            const newIndex = parseInt(event.target.value, 10);
            if (newIndex >= 0 && newIndex < questions.length && newIndex !== state.currentQuestionIndex) {
                state.currentQuestionIndex = newIndex;
                loadQuestion();
                updateProgress();
            }
        }

        function populateQuestionMap() {
            if (!dom.questionMapContainer || questions.length === 0) return;
            dom.questionMapContainer.innerHTML = '';
            questions.forEach((_, index) => { 
                const marker = document.createElement('div');
                marker.classList.add('question-marker');
                marker.dataset.index = index;
                marker.textContent = index + 1;
                marker.setAttribute('role', 'button');
                marker.setAttribute('tabindex', '0'); 
                marker.setAttribute('aria-label', `Vai alla domanda ${index + 1}`);
                marker.addEventListener('click', () => handleQuestionMarkerClick(index));
                marker.addEventListener('keydown', (event) => { 
                    if (event.key === 'Enter' || event.key === ' ') {
                        handleQuestionMarkerClick(index);
                    }
                });
                dom.questionMapContainer.appendChild(marker);
            });
            updateQuestionMapStyles();
        }

        function handleQuestionMarkerClick(index) {
            if (index >= 0 && index < questions.length && index !== state.currentQuestionIndex) {
                state.currentQuestionIndex = index;
                loadQuestion();
                updateProgress();
            }
        }

        function updateQuestionMapStyles() {
            if (!dom.questionMapContainer || questions.length === 0) return;
            const markers = dom.questionMapContainer.querySelectorAll('.question-marker');
            markers.forEach(marker => {
                const index = parseInt(marker.dataset.index, 10);
                marker.classList.remove('current', 'answered', 'correct', 'incorrect');

                if (index === state.currentQuestionIndex) {
                    marker.classList.add('current');
                }

                const answerInfo = state.userAnswers[index];
                if (answerInfo.correct === true) {
                    marker.classList.add('correct');
                } else if (answerInfo.correct === false) {
                    marker.classList.add('incorrect');
                } else if (answerInfo.answer !== null) { 
                    marker.classList.add('answered');
                }
            });
        }
        
        dom.showAnswerBtn.addEventListener('click', showAnswer);
        if(dom.stopBtn) dom.stopBtn.addEventListener('click', showResults);
        dom.nextBtn.addEventListener('click', () => navigate(1));
        dom.prevBtn.addEventListener('click', () => navigate(-1));
        dom.restartBtn.addEventListener('click', initQuiz);
        if (dom.questionJumpSelect) {
            dom.questionJumpSelect.addEventListener('change', handleQuestionJump);
        }
        
        initQuiz(); 
    });
</script>
</body>
</html>